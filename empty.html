<!doctype html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="application-name" content="TiddlyWiki" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.0.0-alpha.9" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="format-detection" content="telephone=no">
<meta name="copyright" content="TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)

Copyright © Jeremy Ruston 2004-2007
Copyright © UnaMesa Association 2007-2013

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the UnaMesa Association nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
" />
<title> — </title>
<!----------- This is a Tiddlywiki file. The points of interest in the file are marked with this pattern -----------><!----------- Raw markup ----------->

</head>
<body>
<!----------- Static styles ----------->
<div id="styleArea">
<style data-tiddler-title="$:/core/styles/boot.css" data-tiddler-type="text/css" type="text/css">/*
Basic styles used before we boot up the parsing engine
*/

/*
Password prompt
*/
.tw-password-wrapper {
    font-family: sans-serif;
	z-index: 20000;
	position: fixed;
	text-align: center;
	width: 480px;
	top: 4em;
    left: 50%;
    margin-left: -264px; /* - width/2 - paddingHorz/2 - border */
	padding: 16px 16px 16px 16px;
	-webkit-border-radius: 8px;
	-moz-border-radius: 8px;
	border-radius: 8px;
	color: #000;
	text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
	background-color: rgb(197, 235, 183);
	border: 8px solid rgb(164, 197, 152);
}

.tw-password-wrapper form {
	text-align: left;
}

.tw-password-wrapper h1 {
	font-size: 16px;
	line-height: 20px;
}

</style>
</div>
<!----------- Static content for Google and browsers without JavaScript ----------->
<noscript>
<div id="splashArea">

</div>
</noscript>
<!----------- Miscellaneous shadow tiddlers ----------->
<div id="shadowArea" style="display:none;">
<div title="$:/core/copyright.txt" type="text/plain">
<pre>TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)

Copyright © Jeremy Ruston 2004-2007
Copyright © UnaMesa Association 2007-2013

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the UnaMesa Association nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
</pre>
</div>
<div type="image/svg+xml" title="$:/core/images/close-button.svg">
<pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xl=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; viewBox=&quot;222 150 56 56&quot; width=&quot;22pt&quot; height=&quot;22pt&quot;&gt;&lt;g stroke=&quot;none&quot; stroke-opacity=&quot;1&quot; stroke-dasharray=&quot;none&quot; fill=&quot;none&quot; fill-opacity=&quot;1&quot;&gt;&lt;g&gt;&lt;path d=&quot;M 249.56668 185.88827 L 267.06757 203.38916 C 269.26427 205.58586 272.82582 205.58586 275.02252 203.38916 L 275.02252 203.38916 C 277.21922 201.19246 277.21922 197.63091 275.02252 195.43421 L 257.52163 177.93332 L 275.38916 160.06579 C 277.58586 157.86909 277.58586 154.30754 275.38916 152.11084 C 273.19246 149.91414 269.63091 149.91414 267.43421 152.11084 L 249.56668 169.97837 L 232.06579 152.47748 L 232.06579 152.47748 C 232.06579 152.47748 232.06579 152.47748 232.06579 152.47748 C 229.86909 150.28078 226.30754 150.28078 224.11084 152.47748 L 224.11084 152.47748 C 221.91414 154.674175 221.91414 158.23573 224.11084 160.43243 L 241.61173 177.93332 L 224.47748 195.06757 L 224.47748 195.06757 L 224.47748 195.06757 C 224.47748 195.06757 224.47748 195.06757 224.47748 195.06757 C 222.28078 197.26427 222.28078 200.82583 224.47748 203.02252 L 224.47748 203.02252 C 226.67418 205.21922 230.23573 205.21922 232.43243 203.02252 Z&quot; fill=&quot;#ccc&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;
</pre>
</div>
<div type="image/svg+xml" title="$:/core/images/edit-button.svg">
<pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xl=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; viewBox=&quot;244 193 20 22&quot; width=&quot;20pt&quot; height=&quot;22pt&quot;&gt;&lt;g stroke=&quot;none&quot; stroke-opacity=&quot;1&quot; stroke-dasharray=&quot;none&quot; fill=&quot;none&quot; fill-opacity=&quot;1&quot;&gt;&lt;g&gt;&lt;title&gt;Body&lt;/title&gt;&lt;path d=&quot;M 257.33334 196.80951 L 245.90476 207.2857 L 244 212.0476 L 248.7619 210.14284 L 260.19048 199.66665 Z M 259.2381 194.90475 L 258.28566 195.85716 L 261.14284 198.71428 L 262.09522 197.76187 Z M 261.14286 193 L 260.19042 193.95241 L 263.04762 196.80953 L 264 195.85714 Z M 244 213.72882 C 244 213.72882 247.4281 215.43353 250.8572 213.7288 C 254.28599 212.02405 261.14284 214.86531 261.14284 214.86531 L 261.14284 213.72884 C 261.14284 213.72884 254.28577 210.88755 250.8572 212.5923 C 247.42858 214.29712 244 212.59228 244 212.59228 Z&quot; fill=&quot;#ccc&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;
</pre>
</div>
<div title="$:/messages/Download" type="text/vnd.tiddlywiki" subtitle="Download changes" footer="&lt;$button message=&quot;tw-close-tiddler&quot; class=&quot;btn btn-primary&quot;&gt;Close&lt;/$button&gt;" help="http://five.tiddlywiki.com/#help:DownloadingChanges">
<pre>Your browser only supports manual saving.

To save your modified wiki, right click on the download link below and select &quot;Download file&quot; or &quot;Save file&quot;, and then choose the folder and filename.

//You can marginally speed things up by clicking the link with the control key (Windows) or the options/alt key (Mac OS X). You will not be prompted for the folder or filename, but your browser is likely to give it an unrecognisable name -- you may need to rename the file to include an `.html` extension before you can do anything useful with it.//

On smartphones that do not allow files to be downloaded you can instead bookmark the link, and then sync your bookmarks to a desktop computer from where the wiki can be saved normally.
</pre>
</div>
<div title="$:/messages/EnterEditMode" type="text/vnd.tiddlywiki" subtitle="Editing this wiki" footer="&lt;&lt;button close class:&quot;btn btn-primary&quot;&gt;&lt;Close&gt;&gt;" help="http://five.tiddlywiki.com/#help:EditMode">
<pre>You can edit this wiki and save your changes. You are strongly advised to verify that saving is working properly before trusting ~TiddlyWiki with your data.

The following methods of saving changes are available:

* Using Firefox's built-in file system access
* Uploading to a simple server script
* Using HTML5's data URI and download attribute


[x] Don't show this message again</pre>
</div>
<div title="$:/messages/SaveInstructions" type="text/vnd.tiddlywiki" subtitle="Save your work" footer="&lt;$button message=&quot;tw-close-tiddler&quot; class=&quot;btn btn-primary&quot;&gt;Close&lt;/$button&gt;" help="http://five.tiddlywiki.com/#help:SavingChanges">
<pre>Your changes to this wiki need to be saved as a ~TiddlyWiki HTML file.

!!! Desktop browsers

# Select ''Save As'' from the ''File'' menu
# Choose a filename and location
#* Some browsers also require you to explicitly specify the file saving format as ''Webpage, HTML only'' or similar
# Close this tab

!!! Smartphone browsers

# Create a bookmark to this page
#* If you've got iCloud or Google Sync set up then the bookmark will automatically sync to your desktop where you can open it and save it as above
# Close this tab

//If you open the bookmark again in Mobile Safari you will see this message again. If you want to go ahead and use the file, just click the ''close'' button below//
</pre>
</div>
<div title="$:/core/styles/base" tags="$:/core/styles">
<pre>\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline
\define border-radius(radius)
```
  -webkit-border-radius: $radius$;
     -moz-border-radius: $radius$;
          border-radius: $radius$;
```
\end
\define box-shadow(shadow)
```
  -webkit-box-shadow: $shadow$;
     -moz-box-shadow: $shadow$;
          box-shadow: $shadow$;
```
\end

{{$:/core/styles/reset}}

html {
	font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Lucida Grande&quot;, sans-serif;
}

body {
	font-size: {{$:/core/styles/metrics##fontsize}};
	line-height: {{$:/core/styles/metrics##lineheight}};
	background-color: {{$:/core/styles/colourmappings##pagebackground}}
}

code, pre {
	padding: 0 3px 2px;
	&lt;&lt;border-radius 3px&gt;&gt;
}

code {
	padding: 1px 2px;
	color: #d14;
	background-color: #f7f7f9;
	border: 1px solid #e1e1e8;
}

pre {
	display: block;
	padding: 1em;
	margin: 0 0 1em;
	word-break: break-all;
	word-wrap: break-word;
	white-space: pre;
	white-space: pre-wrap;
	background-color: #f5f5f5;
	border: 1px solid #ccc;
}

a.tw-tiddlylink {
	text-decoration: none;
	font-style: normal;
	font-weight: normal;
	color: {{$:/core/styles/colourmappings##linkforeground}};
}

a.tw-tiddlylink:hover {
	text-decoration: underline;
}

a.tw-tiddlylink-resolves {
	font-style: normal;
	font-weight: bold;
}

a.tw-tiddlylink-missing {
	font-style: italic;
}

.btn-invisible {
	padding: 0;
	margin: 0;
	background: none;
	border: none;
}

.tw-tags-wrapper {
	margin: 0.25em 0 1em 0;
}

.tw-tag-label {
	display: inline-block;
	padding: 2px 4px;
	font-size: 11.844px;
	font-weight: bold;
	line-height: 14px;
	color: #ffffff;
	text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.44);
	white-space: nowrap;
	vertical-align: baseline;
	background-color: #999999;
	border: 1px solid rgba(0,0,0,0.0);
	&lt;&lt;border-radius 3px&gt;&gt;
	&lt;&lt;box-shadow &quot;inset 1px 1px 0 rgba(255,255,255,0.22)&quot;&gt;&gt;
}

.tw-tag-label:hover {
	&lt;&lt;box-shadow &quot;inset 0px 2em 0 rgba(0,0,0,0.22)&quot;&gt;&gt;
}

.edit-header {
}

.sidebar-header {
	position: fixed;
	top: 0;
	left: 0;
	bottom: 0;
	width: {{$:/core/styles/metrics##sidebarwidth}};
	overflow-y: auto;
	overflow-x: auto;
	-webkit-overflow-scrolling: touch;
	padding: 4em 0em 2em 2em;
	margin: 0;
}

.tw-menu-list-item {
	white-space: nowrap;
}

.story-river {
	margin-left: {{$:/core/styles/metrics##sidebarwidth}};
	padding: 2em;
}

.tw-tiddler-frame {
	padding: 3em;
	margin-bottom: 2em;
	background-color: {{$:/core/styles/colourmappings##tiddlerbackground}};
	max-width: 50em;
	&lt;&lt;box-shadow &quot;5px 5px 5px rgba(0, 0, 0, 0.1)&quot;&gt;&gt;
}

.title {
	font-weight: bold;
	font-size: 33px;
	line-height: 40px;
	color: #182955;
}

.tw-tiddler-missing .title {
  font-style: italic;
  font-weight: normal;
}

.tw-tiddler-frame .tw-tiddler-controls {
	float: right;
}

.tw-tiddler-controls .tw-button {
	margin: 0 0 0 0.5em;
}

.tw-drop-down {
	display: block;
	position: absolute;
	min-width: 20em;
	border: 1px solid {{$:/core/styles/colourmappings##dropdownborder}};
	background-color: {{$:/core/styles/colourmappings##dropdownbackground}};
	&lt;&lt;border-radius 4px&gt;&gt;
	&lt;&lt;box-shadow &quot;2px 2px 10px rgba(0, 0, 0, 0.5)&quot;&gt;&gt;
	padding: 0.5em 0em 0.5em 0em;
	margin: 0.25em 0 0 0;
	white-space: nowrap;
}

.tw-drop-down a {
	display: block;
	padding: 0em 1em 0em 1em;
}

.tw-drop-down a:hover {
	color: {{$:/core/styles/colourmappings##linkbackground}};
	background-color: {{$:/core/styles/colourmappings##linkforeground}};
	text-decoration: none;
}

.modal-backdrop {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	z-index: 1000;
	background-color: #000;
}

.modal {
	position: fixed;
	top: 50%;
	left: 50%;
	z-index: 1100;
	width: 560px;
	margin: -250px 0 0 -280px;
	background-color: #fff;
	border: 1px solid #999;
	border: 1px solid rgba(0,0,0,.3);
	&lt;&lt;border-radius 6px&gt;&gt;
	&lt;&lt;box-shadow &quot;0 3px 7px rgba(0,0,0,0.3)&quot;&gt;&gt;
}

.modal-header {
	padding: 9px 15px;
	border-bottom: 1px solid #eee;
}

.modal-header h3 {
	margin: 0;
	line-height: 30px;
}

.modal-body {
	overflow-y: auto;
	max-height: 400px;
	padding: 15px;
}

.modal-footer {
	padding: 14px 15px 15px;
	margin-bottom: 0;
	text-align: right;
	background-color: #f5f5f5;
	border-top: 1px solid #ddd;
	&lt;&lt;border-radius &quot;0 0 6px 6px&quot;&gt;&gt;
	&lt;&lt;box-shadow &quot;inset 0 1px 0 #fff&quot;&gt;&gt;;
}

.tw-edit-texteditor input, .tw-edit-texteditor textarea {
	width: 100%;
}

canvas.tw-edit-bitmapeditor  {
	cursor: crosshair;
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

img, canvas, embed {
	max-width: 100%;
}

embed {
	width: 100%;
	height: 20em;
}
</pre>
</div>
<div title="$:/core/styles/colourmappings" type="application/x-tiddler-dictionary">
<pre>tiddlerbackground: {{$:/core/styles/colours##background}}
pagebackground: {{$:/core/styles/colours##pagebackground}}
linkbackground: {{$:/core/styles/colours##background}}
linkforeground: {{$:/core/styles/colours##primary}}
dropdownbackground: {{$:/core/styles/colours##background}}
dropdownborder: {{$:/core/styles/colours##medium}}
</pre>
</div>
<div title="$:/core/styles/colours" type="application/x-tiddler-dictionary">
<pre>primary: `#6a5ccc`
background: `#fff`
pagebackground: `#ececec`
medium: `#bbb`</pre>
</div>
<div title="$:/core/styles/metrics" type="application/x-tiddler-dictionary">
<pre>fontsize: `14px`
lineheight: `20px`
sidebarwidth: `20%`
</pre>
</div>
<div title="$:/core/styles/reset" type="text/plain">
<pre>/*! normalize.css v2.1.0 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 8/9.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 8/9.
 */

audio,
canvas,
video {
    display: inline-block;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 8/9.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    font-family: sans-serif; /* 1 */
    -webkit-text-size-adjust: 100%; /* 2 */
    -ms-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari 5, and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Correct font family set oddly in Safari 5 and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre-wrap;
}

/**
 * Set consistent quote types.
 */

q {
    quotes: &quot;\201C&quot; &quot;\201D&quot; &quot;\2018&quot; &quot;\2019&quot;;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9.
 */

img {
    border: 0;
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari 5.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
}

/**
 * 1. Correct font family not being inherited in all browsers.
 * 2. Correct font size not being inherited in all browsers.
 * 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome.
 */

button,
input,
select,
textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 2 */
    margin: 0; /* 3 */
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type=&quot;button&quot;], /* 1 */
input[type=&quot;reset&quot;],
input[type=&quot;submit&quot;] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to `content-box` in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 */

input[type=&quot;checkbox&quot;],
input[type=&quot;radio&quot;] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type=&quot;search&quot;] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type=&quot;search&quot;]::-webkit-search-cancel-button,
input[type=&quot;search&quot;]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}
</pre>
</div>
<div title="$:/core/templates/css-tiddler">
<pre>&lt;!--

This template is used for saving CSS tiddlers as a style tag with data attributes representing the tiddler fields.

--&gt;`&lt;style`&lt;$fields template=' data-tiddler-$name$=&quot;$encoded_value$&quot;'&gt;&lt;/$fields&gt;` type=&quot;text/css&quot;&gt;`&lt;$view field=&quot;text&quot; format=&quot;text&quot; /&gt;`&lt;/style&gt;`</pre>
</div>
<div title="$:/templates/EditTemplate" modifier="JeremyRuston">
<pre>&lt;$view field=&quot;title&quot;/&gt; &lt;$button message=&quot;tw-delete-tiddler&quot; class=&quot;btn btn-mini btn-success&quot;&gt;delete&lt;/$button&gt; &lt;$button message=&quot;tw-save-tiddler&quot; class=&quot;btn btn-mini btn-success&quot;&gt;done&lt;/$button&gt;

@@.title
&lt;$edit field=&quot;draft.title&quot;/&gt;
@@

Type tags separated with spaces, `[[`using double square brackets`]]` if necessary:

&lt;$edit field=&quot;tags&quot;/&gt;

@@.body
&lt;$edit field=&quot;text&quot;/&gt;
@@
</pre>
</div>
<div title="$:/core/templates/html-div-tiddler">
<pre>&lt;!--

This template is used for saving tiddlers as an HTML DIV tag with attributes representing the tiddler fields.

--&gt;`&lt;div`&lt;$fields template=' $name$=&quot;$encoded_value$&quot;'&gt;&lt;/$fields&gt;`&gt;
&lt;pre&gt;`&lt;$view field=&quot;text&quot; format=&quot;htmlencoded&quot; /&gt;`&lt;/pre&gt;
&lt;/div&gt;`
</pre>
</div>
<div title="$:/core/templates/html-tiddler">
<pre>&lt;!--

This template is used for saving tiddlers as raw HTML

--&gt;&lt;$view field=&quot;text&quot; format=&quot;htmlwikified&quot; /&gt;</pre>
</div>
<div title="$:/core/templates/javascript-tiddler">
<pre>&lt;!--

This template is used for saving JavaScript tiddlers as a script tag with data attributes representing the tiddler fields.

--&gt;`&lt;script`&lt;$fields template=' data-tiddler-$name$=&quot;$encoded_value$&quot;'&gt;&lt;/$fields&gt;` type=&quot;text/javascript&quot;&gt;`&lt;$view field=&quot;text&quot; format=&quot;text&quot; /&gt;`&lt;/script&gt;`</pre>
</div>
<div title="$:/core/templates/module-tiddler">
<pre>&lt;!--

This template is used for saving JavaScript tiddlers as a script tag with data attributes representing the tiddler fields. The body of the tiddler is wrapped in a call to the `$tw.modules.define` function in order to define the body of the tiddler as a module

--&gt;`&lt;script`&lt;$fields template=' data-tiddler-$name$=&quot;$encoded_value$&quot;'&gt;&lt;/$fields&gt;` type=&quot;text/javascript&quot; data-module=&quot;yes&quot;&gt;$tw.modules.define(&quot;`&lt;$view field=&quot;title&quot; format=&quot;jsencoded&quot; /&gt;`&quot;,&quot;`&lt;$view field=&quot;module-type&quot; format=&quot;jsencoded&quot; /&gt;`&quot;,function(module,exports,require) {`&lt;$view field=&quot;text&quot; format=&quot;text&quot; /&gt;`});
&lt;/script&gt;`</pre>
</div>
<div title="$:/templates/PageTemplate">
<pre>&lt;!-- The navigator catches navigation events and updates the story and history tiddlers --&gt;
&lt;$navigator story=&quot;$:/StoryList&quot; history=&quot;$:/HistoryList&quot;&gt;

&lt;!-- The sidebar header --&gt;
&lt;header class=&quot;sidebar-header&quot;&gt;

{{SiteTitle}}.title &lt;br&gt;&lt;small&gt;{{SiteSubtitle}}&lt;/small&gt;

&lt;$list filter=&quot;[list[$:/StoryList]]&quot; history=&quot;$:/HistoryList&quot; itemClass=&quot;tw-menu-list-item&quot;/&gt;

&lt;div class=&quot;edit-controls&quot;&gt;
&lt;$button message=&quot;tw-new-tiddler&quot; class=&quot;btn btn-mini btn-success&quot;&gt;New&lt;/$button&gt;
&lt;$button message=&quot;tw-save-wiki&quot; class=&quot;btn btn-mini btn-primary&quot;&gt;Save&lt;/$button&gt;
&lt;/div&gt;

&lt;/header&gt;

&lt;!-- The story river --&gt;
&lt;section class=&quot;story-river&quot;&gt;

&lt;!-- The main story --&gt;
&lt;$list filter=&quot;[list[$:/StoryList]]&quot; history=&quot;$:/HistoryList&quot; template=&quot;$:/templates/ViewTemplate&quot; editTemplate=&quot;$:/templates/EditTemplate&quot; listview=&quot;classic&quot; itemClass=&quot;tw-tiddler-frame&quot;/&gt;

&lt;!-- Config area --&gt;
{{$:/snippets/encryptionstatus}}

&lt;!-- End of story river --&gt;
&lt;/section&gt;

&lt;/$navigator&gt;

</pre>
</div>
<div title="$:/core/templates/plain-text-tiddler">
<pre>&lt;$view field=&quot;text&quot; format=&quot;text&quot; /&gt;</pre>
</div>
<div title="$:/templates/SearchResultTemplate">
<pre>{{tw-search-result{
&lt;li&gt;

&lt;&lt;link throughField:title hover:&quot;$:/temp/SearchPreviewDropDownLocation&quot; qualifyHoverTitle:yes&gt;&lt;
&lt;&lt;view title text&gt;&gt;
&gt;&gt;

&lt;/li&gt;
}}}

&lt;&lt;reveal state:&quot;$:/temp/SearchPreviewDropDownLocation&quot; type:popup position:right qualifyTiddlerTitles:yes&gt;&lt;

&lt;div class=&quot;tw-tiddler-frame&quot; style=&quot;color: black; width: 400px;&quot;&gt;

&lt;&lt;tiddler template:SearchPreviewTemplate&gt;&gt;

&lt;/div&gt;

&gt;&gt;

</pre>
</div>
<div title="$:/core/templates/static.template.css">
<pre>{{{ [is[shadow]type[text/css]] ||$:/core/templates/plain-text-tiddler}}}
{{$:/core/styles/base}}
</pre>
</div>
<div title="$:/core/templates/static.template.html" type="text/vnd.tiddlywiki-html">
<pre>\define tw-wikilink-template() static/$uri_encoded$.html
\rules only filteredtranscludeinline transcludeinline
&lt;!doctype html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;
&lt;meta name=&quot;generator&quot; content=&quot;TiddlyWiki&quot; /&gt;
&lt;meta name=&quot;tiddlywiki-version&quot; content=&quot;{{$:/core/templates/version}}&quot; /&gt;
&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
&lt;title&gt;{{$:/core/wiki/title}}&lt;/title&gt;
&lt;div id=&quot;styleArea&quot;&gt;
{{{ [is[shadow]type[text/css]] ||$:/core/templates/css-tiddler}}}
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
{{$:/core/styles/base}}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
{{$:/templates/PageTemplate||$:/core/templates/html-tiddler}}
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<div title="$:/core/templates/static.tiddler.html">
<pre>\define tw-wikilink-template() $uri_encoded$.html
`&lt;!doctype html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;
&lt;meta name=&quot;generator&quot; content=&quot;TiddlyWiki&quot; /&gt;
&lt;meta name=&quot;tiddlywiki-version&quot; content=&quot;`{{$:/core/templates/version}}`&quot; /&gt;
&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;static.css&quot;&gt;
&lt;title&gt;`{{$:/core/wiki/title}}`&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;section class=&quot;story-river&quot;&gt;
&lt;div class=&quot;tw-tiddler-frame&quot;&gt;
`&lt;$view tiddler=&quot;$:/templates/ViewTemplate&quot; format=&quot;htmlwikified&quot;/&gt;`
&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
`</pre>
</div>
<div title="$:/templates/StaticContent" type="text/vnd.tiddlywiki">
<pre>&lt;!-- For Google, and people without JavaScript--&gt;
&lt;$list filter=&quot;[!is[shadow]sort[title]]&quot; &gt;
&lt;$view field=&quot;title&quot; format=&quot;text&quot;&gt;&lt;/$view&gt;
&lt;/$list&gt;
</pre>
</div>
<div title="$:/core/templates/store.area.template.html">
<pre>&lt;$reveal type=&quot;nomatch&quot; state=&quot;$:/isEncrypted&quot; text=&quot;yes&quot;&gt;
`&lt;div id=&quot;storeArea&quot; style=&quot;display:none;&quot;&gt;`
{{{ [!is[shadow]] ||$:/core/templates/html-div-tiddler}}}
`&lt;/div&gt;`
&lt;/$reveal&gt;
&lt;$reveal type=&quot;match&quot; state=&quot;$:/isEncrypted&quot; text=&quot;yes&quot;&gt;
`&lt;!------------- Encrypted tiddlers ---------&gt;`
`&lt;pre id=&quot;encryptedStoreArea&quot; type=&quot;text/plain&quot; style=&quot;display:none;&quot;&gt;`
&lt;$encrypt filter=&quot;[!is[shadow]]&quot;/&gt;
`&lt;/pre&gt;`
&lt;/$reveal&gt;</pre>
</div>
<div title="$:/templates/TagTemplate">
<pre>&lt;$button popup=&quot;tagpopup&quot; qualifyTiddlerTitles=&quot;yes&quot; class=&quot;btn-invisible&quot;&gt;&lt;$setstyle name=&quot;background-color&quot; value={{!!color}} class=&quot;tw-tag-label&quot;&gt;&lt;$view field=&quot;title&quot; format=&quot;text&quot; /&gt;&lt;/$setstyle&gt;&lt;/$button&gt;
&lt;$reveal state=&quot;tagpopup&quot; type=&quot;popup&quot; position=&quot;below&quot; qualifyTiddlerTitles=&quot;yes&quot; &gt;&lt;div class=&quot;tw-drop-down&quot;&gt;
&lt;$view field=&quot;title&quot; format=&quot;link&quot; /&gt;
----
&lt;$list filter=&quot;[is[current]tagging[]sort[title]]&quot;&gt;
&lt;$view field=&quot;title&quot; format=&quot;link&quot; /&gt;
&lt;/$list&gt;
&lt;/div&gt;&lt;/$reveal&gt;
</pre>
</div>
<div title="$:/core/templates/tiddlywiki5.template.html">
<pre>\rules only filteredtranscludeinline transcludeinline
&lt;!doctype html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;
&lt;meta name=&quot;application-name&quot; content=&quot;TiddlyWiki&quot; /&gt;
&lt;meta name=&quot;generator&quot; content=&quot;TiddlyWiki&quot; /&gt;
&lt;meta name=&quot;tiddlywiki-version&quot; content=&quot;{{$:/core/templates/version}}&quot; /&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;
&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;
&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
&lt;meta name=&quot;copyright&quot; content=&quot;{{$:/core/copyright.txt}}&quot; /&gt;
&lt;title&gt;{{$:/core/wiki/title}}&lt;/title&gt;
&lt;!----------- This is a Tiddlywiki file. The points of interest in the file are marked with this pattern -----------&gt;

&lt;!----------- Raw markup -----------&gt;
{{{ [tag[$:/core/wiki/rawmarkup]] ||$:/core/templates/plain-text-tiddler}}}
&lt;/head&gt;
&lt;body&gt;
&lt;!----------- Static styles -----------&gt;
&lt;div id=&quot;styleArea&quot;&gt;
{{{ [is[shadow]type[text/css]] ||$:/core/templates/css-tiddler}}}
&lt;/div&gt;
&lt;!----------- Static content for Google and browsers without JavaScript -----------&gt;
&lt;noscript&gt;
&lt;div id=&quot;splashArea&quot;&gt;
{{$:/templates/NewStaticContent||$:/core/templates/html-tiddler}}
&lt;/div&gt;
&lt;/noscript&gt;
&lt;!----------- Miscellaneous shadow tiddlers -----------&gt;
&lt;div id=&quot;shadowArea&quot; style=&quot;display:none;&quot;&gt;
{{{ [is[shadow]] -[type[text/css]] -[type[application/javascript]has[module-type]] -[type[application/javascript]library[yes]] -[[$:/core/boot.js]] -[[$:/core/bootprefix.js]] ||$:/core/templates/html-div-tiddler}}}
&lt;/div&gt;
&lt;!----------- Ordinary tiddlers -----------&gt;
{{$:/core/templates/store.area.template.html}}
&lt;!----------- Library modules -----------&gt;
&lt;div id=&quot;libraryModules&quot; style=&quot;display:none;&quot;&gt;
{{$:/core/lib/jquery.min.js||$:/core/templates/javascript-tiddler}}
{{{ [is[shadow]type[application/javascript]library[yes]] -[[$:/core/lib/jquery.min.js]] ||$:/core/templates/javascript-tiddler}}}
&lt;/div&gt;
&lt;!----------- Boot kernel prologue -----------&gt;
&lt;div id=&quot;bootKernelPrefix&quot; style=&quot;display:none;&quot;&gt;
{{ $:/core/bootprefix.js ||$:/core/templates/javascript-tiddler}}
&lt;/div&gt;
&lt;!----------- Plugin modules -----------&gt;
&lt;div id=&quot;modules&quot; style=&quot;display:none;&quot;&gt;
{{{ [is[shadow]type[application/javascript]has[module-type]] ||$:/core/templates/module-tiddler}}}
&lt;/div&gt;
&lt;!----------- Boot kernel -----------&gt;
&lt;div id=&quot;bootKernel&quot; style=&quot;display:none;&quot;&gt;
{{ $:/core/boot.js ||$:/core/templates/javascript-tiddler}}
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<div title="$:/core/templates/version">
<pre>&lt;$version/&gt;</pre>
</div>
<div title="$:/templates/ViewTemplate" modifier="JeremyRuston">
<pre>&lt;span class=&quot;tw-tiddler-controls&quot;&gt;
&lt;$button message=&quot;tw-delete-tiddler&quot; class=&quot;btn btn-mini btn-success&quot;&gt;delete&lt;/$button&gt;
&lt;$button message=&quot;tw-edit-tiddler&quot; class=&quot;btn-invisible&quot;&gt;{{$:/core/images/edit-button.svg}}&lt;/$button&gt;
&lt;$button message=&quot;tw-close-tiddler&quot; class=&quot;btn-invisible&quot;&gt;{{$:/core/images/close-button.svg}}&lt;/$button&gt;
&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;
&lt;$view field=&quot;title&quot;/&gt;
&lt;/span&gt;

&lt;div class=&quot;small&quot;&gt;&lt;$view field=&quot;modifier&quot; format=&quot;link&quot;/&gt; &lt;$view field=&quot;modified&quot; format=&quot;date&quot;/&gt;&lt;/div&gt;

&lt;div class=&quot;tw-tags-wrapper&quot;&gt;&lt;$list filter=&quot;[is[current]tags[]]&quot; template=&quot;$:/templates/TagTemplate&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;body&quot;&gt;
	&lt;$view field=&quot;text&quot; format=&quot;wikified&quot;&gt;
	&lt;/$view&gt;
&lt;/div&gt;
</pre>
</div>
<div title="$:/snippets/encryptionstatus">
<pre>&lt;$reveal type=&quot;match&quot; state=&quot;$:/isEncrypted&quot; text=&quot;yes&quot;&gt;
This wiki is encrypted.
&lt;$button message=&quot;tw-clear-password&quot; class=&quot;btn btn-mini btn-danger&quot;&gt;Clear password&lt;/$button&gt;
&lt;$button message=&quot;tw-set-password&quot; class=&quot;btn btn-mini btn-warning&quot;&gt;Change password&lt;/$button&gt;
&lt;/$reveal&gt;
&lt;$reveal type=&quot;nomatch&quot; state=&quot;$:/isEncrypted&quot; text=&quot;yes&quot;&gt;
This wiki is not encrypted.
&lt;$button message=&quot;tw-set-password&quot; class=&quot;btn btn-mini btn-warning&quot;&gt;Set password&lt;/$button&gt;
&lt;/$reveal&gt;</pre>
</div>
<div title="$:/temp/search">
<pre></pre>
</div>
<div title="$:/core/wiki/title" type="text/vnd.tiddlywiki">
<pre>{{SiteTitle}} --- {{SiteSubtitle}}</pre>
</div>
<div title="$:/plugins/tiddlywiki/fullscreen" type="application/json" bundle="yes">
<pre>{
    &quot;title&quot;: &quot;$:/plugins/tiddlywiki/fullscreen&quot;,
    &quot;description&quot;: &quot;Adds support for HTML5 full screen mode&quot;,
    &quot;author&quot;: &quot;JeremyRuston&quot;,
    &quot;version&quot;: &quot;0.0.0&quot;,
    &quot;coreVersion&quot;: &quot;&gt;=5.0.0&quot;,
    &quot;tiddlers&quot;: {
        &quot;init.js&quot;: {
            &quot;text&quot;: &quot;/*\\\ntitle: $:/plugins/tiddlywiki/fullscreen/init.js\ntype: application/javascript\nmodule-type: browser-startup\n\nMessage handler for full screen mode\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false, Element: false */\n\&quot;use strict\&quot;;\n\nvar toggleFullScreen = function() {\n\tif(document[$tw.browser.isFullScreen]) {\n\t\tdocument[$tw.browser.cancelFullScreen]();\n\t} else {\n\t\tdocument.documentElement[$tw.browser.requestFullScreen](Element.ALLOW_KEYBOARD_INPUT);\n\t}\n};\n\nexports.startup = function() {\n\t// Install the full screen handler\n\tdocument.addEventListener(\&quot;tw-full-screen\&quot;,function(event) {\n\t\ttoggleFullScreen();\n\t},false);\n};\n\n})();\n&quot;,
            &quot;title&quot;: &quot;$:/plugins/tiddlywiki/fullscreen/init.js&quot;,
            &quot;type&quot;: &quot;application/javascript&quot;,
            &quot;module-type&quot;: &quot;browser-startup&quot;
        }
    }
}</pre>
</div>
<div title="$:/isEncrypted">
<pre>no</pre>
</div>
<div title="$:/StoryList">
<pre></pre>
</div>

</div>
<!----------- Ordinary tiddlers ----------->
<div id="storeArea" style="display:none;">
<div title="SearchPreviewTemplate">
<pre>&lt;div class=&quot;title&quot;&gt;
&lt;&lt;view title text&gt;&gt;
&lt;/div&gt;
&lt;&lt;view text wikified&gt;&gt;
</pre>
</div>

</div>


<!----------- Library modules ----------->
<div id="libraryModules" style="display:none;">
<script type="text/javascript"></script>
<script data-tiddler-title="$:/library/sjcl.js" data-tiddler-type="application/javascript" data-tiddler-library="yes" type="text/javascript">"use strict";var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
if(typeof module!="undefined"&&module.exports)module.exports=sjcl;
sjcl.cipher.aes=function(a){this.h[0][0][0]||this.z();var b,c,d,e,f=this.h[0][4],g=this.h[1];b=a.length;var h=1;if(b!==4&&b!==6&&b!==8)throw new sjcl.exception.invalid("invalid aes key size");this.a=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(a%b===0||b===8&&a%b===4){c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255];if(a%b===0){c=c<<8^c>>>24^h<<24;h=h<<1^(h>>7)*283}}d[a]=d[a-b]^c}for(b=0;a;b++,a--){c=d[b&3?a:a-4];e[b]=a<=4||b<4?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^
g[3][f[c&255]]}};
sjcl.cipher.aes.prototype={encrypt:function(a){return this.I(a,0)},decrypt:function(a){return this.I(a,1)},h:[[[],[],[],[],[]],[[],[],[],[],[]]],z:function(){var a=this.h[0],b=this.h[1],c=a[4],d=b[4],e,f,g,h=[],i=[],k,j,l,m;for(e=0;e<0x100;e++)i[(h[e]=e<<1^(e>>7)*283)^e]=e;for(f=g=0;!c[f];f^=k||1,g=i[g]||1){l=g^g<<1^g<<2^g<<3^g<<4;l=l>>8^l&255^99;c[f]=l;d[l]=f;j=h[e=h[k=h[f]]];m=j*0x1010101^e*0x10001^k*0x101^f*0x1010100;j=h[l]*0x101^l*0x1010100;for(e=0;e<4;e++){a[e][f]=j=j<<24^j>>>8;b[e][l]=m=m<<24^m>>>8}}for(e=
0;e<5;e++){a[e]=a[e].slice(0);b[e]=b[e].slice(0)}},I:function(a,b){if(a.length!==4)throw new sjcl.exception.invalid("invalid aes block size");var c=this.a[b],d=a[0]^c[0],e=a[b?3:1]^c[1],f=a[2]^c[2];a=a[b?1:3]^c[3];var g,h,i,k=c.length/4-2,j,l=4,m=[0,0,0,0];g=this.h[b];var n=g[0],o=g[1],p=g[2],q=g[3],r=g[4];for(j=0;j<k;j++){g=n[d>>>24]^o[e>>16&255]^p[f>>8&255]^q[a&255]^c[l];h=n[e>>>24]^o[f>>16&255]^p[a>>8&255]^q[d&255]^c[l+1];i=n[f>>>24]^o[a>>16&255]^p[d>>8&255]^q[e&255]^c[l+2];a=n[a>>>24]^o[d>>16&
255]^p[e>>8&255]^q[f&255]^c[l+3];l+=4;d=g;e=h;f=i}for(j=0;j<4;j++){m[b?3&-j:j]=r[d>>>24]<<24^r[e>>16&255]<<16^r[f>>8&255]<<8^r[a&255]^c[l++];g=d;d=e;e=f;f=a;a=g}return m}};
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.P(a.slice(b/32),32-(b&31)).slice(1);return c===undefined?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(a.length===0||b.length===0)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return d===32?a.concat(b):sjcl.bitArray.P(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;
if(b===0)return 0;return(b-1)*32+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(a.length*32<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;if(c>0&&b)a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1);return a},partial:function(a,b,c){if(a===32)return b;return(c?b|0:b<<32-a)+a*0x10000000000},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return false;var c=0,d;for(d=0;d<a.length;d++)c|=
a[d]^b[d];return c===0},P:function(a,b,c,d){var e;e=0;if(d===undefined)d=[];for(;b>=32;b-=32){d.push(c);c=0}if(b===0)return d.concat(a);for(e=0;e<a.length;e++){d.push(c|a[e]>>>b);c=a[e]<<32-b}e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,b+a>32?c:d.pop(),1));return d},k:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};
sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++){if((d&3)===0)e=a[d/4];b+=String.fromCharCode(e>>>24);e<<=8}return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++){d=d<<8|a.charCodeAt(c);if((c&3)===3){b.push(d);d=0}}c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a+="00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,d*4)}};
sjcl.codec.base64={F:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.F,g=0,h=sjcl.bitArray.bitLength(a);if(c)f=f.substr(0,62)+"-_";for(c=0;d.length*6<h;){d+=f.charAt((g^a[c]>>>e)>>>26);if(e<6){g=a[c]<<6-e;e+=26;c++}else{g<<=6;e-=6}}for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d=0,e=sjcl.codec.base64.F,f=0,g;if(b)e=e.substr(0,62)+"-_";for(b=0;b<a.length;b++){g=e.indexOf(a.charAt(b));
if(g<0)throw new sjcl.exception.invalid("this isn't base64!");if(d>26){d-=26;c.push(f^g>>>d);f=g<<32-d}else{d+=6;f^=g<<32-d}}d&56&&c.push(sjcl.bitArray.partial(d&56,f,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.a[0]||this.z();if(a){this.n=a.n.slice(0);this.i=a.i.slice(0);this.e=a.e}else this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.n=this.N.slice(0);this.i=[];this.e=0;return this},update:function(a){if(typeof a==="string")a=sjcl.codec.utf8String.toBits(a);var b,c=this.i=sjcl.bitArray.concat(this.i,a);b=this.e;a=this.e=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)this.D(c.splice(0,16));return this},finalize:function(){var a,b=this.i,c=this.n;b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.e/
4294967296));for(b.push(this.e|0);b.length;)this.D(b.splice(0,16));this.reset();return c},N:[],a:[],z:function(){function a(e){return(e-Math.floor(e))*0x100000000|0}var b=0,c=2,d;a:for(;b<64;c++){for(d=2;d*d<=c;d++)if(c%d===0)continue a;if(b<8)this.N[b]=a(Math.pow(c,0.5));this.a[b]=a(Math.pow(c,1/3));b++}},D:function(a){var b,c,d=a.slice(0),e=this.n,f=this.a,g=e[0],h=e[1],i=e[2],k=e[3],j=e[4],l=e[5],m=e[6],n=e[7];for(a=0;a<64;a++){if(a<16)b=d[a];else{b=d[a+1&15];c=d[a+14&15];b=d[a&15]=(b>>>7^b>>>18^
b>>>3^b<<25^b<<14)+(c>>>17^c>>>19^c>>>10^c<<15^c<<13)+d[a&15]+d[a+9&15]|0}b=b+n+(j>>>6^j>>>11^j>>>25^j<<26^j<<21^j<<7)+(m^j&(l^m))+f[a];n=m;m=l;l=j;j=k+b|0;k=i;i=h;h=g;g=b+(h&i^k&(h^i))+(h>>>2^h>>>13^h>>>22^h<<30^h<<19^h<<10)|0}e[0]=e[0]+g|0;e[1]=e[1]+h|0;e[2]=e[2]+i|0;e[3]=e[3]+k|0;e[4]=e[4]+j|0;e[5]=e[5]+l|0;e[6]=e[6]+m|0;e[7]=e[7]+n|0}};
sjcl.mode.ccm={name:"ccm",encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,i=h.bitLength(c)/8,k=h.bitLength(g)/8;e=e||64;d=d||[];if(i<7)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(f=2;f<4&&k>>>8*f;f++);if(f<15-i)f=15-i;c=h.clamp(c,8*(15-f));b=sjcl.mode.ccm.H(a,b,c,d,e,f);g=sjcl.mode.ccm.J(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),i=f.clamp(b,h-e),k=f.bitSlice(b,
h-e);h=(h-e)/8;if(g<7)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(b=2;b<4&&h>>>8*b;b++);if(b<15-g)b=15-g;c=f.clamp(c,8*(15-b));i=sjcl.mode.ccm.J(a,i,c,k,e,b);a=sjcl.mode.ccm.H(a,i.data,c,d,e,b);if(!f.equal(i.tag,a))throw new sjcl.exception.corrupt("ccm: tag doesn't match");return i.data},H:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,i=h.k;e/=8;if(e%2||e<4||e>16)throw new sjcl.exception.invalid("ccm: invalid tag length");if(d.length>0xffffffff||b.length>0xffffffff)throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
f=[h.partial(8,(d.length?64:0)|e-2<<2|f-1)];f=h.concat(f,c);f[3]|=h.bitLength(b)/8;f=a.encrypt(f);if(d.length){c=h.bitLength(d)/8;if(c<=65279)g=[h.partial(16,c)];else if(c<=0xffffffff)g=h.concat([h.partial(16,65534)],[c]);g=h.concat(g,d);for(d=0;d<g.length;d+=4)f=a.encrypt(i(f,g.slice(d,d+4).concat([0,0,0])))}for(d=0;d<b.length;d+=4)f=a.encrypt(i(f,b.slice(d,d+4).concat([0,0,0])));return h.clamp(f,e*8)},J:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.k;var i=b.length,k=h.bitLength(b);c=h.concat([h.partial(8,
f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!i)return{tag:d,data:[]};for(g=0;g<i;g+=4){c[3]++;e=a.encrypt(c);b[g]^=e[0];b[g+1]^=e[1];b[g+2]^=e[2];b[g+3]^=e[3]}return{tag:d,data:h.clamp(b,k)}}};
sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){if(sjcl.bitArray.bitLength(c)!==128)throw new sjcl.exception.invalid("ocb iv must be 128 bits");var g,h=sjcl.mode.ocb2.B,i=sjcl.bitArray,k=i.k,j=[0,0,0,0];c=h(a.encrypt(c));var l,m=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4){l=b.slice(g,g+4);j=k(j,l);m=m.concat(k(c,a.encrypt(k(c,l))));c=h(c)}l=b.slice(g);b=i.bitLength(l);g=a.encrypt(k(c,[0,0,0,b]));l=i.clamp(k(l.concat([0,0,0]),g),b);j=k(j,k(l.concat([0,0,0]),g));j=a.encrypt(k(j,k(c,h(c))));
if(d.length)j=k(j,f?d:sjcl.mode.ocb2.pmac(a,d));return m.concat(i.concat(l,i.clamp(j,e)))},decrypt:function(a,b,c,d,e,f){if(sjcl.bitArray.bitLength(c)!==128)throw new sjcl.exception.invalid("ocb iv must be 128 bits");e=e||64;var g=sjcl.mode.ocb2.B,h=sjcl.bitArray,i=h.k,k=[0,0,0,0],j=g(a.encrypt(c)),l,m,n=sjcl.bitArray.bitLength(b)-e,o=[];d=d||[];for(c=0;c+4<n/32;c+=4){l=i(j,a.decrypt(i(j,b.slice(c,c+4))));k=i(k,l);o=o.concat(l);j=g(j)}m=n-c*32;l=a.encrypt(i(j,[0,0,0,m]));l=i(l,h.clamp(b.slice(c),
m).concat([0,0,0]));k=i(k,l);k=a.encrypt(i(k,i(j,g(j))));if(d.length)k=i(k,f?d:sjcl.mode.ocb2.pmac(a,d));if(!h.equal(h.clamp(k,e),h.bitSlice(b,n)))throw new sjcl.exception.corrupt("ocb: tag doesn't match");return o.concat(h.clamp(l,m))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.B,e=sjcl.bitArray,f=e.k,g=[0,0,0,0],h=a.encrypt([0,0,0,0]);h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4){h=d(h);g=f(g,a.encrypt(f(h,b.slice(c,c+4))))}b=b.slice(c);if(e.bitLength(b)<128){h=f(h,d(h));b=e.concat(b,[2147483648|0,0,
0,0])}g=f(g,b);return a.encrypt(f(d(f(h,d(h))),g))},B:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^(a[0]>>>31)*135]}};sjcl.misc.hmac=function(a,b){this.M=b=b||sjcl.hash.sha256;var c=[[],[]],d=b.prototype.blockSize/32;this.l=[new b,new b];if(a.length>d)a=b.hash(a);for(b=0;b<d;b++){c[0][b]=a[b]^909522486;c[1][b]=a[b]^1549556828}this.l[0].update(c[0]);this.l[1].update(c[1])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a,b){a=(new this.M(this.l[0])).update(a,b).finalize();return(new this.M(this.l[1])).update(a).finalize()};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;if(d<0||c<0)throw sjcl.exception.invalid("invalid params to pbkdf2");if(typeof a==="string")a=sjcl.codec.utf8String.toBits(a);e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,i,k=[],j=sjcl.bitArray;for(i=1;32*k.length<(d||1);i++){e=f=a.encrypt(j.concat(b,[i]));for(g=1;g<c;g++){f=a.encrypt(f);for(h=0;h<f.length;h++)e[h]^=f[h]}k=k.concat(e)}if(d)k=j.clamp(k,d);return k};
sjcl.random={randomWords:function(a,b){var c=[];b=this.isReady(b);var d;if(b===0)throw new sjcl.exception.notReady("generator isn't seeded");else b&2&&this.U(!(b&1));for(b=0;b<a;b+=4){(b+1)%0x10000===0&&this.L();d=this.w();c.push(d[0],d[1],d[2],d[3])}this.L();return c.slice(0,a)},setDefaultParanoia:function(a){this.t=a},addEntropy:function(a,b,c){c=c||"user";var d,e,f=(new Date).valueOf(),g=this.q[c],h=this.isReady(),i=0;d=this.G[c];if(d===undefined)d=this.G[c]=this.R++;if(g===undefined)g=this.q[c]=
0;this.q[c]=(this.q[c]+1)%this.b.length;switch(typeof a){case "number":if(b===undefined)b=1;this.b[g].update([d,this.u++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if(c==="[object Uint32Array]"){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else{if(c!=="[object Array]")i=1;for(c=0;c<a.length&&!i;c++)if(typeof a[c]!="number")i=1}if(!i){if(b===undefined)for(c=b=0;c<a.length;c++)for(e=a[c];e>0;){b++;e>>>=1}this.b[g].update([d,this.u++,2,b,f,a.length].concat(a))}break;case "string":if(b===
undefined)b=a.length;this.b[g].update([d,this.u++,3,b,f,a.length]);this.b[g].update(a);break;default:i=1}if(i)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.j[g]+=b;this.f+=b;if(h===0){this.isReady()!==0&&this.K("seeded",Math.max(this.g,this.f));this.K("progress",this.getProgress())}},isReady:function(a){a=this.C[a!==undefined?a:this.t];return this.g&&this.g>=a?this.j[0]>80&&(new Date).valueOf()>this.O?3:1:this.f>=a?2:0},getProgress:function(a){a=
this.C[a?a:this.t];return this.g>=a?1:this.f>a?1:this.f/a},startCollectors:function(){if(!this.m){if(window.addEventListener){window.addEventListener("load",this.o,false);window.addEventListener("mousemove",this.p,false)}else if(document.attachEvent){document.attachEvent("onload",this.o);document.attachEvent("onmousemove",this.p)}else throw new sjcl.exception.bug("can't attach event");this.m=true}},stopCollectors:function(){if(this.m){if(window.removeEventListener){window.removeEventListener("load",
this.o,false);window.removeEventListener("mousemove",this.p,false)}else if(window.detachEvent){window.detachEvent("onload",this.o);window.detachEvent("onmousemove",this.p)}this.m=false}},addEventListener:function(a,b){this.r[a][this.Q++]=b},removeEventListener:function(a,b){var c;a=this.r[a];var d=[];for(c in a)a.hasOwnProperty(c)&&a[c]===b&&d.push(c);for(b=0;b<d.length;b++){c=d[b];delete a[c]}},b:[new sjcl.hash.sha256],j:[0],A:0,q:{},u:0,G:{},R:0,g:0,f:0,O:0,a:[0,0,0,0,0,0,0,0],d:[0,0,0,0],s:undefined,
t:6,m:false,r:{progress:{},seeded:{}},Q:0,C:[0,48,64,96,128,192,0x100,384,512,768,1024],w:function(){for(var a=0;a<4;a++){this.d[a]=this.d[a]+1|0;if(this.d[a])break}return this.s.encrypt(this.d)},L:function(){this.a=this.w().concat(this.w());this.s=new sjcl.cipher.aes(this.a)},T:function(a){this.a=sjcl.hash.sha256.hash(this.a.concat(a));this.s=new sjcl.cipher.aes(this.a);for(a=0;a<4;a++){this.d[a]=this.d[a]+1|0;if(this.d[a])break}},U:function(a){var b=[],c=0,d;this.O=b[0]=(new Date).valueOf()+3E4;for(d=
0;d<16;d++)b.push(Math.random()*0x100000000|0);for(d=0;d<this.b.length;d++){b=b.concat(this.b[d].finalize());c+=this.j[d];this.j[d]=0;if(!a&&this.A&1<<d)break}if(this.A>=1<<this.b.length){this.b.push(new sjcl.hash.sha256);this.j.push(0)}this.f-=c;if(c>this.g)this.g=c;this.A++;this.T(b)},p:function(a){sjcl.random.addEntropy([a.x||a.clientX||a.offsetX||0,a.y||a.clientY||a.offsetY||0],2,"mouse")},o:function(){sjcl.random.addEntropy((new Date).valueOf(),2,"loadtime")},K:function(a,b){var c;a=sjcl.random.r[a];
var d=[];for(c in a)a.hasOwnProperty(c)&&d.push(a[c]);for(c=0;c<d.length;c++)d[c](b)}};try{var s=new Uint32Array(32);crypto.getRandomValues(s);sjcl.random.addEntropy(s,1024,"crypto['getRandomValues']")}catch(t){}
sjcl.json={defaults:{v:1,iter:1E3,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},encrypt:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.c({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.c(f,c);c=f.adata;if(typeof f.salt==="string")f.salt=sjcl.codec.base64.toBits(f.salt);if(typeof f.iv==="string")f.iv=sjcl.codec.base64.toBits(f.iv);if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||typeof a==="string"&&f.iter<=100||f.ts!==64&&f.ts!==96&&f.ts!==128||f.ks!==128&&f.ks!==192&&f.ks!==0x100||f.iv.length<
2||f.iv.length>4)throw new sjcl.exception.invalid("json encrypt: invalid parameters");if(typeof a==="string"){g=sjcl.misc.cachedPbkdf2(a,f);a=g.key.slice(0,f.ks/32);f.salt=g.salt}if(typeof b==="string")b=sjcl.codec.utf8String.toBits(b);if(typeof c==="string")c=sjcl.codec.utf8String.toBits(c);g=new sjcl.cipher[f.cipher](a);e.c(d,f);d.key=a;f.ct=sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return e.encode(f)},decrypt:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.c(e.c(e.c({},e.defaults),e.decode(b)),
c,true);var f;c=b.adata;if(typeof b.salt==="string")b.salt=sjcl.codec.base64.toBits(b.salt);if(typeof b.iv==="string")b.iv=sjcl.codec.base64.toBits(b.iv);if(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||typeof a==="string"&&b.iter<=100||b.ts!==64&&b.ts!==96&&b.ts!==128||b.ks!==128&&b.ks!==192&&b.ks!==0x100||!b.iv||b.iv.length<2||b.iv.length>4)throw new sjcl.exception.invalid("json decrypt: invalid parameters");if(typeof a==="string"){f=sjcl.misc.cachedPbkdf2(a,b);a=f.key.slice(0,b.ks/32);b.salt=f.salt}if(typeof c===
"string")c=sjcl.codec.utf8String.toBits(c);f=new sjcl.cipher[b.cipher](a);c=sjcl.mode[b.mode].decrypt(f,b.ct,b.iv,c,b.ts);e.c(d,b);d.key=a;return sjcl.codec.utf8String.fromBits(c)},encode:function(a){var b,c="{",d="";for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid("json encode: invalid property name");c+=d+'"'+b+'":';d=",";switch(typeof a[b]){case "number":case "boolean":c+=a[b];break;case "string":c+='"'+escape(a[b])+'"';break;case "object":c+='"'+
sjcl.codec.base64.fromBits(a[b],1)+'"';break;default:throw new sjcl.exception.bug("json encode: unsupported type");}}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid("json decode: this isn't json!");a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++){if(!(d=a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i)))throw new sjcl.exception.invalid("json decode: this isn't json!");b[d[2]]=
d[3]?parseInt(d[3],10):d[2].match(/^(ct|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4])}return b},c:function(a,b,c){if(a===undefined)a={};if(b===undefined)return a;var d;for(d in b)if(b.hasOwnProperty(d)){if(c&&a[d]!==undefined&&a[d]!==b[d])throw new sjcl.exception.invalid("required parameter overridden");a[d]=b[d]}return a},W:function(a,b){var c={},d;for(d in a)if(a.hasOwnProperty(d)&&a[d]!==b[d])c[d]=a[d];return c},V:function(a,b){var c={},d;for(d=0;d<b.length;d++)if(a[b[d]]!==undefined)c[b[d]]=
a[b[d]];return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.S={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.S,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=b.salt===undefined?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};</script>
</div>
<!----------- Boot kernel prologue ----------->
<div id="bootKernelPrefix" style="display:none;">
<script data-tiddler-title="$:/core/bootprefix.js" data-tiddler-type="application/javascript" type="text/javascript">/*\
title: $:/core/bootprefix.js
type: application/javascript

This file sets up the globals that need to be available when JavaScript modules are executed in the browser. The overall sequence is:

# BootPrefix.js
# <module definitions>
# Boot.js

See Boot.js for further details of the boot process.

\*/

// Set up $tw global for the browser
if(typeof(window) === "undefined") {
	global.$tw = global.$tw || {}; // No `browser` member for the server
} else {
	window.$tw = window.$tw || {browser: {}};
}

/*
Information about each module is kept in an object with these members:
	moduleType: type of module
	definition: object, function or string defining the module; see below
	exports: exports of the module, filled in after execution

The `definition` can be of several types:

* An object can be used to directly specify the exports of the module
* A function with the arguments `module,require,exports` that returns `exports`
* A string function body with the same arguments

Each moduleInfo object is stored in two hashmaps: $tw.modules.titles and $tw.modules.types. The first is indexed by title and the second is indexed by type and then title
*/
$tw.modules = {
	titles: {}, // hashmap by module name of moduleInfo
	types: {} // hashmap by module type and then name of moduleInfo
};

/*
Define a JavaScript tiddler module for later execution
	moduleName: name of module being defined
	moduleType: type of module
	definition: module definition; see discussion above
*/
$tw.modules.define = function(moduleName,moduleType,definition) {
	// Create the moduleInfo
	var moduleInfo = {
		moduleType: moduleType,
		definition: definition,
		exports: undefined
	};
	// If the definition is already an object we can use it as the exports
	if(typeof moduleInfo.definition === "object") {
		moduleInfo.exports = definition;
	}
	// Store the module in the titles hashmap
	if(Object.prototype.hasOwnProperty.call($tw.modules.titles,moduleName)) {
		console.log("Warning: Redefined module - " + moduleName);
	}
	$tw.modules.titles[moduleName] = moduleInfo;
	// Store the module in the types hashmap
	if(!Object.prototype.hasOwnProperty.call($tw.modules.types,moduleType)) {
		$tw.modules.types[moduleType] = {};
	}
	if(Object.prototype.hasOwnProperty.call($tw.modules.types[moduleType],moduleName)) {
		console.log("Warning: Redefined module - " + moduleName);
	}
	$tw.modules.types[moduleType][moduleName] = moduleInfo;
};

/*
Define a tiddler
*/
$tw.preloadTiddlers = $tw.preloadTiddlers || [];

$tw.preloadTiddler = function(fields) {
	$tw.preloadTiddlers.push(fields);
};

</script>
</div>
<!----------- Plugin modules ----------->
<div id="modules" style="display:none;">
<script data-tiddler-title="$:/core/modules/commander.js" data-tiddler-type="application/javascript" data-tiddler-module-type="global" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commander.js","global",function(module,exports,require) {/*\
title: $:/core/modules/commander.js
type: application/javascript
module-type: global

The $tw.Commander class is a command interpreter

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Parse a sequence of commands
	commandTokens: an array of command string tokens
	wiki: reference to the wiki store object
	streams: {output:, error:}, each of which has a write(string) method
	callback: a callback invoked as callback(err) where err is null if there was no error
*/
var Commander = function(commandTokens,callback,wiki,streams) {
	this.commandTokens = commandTokens;
	this.nextToken = 0;
	this.callback = callback;
	this.wiki = wiki;
	this.streams = streams;
};

/*
Execute the sequence of commands and invoke a callback on completion
*/
Commander.prototype.execute = function() {
	this.executeNextCommand();
};

/*
Execute the next command in the sequence
*/
Commander.prototype.executeNextCommand = function() {
	var self = this;
	// Invoke the callback if there are no more commands
	if(this.nextToken >= this.commandTokens.length) {
		this.callback(null);
	} else {
		// Get and check the command token
		var commandName = this.commandTokens[this.nextToken++];
		if(commandName.substr(0,2) !== "--") {
			this.callback("Missing command");
		} else {
			commandName = commandName.substr(2); // Trim off the --
			// Accumulate the parameters to the command
			var params = [];
			while(this.nextToken < this.commandTokens.length && 
				this.commandTokens[this.nextToken].substr(0,2) !== "--") {
				params.push(this.commandTokens[this.nextToken++]);
			}
			// Get the command info
			var command = $tw.commands[commandName],
				c,err;
			if(!command) {
				this.callback("Unknown command: " + commandName);
			} else {
				if(this.verbose) {
					this.streams.output.write("Executing command: " + commandName + " " + params.join(" ") + "\n");
				}
				if(command.info.synchronous) {
					// Synchronous command
					c = new command.Command(params,this);
					err = c.execute();
					if(err) {
						this.callback(err);
					} else {
						this.executeNextCommand();
					}
				} else {
					// Asynchronous command
					c = new command.Command(params,this,function(err) {
						if(err) {
							self.callback(err);
						} else {
							self.executeNextCommand();
						}
					});
					err = c.execute();
					if(err) {
						this.callback(err);
					}
				}
			}
		}
	}
};

Commander.initCommands = function(moduleType) {
	moduleType = moduleType || "command";
	$tw.commands = {};
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		var c = $tw.commands[module.info.name] = {};
		// Add the methods defined by the module
		for(var f in module) {
			if($tw.utils.hop(module,f)) {
				c[f] = module[f];
			}
		}
	});
};

exports.Commander = Commander;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/dump.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/dump.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/dump.js
type: application/javascript
module-type: command

Dump command for inspecting TiddlyWiki internals

\*/
(function(){

/*jshint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "dump",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
	this.output = commander.streams.output;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Too few parameters for dump command";
	}
	var subcommand = this.subcommands[this.params[0]];
	if(subcommand) {
		return subcommand.call(this);
	} else {
		return "Unknown subcommand (" + this.params[0] + ") for dump command";
	}
};

Command.prototype.subcommands = {};

Command.prototype.subcommands.tiddler = function() {
	if(this.params.length < 2) {
		return "Too few parameters for dump tiddler command";
	}
	var tiddler = this.commander.wiki.getTiddler(this.params[1]);
	if(!tiddler) {
		return "No such tiddler as '" + this.params[1] + "'";
	}
	this.output.write("Tiddler '" + this.params[1] + "' contains these fields:\n");
	for(var t in tiddler.fields) {
		this.output.write("  " + t + ": " + tiddler.getFieldString(t) + "\n");
	}
	return null; // No error
};

Command.prototype.subcommands.tiddlers = function() {
	var tiddlers = this.commander.wiki.getTiddlers();
	this.output.write("Wiki contains these tiddlers:\n");
	for(var t=0; t<tiddlers.length; t++) {
		this.output.write(tiddlers[t] + "\n");
	}
	return null; // No error
};

Command.prototype.subcommands.shadows = function() {
	var tiddlers = this.commander.wiki.getShadowTitles();
	this.output.write("Wiki contains these shadow tiddlers:\n");
	for(var t=0; t<tiddlers.length; t++) {
		this.output.write(tiddlers[t] + "\n");
	}
	return null; // No error
};

Command.prototype.subcommands.config = function() {
	var self = this;
	var quotePropertyName = function(p) {
			var unquotedPattern = /^[A-Za-z0-9_]*$/mg;
			if(unquotedPattern.test(p)) {
				return p;
			} else {
				return "[\"" + $tw.utils.stringify(p) + "\"]";
			}
		},
		dumpConfig = function(object,prefix) {
			for(var n in object) {
				var v = object[n];
				if(typeof v === "object") {
					dumpConfig(v,prefix + "." + quotePropertyName(n));
				} else if(typeof v === "string") {
					self.output.write(prefix + "." + quotePropertyName(n) + ": \"" + $tw.utils.stringify(v) + "\"\n");
				} else {
					self.output.write(prefix + "." + quotePropertyName(n) + ": " + v.toString() + "\n");
				}
			}
		},
		dumpObject = function(heading,object) {
			self.output.write(heading +"\n");
			for(var n in object) {
				self.output.write("  " + n + "\n");
			}
		};
	this.output.write("Configuration:\n");
	dumpConfig($tw.config,"  $tw.config");
	dumpObject("Tiddler field modules:",$tw.Tiddler.fieldModules);
	dumpObject("Loaded modules:",$tw.modules.titles);
	dumpObject("Command modules:",$tw.commands);
	dumpObject("Parser modules:",$tw.wiki.parsers);
	dumpObject("Macro modules:",$tw.wiki.macros);
	dumpObject("Deserializer modules:",$tw.Wiki.tiddlerDeserializerModules);
	return null; // No error
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/load.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/load.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/load.js
type: application/javascript
module-type: command

Command to load tiddlers from a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "load",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var self = this,
		fs = require("fs"),
		path = require("path");
	if(this.params.length < 1) {
		return "Missing filename";
	}
	fs.readFile(this.params[0],"utf8",function(err,data) {
		if(err) {
			self.callback(err);
		} else {
			var fields = {title: self.params[0]},
				extname = path.extname(self.params[0]),
				type = extname === ".html" ? "application/vnd.tiddlywiki2" : extname;
			var tiddlers = self.commander.wiki.deserializeTiddlers(type,data,fields);
			if(!tiddlers) {
				self.callback("No tiddlers found in file \"" + self.params[0] + "\"");
			} else {
				for(var t=0; t<tiddlers.length; t++) {
					self.commander.wiki.addTiddler(new $tw.Tiddler(tiddlers[t]));
				}
				self.callback(null);	
			}
		}
	});
	return null;
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/password.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/password.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/password.js
type: application/javascript
module-type: command

Save password for crypto operations

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "password",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 1) {
		return "Missing password";
	}
	$tw.crypto.setPassword(this.params[0]);
	return null;
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/savetiddler.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/savetiddler.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/savetiddler.js
type: application/javascript
module-type: command

Command to save a tiddler to a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "savetiddler",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		title = this.params[0],
		filename = this.params[1],
		type = this.params[2] || "text/html";
	fs.writeFile(filename,this.commander.wiki.renderTiddler(type,title),"utf8",function(err) {
		self.callback(err);
	});
	return null;
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/savetiddlers.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/savetiddlers.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/savetiddlers.js
type: application/javascript
module-type: command

Command to save several tiddlers to a file

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "savetiddlers",
	synchronous: false
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	if(this.params.length < 2) {
		return "Missing filename";
	}
	var self = this,
		fs = require("fs"),
		path = require("path"),
		wiki = this.commander.wiki,
		filter = this.params[0],
		template = this.params[1],
		pathname = this.params[2],
		type = this.params[3] || "text/html",
		extension = this.params[4] || ".html",
		parser = wiki.parseTiddler(template),
		tiddlers = wiki.filterTiddlers(filter);
	$tw.utils.each(tiddlers,function(title) {
		var renderTree = new $tw.WikiRenderTree(parser,{wiki: wiki});
		renderTree.execute({tiddlerTitle: title});
		var text = renderTree.render(type);
		fs.writeFileSync(path.resolve(pathname,title + extension),text,"utf8");
	});
	return null;
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/server.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/server.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/server.js
type: application/javascript
module-type: command

Serve tiddlers over http

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "server",
	synchronous: true
};

var Command = function(params,commander,callback) {
	this.params = params;
	this.commander = commander;
	this.callback = callback;
};

Command.prototype.execute = function() {
	var self = this,
		util = require("util"),
		fs = require("fs"),
		url = require("url"),
		path = require("path"),
		http = require("http"),
		port = this.params[0] || "8080",
		rootTiddler = this.params[1] || "$:/core/templates/tiddlywiki5.template.html",
		renderType = this.params[2] || "text/plain",
		serveType = this.params[3] || "text/html";
	http.createServer(function(request, response) {
		var requestPath = url.parse(request.url).pathname,
			text;
		switch(request.method) {
			case "PUT":
				var data = "";
				request.on("data",function(chunk) {
					data += chunk.toString();
				});
				request.on("end",function() {
					var prefix = "/tiddlers/";
					if(requestPath.indexOf(prefix) === 0) {
						var title = decodeURIComponent(requestPath.substr(prefix.length)),
							fields = JSON.parse(data);
						// Use the title from the PUT URL if we don't have one
						if(!fields.title) {
							fields.title = title;
						}
						// Pull up any subfields in the `fields` object
						if(fields.fields) {
							$tw.utils.each(fields.fields,function(field,name) {
								fields[name] = field;
							});
							delete fields.fields;
						}
						// Remove any server.revision field
						if(fields["server.revision"]) {
							delete fields["server.revision"];
						}
console.log("PUT tiddler",title,fields)
//						self.commander.wiki.addTiddler(new $tw.Tiddler(JSON.parse(data),{title: title}));
						response.writeHead(204, "OK");
						response.end();
					} else {
						response.writeHead(404);
						response.end();
					}
				});
				break;
			case "DELETE":
console.log("DELETE tiddler",requestPath.substr(1))
//				self.commander.wiki.deleteTiddler(decodeURIComponent(requestPath.substr(1)));
				response.writeHead(204, "OK");
				response.end();
				break;
			case "GET":
				if(requestPath === "/") {
					response.writeHead(200, {"Content-Type": serveType});
					text = self.commander.wiki.renderTiddler(renderType,rootTiddler);
					response.end(text,"utf8");
				} else if(requestPath === "/status") {
					response.writeHead(200, {"Content-Type": "application/json"});
					text = JSON.stringify({
						username: "ANONYMOUS",
						tiddlywiki_version: $tw.version,
						version: "1.4.7"
					});
					response.end(text,"utf8");
				} else if(requestPath === "/tiddlers.json") {
					response.writeHead(200, {"Content-Type": "application/json"});
					var tiddlers = [];
					$tw.wiki.forEachTiddler("title",function(title,tiddler) {
						var tiddlerFields = {};
						$tw.utils.each(tiddler.fields,function(field,name) {
							if(name !== "text") {
								tiddlerFields[name] = tiddler.getFieldString(name);
							}
						});
						tiddlerFields["server.revision"] = $tw.wiki.getChangeCount(title);
						tiddlerFields["created"] = "201203091234";
						tiddlers.push(tiddlerFields);
					});
					text = JSON.stringify(tiddlers);
					response.end(text,"utf8");
				} else {
					response.writeHead(404);
					response.end();
				}
				break;
			}
	}).listen(port);
	if(this.commander.verbose) {
		console.log("Serving on port " + port);
	}
	return null;
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/verbose.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/verbose.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/verbose.js
type: application/javascript
module-type: command

Verbose command

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "verbose",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	this.commander.verbose = true;
	return null; // No error
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/commands/version.js" data-tiddler-type="application/javascript" data-tiddler-module-type="command" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/commands/version.js","command",function(module,exports,require) {/*\
title: $:/core/modules/commands/version.js
type: application/javascript
module-type: command

Version command

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.info = {
	name: "version",
	synchronous: true
};

var Command = function(params,commander) {
	this.params = params;
	this.commander = commander;
};

Command.prototype.execute = function() {
	this.commander.streams.output.write($tw.version + "\n");
	return null; // No error
};

exports.Command = Command;

})();
});
</script><script data-tiddler-title="$:/core/modules/config.js" data-tiddler-type="application/javascript" data-tiddler-module-type="config" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/config.js","config",function(module,exports,require) {/*\
title: $:/core/modules/config.js
type: application/javascript
module-type: config

Core configuration constants

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.preferences = {};

exports.preferences.animationDuration = 400;
exports.preferences.animationDurationMs = exports.preferences.animationDuration + "ms";
exports.preferences.jsonSpaces = 4;

exports.dateFormats = {
	months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November","December"],
	days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
// suffixes for dates, eg "1st","2nd","3rd"..."30th","31st"
	daySuffixes: ["st","nd","rd","th","th","th","th","th","th","th",
		"th","th","th","th","th","th","th","th","th","th",
		"st","nd","rd","th","th","th","th","th","th","th",
		"st"],
	am: "am",
	pm: "pm"
};

exports.htmlEntities = {quot:34, amp:38, apos:39, lt:60, gt:62, nbsp:160, iexcl:161, cent:162, pound:163, curren:164, yen:165, brvbar:166, sect:167, uml:168, copy:169, ordf:170, laquo:171, not:172, shy:173, reg:174, macr:175, deg:176, plusmn:177, sup2:178, sup3:179, acute:180, micro:181, para:182, middot:183, cedil:184, sup1:185, ordm:186, raquo:187, frac14:188, frac12:189, frac34:190, iquest:191, Agrave:192, Aacute:193, Acirc:194, Atilde:195, Auml:196, Aring:197, AElig:198, Ccedil:199, Egrave:200, Eacute:201, Ecirc:202, Euml:203, Igrave:204, Iacute:205, Icirc:206, Iuml:207, ETH:208, Ntilde:209, Ograve:210, Oacute:211, Ocirc:212, Otilde:213, Ouml:214, times:215, Oslash:216, Ugrave:217, Uacute:218, Ucirc:219, Uuml:220, Yacute:221, THORN:222, szlig:223, agrave:224, aacute:225, acirc:226, atilde:227, auml:228, aring:229, aelig:230, ccedil:231, egrave:232, eacute:233, ecirc:234, euml:235, igrave:236, iacute:237, icirc:238, iuml:239, eth:240, ntilde:241, ograve:242, oacute:243, ocirc:244, otilde:245, ouml:246, divide:247, oslash:248, ugrave:249, uacute:250, ucirc:251, uuml:252, yacute:253, thorn:254, yuml:255, OElig:338, oelig:339, Scaron:352, scaron:353, Yuml:376, fnof:402, circ:710, tilde:732, Alpha:913, Beta:914, Gamma:915, Delta:916, Epsilon:917, Zeta:918, Eta:919, Theta:920, Iota:921, Kappa:922, Lambda:923, Mu:924, Nu:925, Xi:926, Omicron:927, Pi:928, Rho:929, Sigma:931, Tau:932, Upsilon:933, Phi:934, Chi:935, Psi:936, Omega:937, alpha:945, beta:946, gamma:947, delta:948, epsilon:949, zeta:950, eta:951, theta:952, iota:953, kappa:954, lambda:955, mu:956, nu:957, xi:958, omicron:959, pi:960, rho:961, sigmaf:962, sigma:963, tau:964, upsilon:965, phi:966, chi:967, psi:968, omega:969, thetasym:977, upsih:978, piv:982, ensp:8194, emsp:8195, thinsp:8201, zwnj:8204, zwj:8205, lrm:8206, rlm:8207, ndash:8211, mdash:8212, lsquo:8216, rsquo:8217, sbquo:8218, ldquo:8220, rdquo:8221, bdquo:8222, dagger:8224, Dagger:8225, bull:8226, hellip:8230, permil:8240, prime:8242, Prime:8243, lsaquo:8249, rsaquo:8250, oline:8254, frasl:8260, euro:8364, image:8465, weierp:8472, real:8476, trade:8482, alefsym:8501, larr:8592, uarr:8593, rarr:8594, darr:8595, harr:8596, crarr:8629, lArr:8656, uArr:8657, rArr:8658, dArr:8659, hArr:8660, forall:8704, part:8706, exist:8707, empty:8709, nabla:8711, isin:8712, notin:8713, ni:8715, prod:8719, sum:8721, minus:8722, lowast:8727, radic:8730, prop:8733, infin:8734, ang:8736, and:8743, or:8744, cap:8745, cup:8746, int:8747, there4:8756, sim:8764, cong:8773, asymp:8776, ne:8800, equiv:8801, le:8804, ge:8805, sub:8834, sup:8835, nsub:8836, sube:8838, supe:8839, oplus:8853, otimes:8855, perp:8869, sdot:8901, lceil:8968, rceil:8969, lfloor:8970, rfloor:8971, lang:9001, rang:9002, loz:9674, spades:9824, clubs:9827, hearts:9829, diams:9830 };

exports.htmlVoidElements = "area,base,br,col,command,embed,hr,img,input,keygen,link,meta,param,source,track,wbr".split(",");


})();
});
</script><script data-tiddler-title="$:/core/modules/deserializers.js" data-tiddler-type="application/javascript" data-tiddler-module-type="tiddlerdeserializer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/deserializers.js","tiddlerdeserializer",function(module,exports,require) {/*\
title: $:/core/modules/deserializers.js
type: application/javascript
module-type: tiddlerdeserializer

Functions to deserialise tiddlers from a block of text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Utility function to parse an old-style tiddler DIV. It looks like this:

<div title="Title" creator="JoeBloggs" modifier="JoeBloggs" created="201102111106" modified="201102111310" tags="myTag [[my long tag]]">
<pre>The text of the tiddler (without the expected HTML encoding).
</pre>
</div>

Note that the field attributes are HTML encoded, but that the body of the <PRE> tag is not.
*/
var parseTiddlerDiv = function(text,fields) {
	var result = {};
	if(fields) {
		for(var t in fields) {
			result[t] = fields[t];		
		}
	}
	var divRegExp = /^\s*<div\s+([^>]*)>((?:.|\n)*)<\/div>\s*$/gi,
		subDivRegExp = /^\s*<pre>((?:.|\n)*)<\/pre>\s*$/gi,
		attrRegExp = /\s*([^=\s]+)\s*=\s*"([^"]*)"/gi,
		match = divRegExp.exec(text);
	if(match) {
		var subMatch = subDivRegExp.exec(match[2]); // Body of the <DIV> tag
		if(subMatch) {
			result.text = subMatch[1];
		} else {
			result.text = match[2]; 
		}
		var attrMatch;
		do {
			attrMatch = attrRegExp.exec(match[1]);
			if(attrMatch) {
				var name = attrMatch[1];
				var value = attrMatch[2];
				result[name] = value;
			}
		} while(attrMatch);
	}
	return result;	
};

exports["application/x-tiddler-html-div"] = function(text,fields) {
	return [parseTiddlerDiv(text,fields)];
};

exports["application/json"] = function(text,fields) {
	var tiddlers = JSON.parse(text),
		result = [],
		getKnownFields = function(tid) {
			var fields = {};
			"title text created creator modified modifier type tags".split(" ").forEach(function(value) {
				if(tid[value] !== null) {
					fields[value] = tid[value];
				}
			});
			return fields;
		};
	for(var t=0; t<tiddlers.length; t++) {
		result.push(getKnownFields(tiddlers[t]));
	}
	return result;
};

exports["application/vnd.tiddlywiki2"] = function(text,fields) {
	var locateStoreArea = function(tiddlywikidoc) {
			var startSaveArea = '<div id="' + 'storeArea">',
				startSaveAreaRegExp = /<div id=["']?storeArea['"]?>/gi,
				endSaveArea = '</d' + 'iv>',
				endSaveAreaCaps = '</D' + 'IV>',
				posOpeningDiv = tiddlywikidoc.search(startSaveAreaRegExp),
				limitClosingDiv = tiddlywikidoc.indexOf("<"+"!--POST-STOREAREA--"+">");
			if(limitClosingDiv == -1) {
				limitClosingDiv = tiddlywikidoc.indexOf("<"+"!--POST-BODY-START--"+">");
			}
			var start = limitClosingDiv == -1 ? tiddlywikidoc.length : limitClosingDiv,
				posClosingDiv = tiddlywikidoc.lastIndexOf(endSaveArea,start);
			if(posClosingDiv == -1) {
				posClosingDiv = tiddlywikidoc.lastIndexOf(endSaveAreaCaps,start);
			}
			return (posOpeningDiv != -1 && posClosingDiv != -1) ? [posOpeningDiv + startSaveArea.length,posClosingDiv] : null;
		},
		results = [],
		storeAreaPos = locateStoreArea(text);
	if(storeAreaPos) {
		var endOfDivRegExp = /(<\/div>\s*)/gi,
			startPos = storeAreaPos[0];
		endOfDivRegExp.lastIndex = startPos;
		var match = endOfDivRegExp.exec(text);
		while(match && startPos < storeAreaPos[1]) {
			var endPos = endOfDivRegExp.lastIndex,
				tiddlerFields = parseTiddlerDiv(text.substring(startPos,endPos),fields);
			if(tiddlerFields.text !== null) {
				tiddlerFields.text = $tw.utils.htmlDecode(tiddlerFields.text);
				results.push(tiddlerFields);
			}
			startPos = endPos;
			match = endOfDivRegExp.exec(text);
		}
	}
	return results;
};

})();
});
</script><script data-tiddler-title="$:/core/modules/filters.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikimethod" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/filters.js","wikimethod",function(module,exports,require) {/*\
title: $:/core/modules/filters.js
type: application/javascript
module-type: wikimethod

Adds tiddler filtering to the $tw.Wiki object.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.filterTiddlers = function(filterString,currTiddlerTitle,tiddlerList) {
	var fn = this.compileFilter(filterString);
	return fn.call(this,tiddlerList || this.tiddlers,currTiddlerTitle);
};

/*
Compiling a filter gives a JavaScript function that is invoked as `this.filter(source)`, where `source` is a hashmap of source tiddler titles (the values don't matter, so it is possible to use a store or a changes object). It returns an array of tiddler titles that satisfy the filter
*/
exports.compileFilter = function(filterString) {
	var filter = this.parseFilter(filterString),
		output = [],
		t,operation,operationInfo,type,p,operator,operatorInfo,fn;
	output.push(this.filterFragments.prologue);
	for(t=0; t<filter.length; t++) {
		operation = filter[t];
		operationInfo = this.filterFragments.operation.prefix[operation.prefix || ""];
		output.push(operationInfo.prologue);
		type = "selector";
		if(operation.prefix === "+") {
			type = "filter";
		}
		for(p=0; p<operation.operators.length; p++) {
			operator = operation.operators[p];
			operatorInfo = this.operators[operator.operator];
			if(!operatorInfo) { // Check for it being a field operator
				operatorInfo = this.operators.field;
			}
			output.push(operatorInfo[type](operator));
			type = "filter";
		}
		output.push(operationInfo.epilogue);
	}
	output.push(this.filterFragments.epilogue);
	try {
		/*jslint evil: true */
		fn = eval(output.join("\n"));
	} catch(ex) {
		throw "Error in filter expression: " + ex;
	}
	return fn;
};

exports.filterFragments = {
	prologue: "(function(source,currTiddlerTitle) {\nvar results = [], subResults, subResultsTemp, title, r, t;",
	epilogue: "return results;\n})",
	operation: {
		prefix: {
			"": {
				prologue: "subResults = [];",
				epilogue: "$tw.utils.pushTop(results,subResults);"
			},
			"+": {
				prologue: "subResults = results.slice(0);\nresults.splice(0,results.length);",
				epilogue: "$tw.utils.pushTop(results,subResults);"
			},
			"-": {
				prologue: "subResults = [];",
				epilogue: "$tw.utils.removeArrayEntries(results,subResults);"
			}
		}
	}
};

exports.operators = {
	"title": { // Filter by title
		selector: function(operator) {
			return "$tw.utils.pushTop(subResults,\"" + $tw.utils.stringify(operator.operand) + "\");";
		},
		filter: function(operator) {
			return "if(subResults.indexOf(\"" + $tw.utils.stringify(operator.operand) + "\") !== -1) {subResults = [\"" + $tw.utils.stringify(operator.operand) + "\"];} else {subResults = [];}";
		}
	},
	"prefix": { // Filter by title prefix
		selector: function(operator) {
			var op = operator.prefix === "!" ? "!" : "=";
			return "for(title in source) {if(title.substr(0," + operator.operand.length + ")" + op + "==\"" + $tw.utils.stringify(operator.operand) + "\") {$tw.utils.pushTop(subResults,title);}}";
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "=" : "!";
			return "for(r=subResults.length-1; r>=0; r--) {if(title.substr(0," + operator.operand.length + ")" + op + "==\"" + $tw.utils.stringify(operator.operand) + "\") {subResults.splice(r,1);}}";
		}
	},
	"is": { // Filter by status
		selector: function(operator) {
			var op = operator.prefix === "!" ? "!" : "";
			switch(operator.operand) {
				case "current":
					if(operator.prefix === "!") {
						return "for(title in source) {if(title !== currTiddlerTitle) {$tw.utils.pushTop(subResults,title);}}";
					} else {
						return "$tw.utils.pushTop(subResults,currTiddlerTitle);";
					}
					break;
				case "shadow":
					return "for(title in source) {if(" + op + "this.getTiddler(title).isShadow()) {$tw.utils.pushTop(subResults,title);}}";
				default:
					throw "Unknown operand for 'is' filter operator";
			}
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "" : "!";
			switch(operator.operand) {
				case "current":
					if(operator.prefix === "!") {
						return "for(r=subResults.length-1; r>=0; r--) {if(subResults[r] === currTiddlerTitle) {subResults.splice(r,1);}}";
					} else {
						return "r = subResults.indexOf(currTiddlerTitle);\nif(r !== -1) {subResults = [currTiddlerTitle];} else {subResults = [];}";
					}
					break;
				case "shadow":
					return "for(r=subResults.length-1; r>=0; r--) {if(" + op + "this.getTiddler(subResults[r]).isShadow()) {subResults.splice(r,1);}}";
				default:
					throw "Unknown operand for 'is' filter operator";
			}
		}
	},
	"tag": { // Filter by tag
		selector: function(operator) {
			var op = operator.prefix === "!" ? "!" : "";
			return "for(title in source) {if(" + op + "this.getTiddler(title).hasTag(\"" + $tw.utils.stringify(operator.operand) + "\")) {$tw.utils.pushTop(subResults,title);}}";
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "" : "!";
			return "for(r=subResults.length-1; r>=0; r--) {if(" + op + "this.getTiddler(subResults[r]).hasTag(\"" + $tw.utils.stringify(operator.operand) + "\")) {subResults.splice(r,1);}}";
		}
	},
	"tags": { // Return all tags used on selected tiddlers
		selector: function(operator) {
			return "for(title in source) {r = this.getTiddler(title); if(r && r.fields.tags) {$tw.utils.pushTop(subResults,r.fields.tags);}}";
		},
		filter: function(operator) {
			return "subResultsTemp = subResults;\nsubResults = [];for(t=subResultsTemp.length-1; t>=0; t--) {r = this.getTiddler(subResultsTemp[t]); if(r && r.fields.tags) {$tw.utils.pushTop(subResults,r.fields.tags);}}";
		}
	},
	"tagging": { // Return all tiddlers tagged with any of the selected tags
		selector: function(operator) {
			return "for(title in source) {$tw.utils.pushTop(subResults,this.getTiddlersWithTag(title));}";
		},
		filter: function(operator) {
			return "subResultsTemp = subResults;\nsubResults = [];for(t=subResultsTemp.length-1; t>=0; t--) {$tw.utils.pushTop(subResults,this.getTiddlersWithTag(subResultsTemp[t]));}";
		}
	},
	"has": { // Filter by presence of a particular field
		selector: function(operator) {
			var op = operator.prefix === "!" ? "=" : "!";
			return "for(title in source) {if(this.getTiddler(title).fields[\"" + $tw.utils.stringify(operator.operand) + "\"] " + op + "== undefined) {$tw.utils.pushTop(subResults,title);}}";
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "!" : "=";
			return "for(r=subResults.length-1; r>=0; r--) {if(this.getTiddler(subResults[r]).fields[\"" + $tw.utils.stringify(operator.operand) + "\"] " + op + "== undefined) {subResults.splice(r,1);}}";
		}
	},
	"sort": { // Sort selected tiddlers
		selector: function(operator) {
			throw "Cannot use sort operator at the start of a filter operation";
		},
		filter: function(operator) {
			var desc = operator.prefix === "!" ? "true" : "false";
			return "this.sortTiddlers(subResults,\"" + $tw.utils.stringify(operator.operand) + "\"," + desc + ");";
		}
	}, // Case insensitive sort of selected tiddlers
	"sort-case-sensitive": {
		selector: function(operator) {
			throw "Cannot use sort operator at the start of a filter operation";
		},
		filter: function(operator) {
			var desc = operator.prefix === "!" ? "true" : "false";
			return "this.sortTiddlers(subResults,\"" + $tw.utils.stringify(operator.operand) + "\"," + desc + ",true);";
		}
	},
	"limit": { // Limit number of members of selection
		selector: function(operator) {
			throw "Cannot use limit operator at the start of a filter operation";
		},
		filter: function(operator) {
			var limit = parseInt(operator.operand,10),
				base = operator.prefix === "!" ? 0 : limit;
			return "if(subResults.length > " + limit + ") {subResults.splice(" + base + ",subResults.length-" + limit + ");}";
		}
	},
	"list": { // Select all tiddlers that are listed (or not listed) in the specified tiddler
		selector: function(operator) {
			if(operator.prefix === "!") {
				return "var list = this.getTiddlerList(\"" + $tw.utils.stringify(operator.operand) + "\");" +
					"for(title in source) {if(list.indexOf(title) === -1) {$tw.utils.pushTop(subResults,title);}}";
			} else {
				return "$tw.utils.pushTop(subResults,this.getTiddlerList(\"" + $tw.utils.stringify(operator.operand) + "\"));";
			}
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "!==" : "===";
			return "var list = this.getTiddlerList(\"" + $tw.utils.stringify(operator.operand) + "\");" +
				"for(r=subResults.length-1; r>=0; r--) {if(list.indexOf(title) " + op + " -1) {subResults.splice(r,1);}}";
		}
	},
	"searchVia": { // Search for the string in the operand tiddler
		selector: function(operator) {
			var op = operator.prefix === "!" ? "true" : "false";
			return "var term = this.getTiddler(\"" + $tw.utils.stringify(operator.operand) + "\").fields.text;" +
				"$tw.utils.pushTop(subResults,this.search(term,{titles: source, invert: " + op + ", exclude: [\"" + $tw.utils.stringify(operator.operand) + "\"]}));";
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "true" : "false";
			return "var term = this.getTiddler(\"" + $tw.utils.stringify(operator.operand) + "\").fields.text;" +
				"subResults = this.search(term,{titles: subResults, invert: " + op + ", exclude: [\"" + $tw.utils.stringify(operator.operand) + "\"]});";
		}
	},
	"field": { // Special handler for field comparisons
		selector: function(operator) {
			var op = operator.prefix === "!" ? "!" : "=";
			return "for(title in source) {if(this.getTiddler(title).fields[\"" + $tw.utils.stringify(operator.operator) + "\"] " + op + "== \"" + operator.operand + "\") {$tw.utils.pushTop(subResults,title);}}";
		},
		filter: function(operator) {
			var op = operator.prefix === "!" ? "=" : "!";
			return "for(r=subResults.length-1; r>=0; r--) {if(this.getTiddler(subResults[r]).fields[\"" + $tw.utils.stringify(operator.operator) + "\"] " + op + "== \"" + operator.operand + "\") {subResults.splice(r,1);}}";
		}
	}
};

/*
Parses an operation within a filter string
	results: Array of array of operator nodes into which results should be inserted
	filterString: filter string
	p: start position within the string
Returns the new start position, after the parsed operation
*/
function parseFilterOperation(operators,filterString,p) {
	var operator, operand, bracketPos;
	// Skip the starting square bracket
	if(filterString.charAt(p++) !== "[") {
		throw "Missing [ in filter expression";
	}
	// Process each operator in turn
	do {
		operator = {};
		// Check for an operator prefix
		if(filterString.charAt(p) === "!") {
			operator.prefix = filterString.charAt(p++);
		}
		// Get the operator name
		bracketPos = filterString.indexOf("[",p);
		if(bracketPos === -1) {
			throw "Missing [ in filter expression";
		}
		operator.operator = filterString.substring(p,bracketPos);
		if(operator.operator === "") {
			operator.operator = "title";
		}
		p = bracketPos + 1;
		// Get the operand
		bracketPos = filterString.indexOf("]",p);
		if(bracketPos === -1) {
			throw "Missing ] in filter expression";
		}
		operator.operand = filterString.substring(p,bracketPos);
		p = bracketPos + 1;
		// Push this operator
		operators.push(operator);
	} while(filterString.charAt(p) !== "]");
	// Skip the ending square bracket
	if(filterString.charAt(p++) !== "]") {
		throw "Missing ] in filter expression";
	}
	// Return the parsing position
	return p;
}

/*
Parse a filter string
*/
exports.parseFilter = function(filterString) {
	filterString = filterString || "";
	var results = [], // Array of arrays of operator nodes {operator:,operand:}
		p = 0, // Current position in the filter string
		match;
	var whitespaceRegExp = /(\s+)/mg,
		operandRegExp = /((?:\+|\-)?)(?:(\[)|("(?:[^"])*")|('(?:[^'])*')|([^\s\[\]]+))/mg;
	while(p < filterString.length) {
		// Skip any whitespace
		whitespaceRegExp.lastIndex = p;
		match = whitespaceRegExp.exec(filterString);
		if(match && match.index === p) {
			p = p + match[0].length;
		}
		// Match the start of the operation
		if(p < filterString.length) {
			operandRegExp.lastIndex = p;
			match = operandRegExp.exec(filterString);
			if(!match || match.index !== p) {
				throw "Syntax error in filter expression";
			}
			var operation = {
				prefix: "",
				operators: []
			};
			if(match[1]) {
				operation.prefix = match[1];
				p++;
			}
			if(match[2]) { // Opening square bracket
				p = parseFilterOperation(operation.operators,filterString,p);
			} else {
				p = match.index + match[0].length;
			}
			if(match[3] || match[4] || match[5]) { // Double quoted string, single quoted string or unquoted title
				operation.operators.push(
					{operator: "title", operand: match[3] || match[4] || match[5]}
				);
			}
			results.push(operation);
		}
	}
	return results;
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/imageparser.js" data-tiddler-type="application/javascript" data-tiddler-module-type="parser" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/imageparser.js","parser",function(module,exports,require) {/*\
title: $:/core/modules/parsers/imageparser.js
type: application/javascript
module-type: parser

The image parser parses an image into an embeddable HTML element

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ImageParser = function(type,text,options) {
	var element = "img",
		src;
	if(type === "application/pdf" || type === ".pdf") {
		src = "data:application/pdf;base64," + text;
		element = "embed";
	} else if(type === "image/svg+xml" || type === ".svg") {
		src = "data:image/svg+xml," + encodeURIComponent(text);
	} else {
		src = "data:" + type + ";base64," + text;
	}
	this.tree = [{
		type: "element",
		tag: element,
		attributes: {
			"src": {type: "string", value: src}
		}
	}];
};

exports["image/svg+xml"] = ImageParser;
exports["image/jpg"] = ImageParser;
exports["image/jpeg"] = ImageParser;
exports["image/png"] = ImageParser;
exports["image/gif"] = ImageParser;
exports["application/pdf"] = ImageParser;

})();

});
</script><script data-tiddler-title="$:/core/modules/parsers/textparser.js" data-tiddler-type="application/javascript" data-tiddler-module-type="parser" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/textparser.js","parser",function(module,exports,require) {/*\
title: $:/core/modules/parsers/textparser.js
type: application/javascript
module-type: parser

The plain text parser processes blocks of source text into a degenerate parse tree consisting of a single text node

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var TextParser = function(type,text,options) {
	this.tree = [{
		type: "element",
		tag: "pre",
		children: [{
			type: "text",
			text: text
		}]
	}];
};

exports["text/plain"] = TextParser;
exports["text/html"] = TextParser;
exports["application/javascript"] = TextParser;

})();

});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/codeblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/codeblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/codeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for code blocks. For example:

```
	```
	This text will not be //wikified//
	```
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "codeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /```\r?\n/mg;
};

exports.parse = function() {
	var reEnd = /(\r?\n```$)/mg;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Look for the end of the block
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the block
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	// Return the pre element
	return [{
		type: "element",
		tag: "pre",
		children: [{
			type: "text",
			text: text
		}]
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/codeinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/codeinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/codeinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for code runs. For example:

```
	This is a `code run`.
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "codeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /`/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	var reEnd = /`/mg;
	// Look for the end marker
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the text
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	return [{
		type: "element",
		tag: "code",
		children: [{
			type: "text",
			text: text
		}]
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/commentblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/commentblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/commentblock.js
type: application/javascript
module-type: wikirule

Wiki text block rule for HTML comments. For example:

```
<!-- This is a comment -->
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "commentblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match - HTML comment regexp by Stephen Ostermiller, http://ostermiller.org/findhtmlcomment.html
	this.matchRegExp = /\<![ \r\n\t]*(?:--(?:[^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>\r?\n/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Don't return any elements
	return [];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/commentinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/commentinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/commentinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for HTML comments. For example:

```
<!-- This is a comment -->
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "commentinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match - HTML comment regexp by Stephen Ostermiller, http://ostermiller.org/findhtmlcomment.html
	this.matchRegExp = /\<![ \r\n\t]*(?:--(?:[^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Don't return any elements
	return [];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/dash.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/dash.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/dash.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for dashes. For example:

```
This is an en-dash: --

This is an em-dash: ---
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "dash";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /-{2,3}(?!-)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	var dash = this.match[0].length === 2 ? "&ndash;" : "&mdash;";
	return [{
		type: "entity",
		entity: dash
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/emphasis.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/emphasis.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/emphasis.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for emphasis. For example:

```
	This is ''bold'' text

	This is //italic// text

	This is __underlined__ text

	This is ^^superscript^^ text

	This is ,,subscript,, text

	This is ~~strikethrough~~ text
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "emphasis";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /''|\/\/|__|\^\^|,,|~~/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Figure out which element and closing regexp to use
	var tag,reEnd;
	switch(this.match[0]) {
		case "''": // Bold
			tag = "strong";
			reEnd = /''/mg;
			break;
		case "//": // Italics
			tag = "em";
			reEnd = /\/\//mg;
			break;
		case "__": // Underline
			tag = "u";
			reEnd = /__/mg;
			break;
		case "^^": // Superscript
			tag = "sup";
			reEnd = /\^\^/mg;
			break;
		case ",,": // Subscript
			tag = "sub";
			reEnd = /,,/mg;
			break;
		case "~~": // Strikethrough
			tag = "strike";
			reEnd = /~~/mg;
			break;
	}
	// Parse the run including the terminator
	var tree = this.parser.parseInlineRun(reEnd,{eatTerminator: true});
	// Return the classed span
	return [{
		type: "element",
		tag: tag,
		children: tree
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/entity.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/entity.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/entity.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for HTML entities. For example:

```
	This is a copyright symbol: &copy;
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "entity";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(&#?[a-zA-Z0-9]{2,8};)/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var entityString = this.match[1];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	// Return the entity
	return [{type: "entity", entity: this.match[0]}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/extlink.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/extlink.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/extlink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for external links. For example:

```
An external link: http://www.tiddlywiki.com/

A suppressed external link: ~http://www.tiddlyspace.com/
```

External links can be suppressed by preceding them with `~`.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "extlink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /~?(?:file|http|https|mailto|ftp|irc|news|data):[^\s'"]+(?:\/|\b)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Create the link unless it is suppressed
	if(this.match[0].substr(0,1) === "~") {
		return [{type: "text", text: this.match[0].substr(1)}];
	} else {
		return [{
			type: "element",
			tag: "$link",
			attributes: {
				to: {type: "string", value: this.match[0]}
			},
			children: [{
				type: "text", text: this.match[0]
			}]
		}];
	}
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/filteredtranscludeblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/filteredtranscludeblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/filteredtranscludeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for block-level filtered transclusion. For example:

```
{{{ [tag[docs]] }}}
{{{ [tag[docs]] |tooltip}}}
{{{ [tag[docs]] ||TemplateTitle}}}
{{{ [tag[docs]] |tooltip||TemplateTitle}}}
{{{ [tag[docs]] }}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "filteredtranscludeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{\{([^\|]+?)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}\}([^\}]*)\}(?:\.(\S+))?(?:\r?\n|$)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var filter = this.match[1],
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the list widget
	var node = {
		type: "element",
		tag: "$list",
		attributes: {
			filter: {type: "string", value: filter}
		},
		isBlock: true
	};
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes["itemClass"] = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/filteredtranscludeinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/filteredtranscludeinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/filteredtranscludeinline.js
type: application/javascript
module-type: wikirule

Wiki text rule for inline filtered transclusion. For example:

```
{{{ [tag[docs]] }}}
{{{ [tag[docs]] |tooltip}}}
{{{ [tag[docs]] ||TemplateTitle}}}
{{{ [tag[docs]] |tooltip||TemplateTitle}}}
{{{ [tag[docs]] }}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "filteredtranscludeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{\{([^\|]+?)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}\}([^\}]*)\}(?:\.(\S+))?/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var filter = this.match[1],
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the list widget
	var node = {
		type: "element",
		tag: "$list",
		attributes: {
			filter: {type: "string", value: filter}
		}
	};
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes["itemClass"] = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/heading.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/heading.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/heading.js
type: application/javascript
module-type: wikirule

Wiki text block rule for headings

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "heading";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /(!{1,6})/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var headingLevel = this.match[1].length;
	// Move past the !s
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse any classes, whitespace and then the heading itself
	var classes = this.parser.parseClasses();
	this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
	var tree = this.parser.parseInlineRun(/(\r?\n)/mg);
	// Return the heading
	return [{
		type: "element",
		tag: "h" + this.match[1].length, 
		attributes: {
			"class": {type: "string", value: classes.join(" ")}
		},
		children: tree
	}];
};
})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/horizrule.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/horizrule.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/horizrule.js
type: application/javascript
module-type: wikirule

Wiki text block rule for rules. For example:

```
---
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "horizrule";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /-{3,}\r?\n/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	return [{type: "element", tag: "hr"}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/html.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/html.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/html.js
type: application/javascript
module-type: wikirule

Wiki rule for HTML elements and widgets. For example:

{{{
<aside>
This is an HTML5 aside element
</aside>

<$slider target="MyTiddler">
This is a widget invocation
</$slider>

}}}

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "html";
exports.types = {inline: true, block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	if(this.is.block) {
		this.matchRegExp = /<([A-Za-z\$]+)(\s*[^>]*?)(\/)?>(\r?\n)/mg;
	} else {
		this.matchRegExp = /<([A-Za-z\$]+)(\s*[^>]*?)(?:(\/>)|(?:>(\r?\n)?))/mg;
	}
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match in case this parser is called recursively
	var tagName = this.match[1],
		attributeString = this.match[2],
		isSelfClosing = !!this.match[3],
		hasLineBreak = !!this.match[4];
	// Move past the tag name and parameters
	this.parser.pos = this.matchRegExp.lastIndex;
	var reAttr = /\s*([A-Za-z\-_]+)(?:\s*=\s*(?:("[^"]*")|('[^']*')|(\{\{[^\}]*\}\})|([^"'\s]+)))?/mg;
	// Process the attributes
	var attrMatch = reAttr.exec(attributeString),
		attributes = {};
	while(attrMatch) {
		var name = attrMatch[1],
			value;
		if(attrMatch[2]) { // Double quoted
			value = {type: "string", value: attrMatch[2].substring(1,attrMatch[2].length-1)};
		} else if(attrMatch[3]) { // Single quoted
			value = {type: "string", value: attrMatch[3].substring(1,attrMatch[3].length-1)};
		} else if(attrMatch[4]) { // Double curly brace quoted
			value = {type: "indirect", textReference: attrMatch[4].substr(2,attrMatch[4].length-4)};
		} else if(attrMatch[5]) { // Unquoted
			value = {type: "string", value: attrMatch[5]};
		} else { // Valueless
			value = {type: "string", value: "true"}; // TODO: We should have a way of indicating we want an attribute without a value
		}
		attributes[name] = value;
		attrMatch = reAttr.exec(attributeString);
	}
	// Process the end tag
	if(!isSelfClosing && $tw.config.htmlVoidElements.indexOf(tagName) === -1) {
		var reEndString = "(</" + $tw.utils.escapeRegExp(tagName) + ">)",
			reEnd = new RegExp(reEndString,"mg"),
			content;
		if(hasLineBreak) {
			content = this.parser.parseBlocks(reEndString);
		} else {
			content = this.parser.parseInlineRun(reEnd);
		}
		reEnd.lastIndex = this.parser.pos;
		var endMatch = reEnd.exec(this.parser.source);
		if(endMatch && endMatch.index === this.parser.pos) {
			this.parser.pos = endMatch.index + endMatch[0].length;
		}
	} else {
		content = [];
	}
	var element = {
		type: "element",
		tag: tagName,
		isBlock: this.is.block || hasLineBreak,
		attributes: attributes,
		children: content
	};
	return [element];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/list.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/list.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/list.js
type: application/javascript
module-type: wikirule

Wiki text block rule for lists. For example:

```
* This is an unordered list
* It has two items

# This is a numbered list
## With a subitem
# And a third item

; This is a term that is being defined
: This is the definition of that term
```

Note that lists can be nested arbitrarily:

```
#** One
#* Two
#** Three
#**** Four
#**# Five
#**## Six
## Seven
### Eight
## Nine
```

A CSS class can be applied to a list item as follows:

```
* List item one
*.active List item two has the class `active`
* List item three
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "list";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /([\\*#;:]+)/mg;
};

var listTypes = {
	"*": {listTag: "ul", itemTag: "li"},
	"#": {listTag: "ol", itemTag: "li"},
	";": {listTag: "dl", itemTag: "dt"},
	":": {listTag: "dl", itemTag: "dd"}
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Array of parse tree nodes for the previous row of the list
	var listStack = [];
	// Cycle through the items in the list
	while(true) {
		// Match the list marker
		var reMatch = /(^[\*#;:]+)/mg;
		reMatch.lastIndex = this.parser.pos;
		var match = reMatch.exec(this.parser.source);
		if(!match || match.index !== this.parser.pos) {
			break;
		}
		// Check whether the list type of the top level matches
		var listInfo = listTypes[match[0].charAt(0)];
		if(listStack.length > 0 && listStack[0].tag !== listInfo.listTag) {
			break;
		}
		// Move past the list marker
		this.parser.pos = match.index + match[0].length;
		// Walk through the list markers for the current row
		for(var t=0; t<match[0].length; t++) {
			listInfo = listTypes[match[0].charAt(t)];
			// Remove any stacked up element if we can't re-use it because the list type doesn't match
			if(listStack.length > t && listStack[t].tag !== listInfo.listTag) {
				listStack.splice(t,listStack.length - t);
			}
			// Construct the list element or reuse the previous one at this level
			if(listStack.length <= t) {
				var listElement = {type: "element", tag: listInfo.listTag, children: [
					{type: "element", tag: listInfo.itemTag, children: []}
				]};
				// Link this list element into the last child item of the parent list item
				if(t) {
					var prevListItem = listStack[t-1].children[listStack[t-1].children.length-1];
					prevListItem.children.push(listElement);
				}
				// Save this element in the stack
				listStack[t] = listElement;
			} else if(t === (match[0].length - 1)) {
				listStack[t].children.push({type: "element", tag: listInfo.itemTag, children: []});
			}
		}
		if(listStack.length > match[0].length) {
			listStack.splice(match[0].length,listStack.length - match[0].length);
		}
		// Process the body of the list item into the last list item
		var lastListChildren = listStack[listStack.length-1].children,
			lastListItem = lastListChildren[lastListChildren.length-1],
			classes = this.parser.parseClasses();
		this.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});
		var tree = this.parser.parseInlineRun(/(\r?\n)/mg);
		lastListItem.children.push.apply(lastListItem.children,tree);
		if(classes.length > 0) {
			$tw.utils.addClassToParseTreeNode(lastListItem,classes.join(" "));
		}
		// Consume any whitespace following the list item
		this.parser.skipWhitespace();
	};
	// Return the root element of the list
	return [listStack[0]];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/macrocallblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/macrocallblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/macrocallblock.js
type: application/javascript
module-type: wikirule

Wiki rule for block macro calls

```
<<name value value2>>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrocallblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /<<([^\s>]+)\s*([\s\S]*?)>>(?:\r?\n|$)/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var macroName = this.match[1],
		paramString = this.match[2];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	var params = [],
		reParam = /\s*(?:([A-Za-z0-9\-_]+)\s*:)?(?:\s*(?:"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))/mg,
		paramMatch = reParam.exec(paramString);
	while(paramMatch) {
		// Process this parameter
		var paramInfo = {
			value: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5]
		};
		if(paramMatch[1]) {
			paramInfo.name = paramMatch[1];
		}
		params.push(paramInfo);
		// Find the next match
		paramMatch = reParam.exec(paramString);
	}
	return [{
		type: "macrocall",
		name: macroName,
		params: params,
		isBlock: true
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/macrocallinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/macrocallinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/macrocallinline.js
type: application/javascript
module-type: wikirule

Wiki rule for macro calls

```
<<name value value2>>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrocallinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /<<([^\s>]+)\s*([\s\S]*?)>>/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get all the details of the match
	var macroName = this.match[1],
		paramString = this.match[2];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	var params = [],
		reParam = /\s*(?:([A-Za-z0-9\-_]+)\s*:)?(?:\s*(?:"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))/mg,
		paramMatch = reParam.exec(paramString);
	while(paramMatch) {
		// Process this parameter
		var paramInfo = {
			value: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5]
		};
		if(paramMatch[1]) {
			paramInfo.name = paramMatch[1];
		}
		params.push(paramInfo);
		// Find the next match
		paramMatch = reParam.exec(paramString);
	}
	return [{
		type: "macrocall",
		name: macroName,
		params: params
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/macrodef.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/macrodef.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/macrodef.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for macro definitions

```
\define name(param:defaultvalue,param2:defaultvalue)
definition text, including $param$ markers
\end
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "macrodef";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\define\s+([^(\s]+)\(\s*([^)]*)\)(\r?\n)?/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Move past the macro name and parameters
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse the parameters
	var paramString = this.match[2],
		params = [];
	if(paramString !== "") {
		var reParam = /\s*([A-Za-z0-9\-_]+)(?:\s*:\s*(?:"([^"]*)"|'([^']*)'|\[\[([^\]]*)\]\]|([^"'\s]+)))?/mg,
			paramMatch = reParam.exec(paramString);
		while(paramMatch) {
			// Save the parameter details
			var paramInfo = {name: paramMatch[1]},
				defaultValue = paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5];
			if(defaultValue) {
				paramInfo["default"] = defaultValue;
			}
			params.push(paramInfo);
			// Look for the next parameter
			paramMatch = reParam.exec(paramString);
		}
	}
	// Is this a multiline definition?
	var reEnd;
	if(this.match[3]) {
		// If so, the end of the body is marked with \end
		reEnd = /(\r?\n\\end\r?\n)/mg;
	} else {
		// Otherwise, the end of the definition is marked by the end of the line
		reEnd = /(\r?\n)/mg;
	}
	// Find the end of the definition
	reEnd.lastIndex = this.parser.pos;
	var text,
		endMatch = reEnd.exec(this.parser.source);
	if(endMatch) {
		text = this.parser.source.substring(this.parser.pos,endMatch.index);
		this.parser.pos = endMatch.index + endMatch[0].length;
	} else {
		// We didn't find the end of the definition, so we'll make it blank
		text = "";
	}
	// Save the macro definition
	return [{
		type: "macrodef",
		name: this.match[1],
		params: params,
		text: text
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/prettylink.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/prettylink.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/prettylink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for pretty links. For example:

```
[[Introduction]]

[[Link description|TiddlerTitle]]
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "prettylink";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\[\[(.*?)(?:\|(.*?))?\]\]/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Process the link
	var text = this.match[1],
		link = this.match[2] || text;
	return [{
		type: "element",
		tag: "$link",
		attributes: {
			to: {type: "string", value: link}
		},
		children: [{
			type: "text", text: text
		}]
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/rules.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/rules.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/rules.js
type: application/javascript
module-type: wikirule

Wiki pragma rule for rules specifications

```
\rules except ruleone ruletwo rulethree
\rules only ruleone ruletwo rulethree
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "rules";
exports.types = {pragma: true};

/*
Instantiate parse rule
*/
exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\\rules[^\S\n]/mg;
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Move past the pragma invocation
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse whitespace delimited tokens terminated by a line break
	var reMatch = /[^\S\n]*(\S+)|(\r?\n)/mg,
		tokens = [];
	reMatch.lastIndex = this.parser.pos;
	var match = reMatch.exec(this.parser.source);
	while(match && match.index === this.parser.pos) {
		this.parser.pos = reMatch.lastIndex;
		// Exit if we've got the line break
		if(match[2]) {
			break;
		}
		// Process the token
		if(match[1]) {
			tokens.push(match[1]);
		}
		// Match the next token
		match = reMatch.exec(this.parser.source);
	}
	// Process the tokens
	if(tokens.length > 0) {
		this.parser.amendRules(tokens[0],tokens.slice(1));
	}
	// No parse tree nodes to return
	return [];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/styleblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/styleblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/styleblock.js
type: application/javascript
module-type: wikirule

Wiki text block rule for assigning styles and classes to paragraphs and other blocks. For example:

```
@@.myClass
@@background-color:red;
This paragraph will have the CSS class `myClass`.

* The `<ul>` around this list will also have the class `myClass`
* List item 2

@@
```

Note that classes and styles can be mixed subject to the rule that styles must precede classes. For example

```
@@.myFirstClass.mySecondClass
@@width:100px;.myThirdClass
This is a paragraph
@@
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "styleblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /@@((?:[^\.\r\n\s:]+:[^\r\n;]+;)+)?(?:\.([^\r\n\s]+))?\r?\n/mg;
};

exports.parse = function() {
	var reEndString = "^@@(?:\\r?\\n)?";
	var classes = [], styles = [];
	do {
		// Get the class and style
		if(this.match[1]) {
			styles.push(this.match[1]);
		}
		if(this.match[2]) {
			classes.push(this.match[2].split(".").join(" "));
		}
		// Move past the match
		this.parser.pos = this.matchRegExp.lastIndex;
		// Look for another line of classes and styles
		this.match = this.matchRegExp.exec(this.parser.source);
	} while(this.match && this.match.index === this.parser.pos);
	// Parse the body
	var tree = this.parser.parseBlocks(reEndString);
	for(var t=0; t<tree.length; t++) {
		if(classes.length > 0) {
			$tw.utils.addClassToParseTreeNode(tree[t],classes.join(" "));
		}
		if(styles.length > 0) {
			$tw.utils.addAttributeToParseTreeNode(tree[t],"style",styles.join(""));
		}
	}
	return tree;
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/styleinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/styleinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/styleinline.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for assigning styles and classes to inline runs. For example:

```
@@.myClass This is some text with a class@@
@@background-color:red;This is some text with a background colour@@
@@width:100px;.myClass This is some text with a class and a width@@
```


\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "styleinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /@@((?:[^\.\r\n\s:]+:[^\r\n;]+;)+)?(\.(?:[^\r\n\s]+)\s+)?/mg;
};

exports.parse = function() {
	var reEnd = /@@/g;
	// Get the styles and class
	var stylesString = this.match[1],
		classString = this.match[2] ? this.match[2].split(".").join(" ") : undefined;
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Parse the run up to the terminator
	var tree = this.parser.parseInlineRun(reEnd,{eatTerminator: true});
	// Return the classed span
	var node = {
		type: "element",
		tag: "span",
		attributes: {
			"class": {type: "string", value: "tw-inline-style"}
		},
		children: tree
	};
	if(classString) {
		$tw.utils.addClassToParseTreeNode(node,classString);
	}
	if(stylesString) {
		$tw.utils.addAttributeToParseTreeNode(node,"style",stylesString);
	}
	return [node];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/table.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/table.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/table.js
type: application/javascript
module-type: wikirule

Wiki text block rule for tables.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "table";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /^\|(?:[^\n]*)\|(?:[fhck]?)\r?\n/mg;
};

var processRow = function(prevColumns) {
	var cellRegExp = /(?:\|([^\n\|]*)\|)|(\|[fhck]?\r?\n)/mg,
		cellTermRegExp = /((?:\x20*)\|)/mg,
		tree = [],
		col = 0,
		colSpanCount = 1,
		prevCell;
	// Match a single cell
	cellRegExp.lastIndex = this.parser.pos;
	var cellMatch = cellRegExp.exec(this.parser.source);
	while(cellMatch && cellMatch.index === this.parser.pos) {
		if(cellMatch[1] === "~") {
			// Rowspan
			var last = prevColumns[col];
			if(last) {
				last.rowSpanCount++;
				$tw.utils.addAttributeToParseTreeNode(last.element,"rowspan",last.rowSpanCount);
				$tw.utils.addAttributeToParseTreeNode(last.element,"valign","center");
				if(colSpanCount > 1) {
					$tw.utils.addAttributeToParseTreeNode(last.element,"colspan",colSpanCount);
					colSpanCount = 1;
				}
			}
			// Move to just before the `|` terminating the cell
			this.parser.pos = cellRegExp.lastIndex - 1;
		} else if(cellMatch[1] === ">") {
			// Colspan
			colSpanCount++;
			// Move to just before the `|` terminating the cell
			this.parser.pos = cellRegExp.lastIndex - 1;
		} else if(cellMatch[2]) {
			// End of row
			if(prevCell && colSpanCount > 1) {
				$tw.utils.addAttributeToParseTreeNode(prevCell,"colspan",colSpanCount);
			}
			this.parser.pos = cellRegExp.lastIndex - 1;
			break;
		} else {
			// For ordinary cells, step beyond the opening `|`
			this.parser.pos++;
			// Look for a space at the start of the cell
			var spaceLeft = false,
				chr = this.parser.source.substr(this.parser.pos,1);
			while(chr === " ") {
				spaceLeft = true;
				this.parser.pos++;
				chr = this.parser.source.substr(this.parser.pos,1);
			}
			// Check whether this is a heading cell
			var cell;
			if(chr === "!") {
				this.parser.pos++;
				cell = {type: "element", tag: "th", children: []};
			} else {
				cell = {type: "element", tag: "td", children: []};
			}
			tree.push(cell);
			// Record information about this cell
			prevCell = cell;
			prevColumns[col] = {rowSpanCount:1,element:cell};
			// Check for a colspan
			if(colSpanCount > 1) {
				$tw.utils.addAttributeToParseTreeNode(cell,"colspan",colSpanCount);
				colSpanCount = 1;
			}
			// Parse the cell
			cell.children = this.parser.parseInlineRun(cellTermRegExp,{eatTerminator: true});
			// Set the alignment for the cell
			if(cellMatch[1].substr(cellMatch[1].length-1,1) === " ") { // spaceRight
				$tw.utils.addAttributeToParseTreeNode(cell,"align",spaceLeft ? "center" : "left");
			} else if(spaceLeft) {
				$tw.utils.addAttributeToParseTreeNode(cell,"align","right");
			}
			// Move back to the closing `|`
			this.parser.pos--;
		}
		col++;
		cellRegExp.lastIndex = this.parser.pos;
		cellMatch = cellRegExp.exec(this.parser.source);
	}
	return tree;
};

exports.parse = function() {
	var rowContainerTypes = {"c":"caption", "h":"thead", "":"tbody", "f":"tfoot"},
		table = {type: "element", tag: "table", children: []},
		rowRegExp = /^\|([^\n]*)\|([fhck]?)\r?\n/mg,
		rowTermRegExp = /(\|(?:[fhck]?)\r?\n)/mg,
		prevColumns = [],
		currRowType,
		rowContainer,
		rowCount = 0;
	// Match the row
	rowRegExp.lastIndex = this.parser.pos;
	var rowMatch = rowRegExp.exec(this.parser.source);
	while(rowMatch && rowMatch.index === this.parser.pos) {
		var rowType = rowMatch[2];
		// Check if it is a class assignment
		if(rowType === "k") {
			$tw.utils.addClassToParseTreeNode(table,rowMatch[1]);
			this.parser.pos = rowMatch.index + rowMatch[0].length;
		} else {
			// Otherwise, create a new row if this one is of a different type
			if(rowType != currRowType) {
				rowContainer = {type: "element", tag: rowContainerTypes[rowType], children: []};
				table.children.push(rowContainer);
				currRowType = rowType;
			}
			// Is this a caption row?
			if(currRowType === "c") {
				// If so, move past the opening `|` of the row
				this.parser.pos++;
				// Move the caption to the first row if it isn't already
				if(table.children.length !== 1) {
					table.children.pop(); // Take rowContainer out of the children array
					table.children.splice(0,0,rowContainer); // Insert it at the bottom						
				}
				// Set the alignment - TODO: figure out why TW did this
//				rowContainer.attributes.align = rowCount === 0 ? "top" : "bottom";
				// Parse the caption
				rowContainer.children = this.parser.parseInlineRun(rowTermRegExp,{eatTerminator: true});
			} else {
				// Create the row
				var theRow = {type: "element", tag: "tr", children: []};
				$tw.utils.addClassToParseTreeNode(theRow,rowCount%2 ? "oddRow" : "evenRow");
				rowContainer.children.push(theRow);
				// Process the row
				theRow.children = processRow.call(this,prevColumns);
				this.parser.pos = rowMatch.index + rowMatch[0].length;
				// Increment the row count
				rowCount++;
			}
		}
		rowMatch = rowRegExp.exec(this.parser.source);
	}
	return [table];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/transcludeblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/transcludeblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/transcludeblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for block-level transclusion. For example:

```
{{MyTiddler}}
{{MyTiddler|tooltip}}
{{MyTiddler||TemplateTitle}}
{{MyTiddler|tooltip||TemplateTitle}}
{{MyTiddler}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "transcludeblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{([^\{\}\|]+)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}([^\}]*)\}(?:\.(\S+))?(?:\r?\n|$)/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var textRef = $tw.utils.trim(this.match[1]),
		tr = $tw.utils.parseTextReference(textRef),
		targetTitle = tr.title,
		targetField = tr.field,
		targetIndex = tr.index,
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the transclude widget
	var node = {
		type: "element",
		tag: "$transclude",
		attributes: {
			target: {type: "string", value: targetTitle}
		},
		isBlock: true
	};
	if(targetField) {
		node.attributes.field = {type: "string", value: targetField};
	}
	if(targetIndex) {
		node.attributes.index = {type: "string", value: targetIndex};
	}
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes["class"] = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/transcludeinline.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/transcludeinline.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/transcludeinline.js
type: application/javascript
module-type: wikirule

Wiki text rule for inline-level transclusion. For example:

```
{{MyTiddler}}
{{MyTiddler|tooltip}}
{{MyTiddler||TemplateTitle}}
{{MyTiddler|tooltip||TemplateTitle}}
{{MyTiddler}width:40;height:50;}.class.class
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "transcludeinline";
exports.types = {inline: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\{\{([^\{\}\|]+)(?:\|([^\|\{\}]+))?(?:\|\|([^\|\{\}]+))?\}([^\}]*)\}(?:\.(\S+))?/mg;
};

exports.parse = function() {
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Get the match details
	var textRef = $tw.utils.trim(this.match[1]),
		tr = $tw.utils.parseTextReference(textRef),
		targetTitle = tr.title,
		targetField = tr.field,
		targetIndex = tr.index,
		tooltip = this.match[2],
		template = $tw.utils.trim(this.match[3]),
		style = this.match[4],
		classes = this.match[5];
	// Return the transclude widget
	var node = {
		type: "element",
		tag: "$transclude",
		attributes: {
			target: {type: "string", value: targetTitle}
		}
	};
	if(targetField) {
		node.attributes.field = {type: "string", value: targetField};
	}
	if(targetIndex) {
		node.attributes.index = {type: "string", value: targetIndex};
	}
	if(tooltip) {
		node.attributes.tooltip = {type: "string", value: tooltip};
	}
	if(template) {
		node.attributes.template = {type: "string", value: template};
	}
	if(style) {
		node.attributes.style = {type: "string", value: style};
	}
	if(classes) {
		node.attributes["class"] = {type: "string", value: classes.split(".").join(" ")};
	}
	return [node];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/typedblock.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/typedblock.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/typedblock.js
type: application/javascript
module-type: wikirule

Wiki text rule for typed blocks. For example:

```
$$$.js
This will be rendered as JavaScript
$$$

$$$.svg
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="100">
  <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red" />
</svg>
$$$

$$$text/vnd.tiddlywiki>text/html
This will be rendered as an //HTML representation// of WikiText
$$$
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "typedblock";
exports.types = {block: true};

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = /\$\$\$([^ >\r\n]*)(?: *> *([^ \r\n]+))?\r?\n/mg;
};

exports.parse = function() {
	var reEnd = /\r?\n\$\$\$\r?\n/mg;
	// Save the type
	var parseType = this.match[1],
		renderType = this.match[2];
	// Move past the match
	this.parser.pos = this.matchRegExp.lastIndex;
	// Look for the end of the block
	reEnd.lastIndex = this.parser.pos;
	var match = reEnd.exec(this.parser.source),
		text;
	// Process the block
	if(match) {
		text = this.parser.source.substring(this.parser.pos,match.index);
		this.parser.pos = match.index + match[0].length;
	} else {
		text = this.parser.source.substr(this.parser.pos);
		this.parser.pos = this.parser.sourceLength;
	}
	// Parse the block according to the specified type
	var parser = this.parser.wiki.parseText(parseType,text,{defaultType: "text/plain"});
	// If there's no render type, just return the parse tree
	if(!renderType) {
		return parser.tree;
	} else {
		// Otherwise, render to the rendertype and return in a <PRE> tag
		var renderTree = new $tw.WikiRenderTree(parser,{wiki: $tw.wiki});
		renderTree.execute();
		return [{
			type: "element",
			tag: "pre",
			children: [{
				type: "text",
				text: renderTree.render(renderType)
			}]
		}];
	}
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/wikilink.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirule" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/wikilink.js","wikirule",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/wikilink.js
type: application/javascript
module-type: wikirule

Wiki text inline rule for wiki links. For example:

```
AWikiLink
AnotherLink
~SuppressedLink
```

Precede a camel case word with `~` to prevent it from being recognised as a link.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "wikilink";
exports.types = {inline: true};

var textPrimitives = {
	upperLetter: "[A-Z\u00c0-\u00de\u0150\u0170]",
	lowerLetter: "[a-z0-9_\\-\u00df-\u00ff\u0151\u0171]",
	anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]",
	anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]"
};

textPrimitives.unWikiLink = "~";
textPrimitives.wikiLink = textPrimitives.upperLetter + "+" +
	textPrimitives.lowerLetter + "+" +
	textPrimitives.upperLetter +
	textPrimitives.anyLetter + "*";

exports.init = function(parser) {
	this.parser = parser;
	// Regexp to match
	this.matchRegExp = new RegExp(textPrimitives.unWikiLink + "?" + textPrimitives.wikiLink,"mg");
};

/*
Parse the most recent match
*/
exports.parse = function() {
	// Get the details of the match
	var linkText = this.match[0];
	// Move past the macro call
	this.parser.pos = this.matchRegExp.lastIndex;
	// If the link starts with the unwikilink character then just output it as plain text
	if(linkText.substr(0,1) === textPrimitives.unWikiLink) {
		return [{type: "text", text: linkText.substr(1)}];
	}
	// If the link has been preceded with a letter then don't treat it as a link
	if(this.match.index > 0) {
		var preRegExp = new RegExp(textPrimitives.anyLetterStrict,"mg");
		preRegExp.lastIndex = this.match.index-1;
		var preMatch = preRegExp.exec(this.parser.source);
		if(preMatch && preMatch.index === this.match.index-1) {
			return [{type: "text", text: linkText}];
		}
	}
	return [{
		type: "element",
		tag: "$link",
		attributes: {
			to: {type: "string", value: linkText}
		},
		children: [{
			type: "text",
			text: linkText
		}]
	}];
};

})();
});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/wikiparser.js" data-tiddler-type="application/javascript" data-tiddler-module-type="parser" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/wikiparser.js","parser",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/wikiparser.js
type: application/javascript
module-type: parser

The wiki text parser processes blocks of source text into a parse tree.

The parse tree is made up of nested arrays of these JavaScript objects:

	{type: "element", tag: <string>, attributes: {}, children: []} - an HTML element
	{type: "text", text: <string>} - a text node
	{type: "entity", value: <string>} - an entity
	{type: "raw", html: <string>} - raw HTML

Attributes are stored as hashmaps of the following objects:

	{type: "string", value: <string>} - literal string
	{type: "array", value: <string array>} - array of strings
	{type: "styles", value: <object>} - hashmap of style strings
	{type: "indirect", textReference: <textReference>} - indirect through a text reference

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var WikiParser = function(type,text,options) {
	this.wiki = options.wiki;
	// Initialise the classes if we don't have them already
	if(!this.pragmaRuleClasses) {
		WikiParser.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules("wikirule","pragma",$tw.WikiRuleBase);
	}
	if(!this.blockRuleClasses) {
		WikiParser.prototype.blockRuleClasses = $tw.modules.createClassesFromModules("wikirule","block",$tw.WikiRuleBase);
	}
	if(!this.inlineRuleClasses) {
		WikiParser.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules("wikirule","inline",$tw.WikiRuleBase);
	}
	// Save the parse text
	this.type = type || "text/vnd.tiddlywiki";
	this.source = text || "";
	this.sourceLength = this.source.length;
	// Set current parse position
	this.pos = 0;
	// Instantiate the pragma parse rules
	this.pragmaRules = this.instantiateRules(this.pragmaRuleClasses,"pragma",0);
	// Instantiate the parser block and inline rules
	this.blockRules = this.instantiateRules(this.blockRuleClasses,"block",0);
	this.inlineRules = this.instantiateRules(this.inlineRuleClasses,"inline",0);
	// Parse any pragmas
	this.tree = this.parsePragmas();
	// Parse the text into inline runs or blocks
	if(options.parseAsInline) {
		this.tree.push.apply(this.tree,this.parseInlineRun());
	} else {
		this.tree.push.apply(this.tree,this.parseBlocks());
	}
	// Return the parse tree
};

/*
Instantiate an array of parse rules
*/
WikiParser.prototype.instantiateRules = function(classes,type,startPos) {
	var rulesInfo = [],
		self = this;
	$tw.utils.each(classes,function(RuleClass) {
		// Instantiate the rule
		var rule = new RuleClass(self);
		rule.is = {};
		rule.is[type] = true;
		rule.init(self);
		var matchIndex = rule.findNextMatch(startPos);
		if(matchIndex !== undefined) {
			rulesInfo.push({
				rule: rule,
				matchIndex: matchIndex
			});
		}
	});
	return rulesInfo;
};

/*
Skip any whitespace at the current position. Options are:
	treatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace
*/
WikiParser.prototype.skipWhitespace = function(options) {
	options = options || {};
	var whitespaceRegExp = options.treatNewlinesAsNonWhitespace ? /([^\S\n]+)/mg : /(\s+)/mg;
	whitespaceRegExp.lastIndex = this.pos;
	var whitespaceMatch = whitespaceRegExp.exec(this.source);
	if(whitespaceMatch && whitespaceMatch.index === this.pos) {
		this.pos = whitespaceRegExp.lastIndex;
	}
};

/*
Get the next match out of an array of parse rule instances
*/
WikiParser.prototype.findNextMatch = function(rules,startPos) {
	// Find the best matching rule by finding the closest match position
	var matchingRule = undefined,
		matchingRulePos = this.sourceLength;
	// Step through each rule
	for(var t=0; t<rules.length; t++) {
		var ruleInfo = rules[t];
		// Ask the rule to get the next match if we've moved past the current one
		if(ruleInfo.matchIndex !== undefined  && ruleInfo.matchIndex < startPos) {
			ruleInfo.matchIndex = ruleInfo.rule.findNextMatch(startPos);
		}
		// Adopt this match if it's closer than the current best match
		if(ruleInfo.matchIndex !== undefined && ruleInfo.matchIndex <= matchingRulePos) {
			matchingRule = ruleInfo;
			matchingRulePos = ruleInfo.matchIndex;
		}
	}
	return matchingRule;
};

/*
Parse any pragmas at the beginning of a block of parse text
*/
WikiParser.prototype.parsePragmas = function() {
	var tree = [];
	while(true) {
		// Skip whitespace
		this.skipWhitespace();
		// Check for the end of the text
		if(this.pos >= this.sourceLength) {
			break;
		}
		// Check if we've arrived at a pragma rule match
		var nextMatch = this.findNextMatch(this.pragmaRules,this.pos);
		// If not, just exit
		if(!nextMatch || nextMatch.matchIndex !== this.pos) {
			break;
		}
		// Process the pragma rule
		tree.push.apply(tree,nextMatch.rule.parse());
	}
	return tree;
};

/*
Parse a block from the current position
	terminatorRegExpString: optional regular expression string that identifies the end of plain paragraphs. Must not include capturing parenthesis
*/
WikiParser.prototype.parseBlock = function(terminatorRegExpString) {
	var terminatorRegExp = terminatorRegExpString ? new RegExp("(" + terminatorRegExpString + "|\\r?\\n\\r?\\n)","mg") : /(\r?\n\r?\n)/mg;
	this.skipWhitespace();
	if(this.pos >= this.sourceLength) {
		return [];
	}
	// Look for a block rule that applies at the current position
	var nextMatch = this.findNextMatch(this.blockRules,this.pos);
	if(nextMatch && nextMatch.matchIndex === this.pos) {
		return nextMatch.rule.parse();
	}
	// Treat it as a paragraph if we didn't find a block rule
	return [{type: "element", tag: "p", children: this.parseInlineRun(terminatorRegExp)}];
};

/*
Parse a series of blocks of text until a terminating regexp is encountered or the end of the text
	terminatorRegExpString: terminating regular expression
*/
WikiParser.prototype.parseBlocks = function(terminatorRegExpString) {
	if(terminatorRegExpString) {
		return this.parseBlocksTerminated(terminatorRegExpString);
	} else {
		return this.parseBlocksUnterminated();
	}
};

/*
Parse a block from the current position to the end of the text
*/
WikiParser.prototype.parseBlocksUnterminated = function() {
	var tree = [];
	while(this.pos < this.sourceLength) {
		tree.push.apply(tree,this.parseBlock());
	}
	return tree;
};

/*
Parse blocks of text until a terminating regexp is encountered
*/
WikiParser.prototype.parseBlocksTerminated = function(terminatorRegExpString) {
	var terminatorRegExp = new RegExp("(" + terminatorRegExpString + ")","mg"),
		tree = [];
	// Skip any whitespace
	this.skipWhitespace();
	//  Check if we've got the end marker
	terminatorRegExp.lastIndex = this.pos;
	var match = terminatorRegExp.exec(this.source);
	// Parse the text into blocks
	while(this.pos < this.sourceLength && !(match && match.index === this.pos)) {
		var blocks = this.parseBlock(terminatorRegExpString);
		tree.push.apply(tree,blocks);
		// Skip any whitespace
		this.skipWhitespace();
		//  Check if we've got the end marker
		terminatorRegExp.lastIndex = this.pos;
		match = terminatorRegExp.exec(this.source);
	}
	if(match && match.index === this.pos) {
		this.pos = match.index + match[0].length;
	}
	return tree;
};

/*
Parse a run of text at the current position
	terminatorRegExp: a regexp at which to stop the run
	options: see below
Options available:
	eatTerminator: move the parse position past any encountered terminator (default false)
*/
WikiParser.prototype.parseInlineRun = function(terminatorRegExp,options) {
	if(terminatorRegExp) {
		return this.parseInlineRunTerminated(terminatorRegExp,options);
	} else {
		return this.parseInlineRunUnterminated(options);
	}
};

WikiParser.prototype.parseInlineRunUnterminated = function(options) {
	var tree = [];
	// Find the next occurrence of an inline rule
	var nextMatch = this.findNextMatch(this.inlineRules,this.pos);
	// Loop around the matches until we've reached the end of the text
	while(this.pos < this.sourceLength && nextMatch) {
		// Process the text preceding the run rule
		if(nextMatch.matchIndex > this.pos) {
			tree.push({type: "text", text: this.source.substring(this.pos,nextMatch.matchIndex)});
			this.pos = nextMatch.matchIndex;
		}
		// Process the run rule
		tree.push.apply(tree,nextMatch.rule.parse());
		// Look for the next run rule
		nextMatch = this.findNextMatch(this.inlineRules,this.pos);
	}
	// Process the remaining text
	if(this.pos < this.sourceLength) {
		tree.push({type: "text", text: this.source.substr(this.pos)});
	}
	this.pos = this.sourceLength;
	return tree;
};

WikiParser.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {
	options = options || {};
	var tree = [];
	// Find the next occurrence of the terminator
	terminatorRegExp.lastIndex = this.pos;
	var terminatorMatch = terminatorRegExp.exec(this.source);
	// Find the next occurrence of a inlinerule
	var inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);
	// Loop around until we've reached the end of the text
	while(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {
		// Return if we've found the terminator, and it precedes any inline rule match
		if(terminatorMatch) {
			if(!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {
				if(terminatorMatch.index > this.pos) {
					tree.push({type: "text", text: this.source.substring(this.pos,terminatorMatch.index)});
				}
				this.pos = terminatorMatch.index;
				if(options.eatTerminator) {
					this.pos += terminatorMatch[0].length;
				}
				return tree;
			}
		}
		// Process any inline rule, along with the text preceding it
		if(inlineRuleMatch) {
			// Preceding text
			if(inlineRuleMatch.matchIndex > this.pos) {
				tree.push({type: "text", text: this.source.substring(this.pos,inlineRuleMatch.matchIndex)});
				this.pos = inlineRuleMatch.matchIndex;
			}
			// Process the inline rule
			tree.push.apply(tree,inlineRuleMatch.rule.parse());
			// Look for the next inline rule
			inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);
			// Look for the next terminator match
			terminatorRegExp.lastIndex = this.pos;
			terminatorMatch = terminatorRegExp.exec(this.source);
		}
	}
	// Process the remaining text
	if(this.pos < this.sourceLength) {
		tree.push({type: "text", text: this.source.substr(this.pos)});
	}
	this.pos = this.sourceLength;
	return tree;
};

/*
Parse zero or more class specifiers `.classname`
*/
WikiParser.prototype.parseClasses = function() {
	var classRegExp = /\.([^\s\.]+)/mg,
		classNames = [];
	classRegExp.lastIndex = this.pos;
	var match = classRegExp.exec(this.source);
	while(match && match.index === this.pos) {
		this.pos = match.index + match[0].length;
		classNames.push(match[1]);
		var match = classRegExp.exec(this.source);
	}
	return classNames;
};

/*
Amend the rules used by this instance of the parser
	type: `only` keeps just the named rules, `except` keeps all but the named rules
	names: array of rule names
*/
WikiParser.prototype.amendRules = function(type,names) {
	names = names || [];
	// Define the filter function
	var keepFilter;
	if(type === "only") {
		keepFilter = function(name) {
			return names.indexOf(name) !== -1;
		};
	} else if(type === "except") {
		keepFilter = function(name) {
			return names.indexOf(name) === -1;
		};
	} else {
		return;
	}
	// Define a function to process each of our rule arrays
	var processRuleArray = function(ruleArray) {
		for(var t=ruleArray.length-1; t>=0; t--) {
			if(!keepFilter(ruleArray[t].rule.name)) {
				ruleArray.splice(t,1);
			}
		}
	};
	// Process each rule array
	processRuleArray(this.pragmaRules);
	processRuleArray(this.blockRules);
	processRuleArray(this.inlineRules);
}

exports["text/vnd.tiddlywiki"] = WikiParser;

})();

});
</script><script data-tiddler-title="$:/core/modules/parsers/wikiparser/rules/wikirulebase.js" data-tiddler-type="application/javascript" data-tiddler-module-type="global" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/parsers/wikiparser/rules/wikirulebase.js","global",function(module,exports,require) {/*\
title: $:/core/modules/parsers/wikiparser/rules/wikirulebase.js
type: application/javascript
module-type: global

Base class for wiki parser rules

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
This constructor is always overridden with a blank constructor, and so shouldn't be used
*/
var WikiRuleBase = function() {
};

/*
To be overridden by individual rules
*/
WikiRuleBase.prototype.init = function(parser) {
	this.parser = parser;
};

/*
Default implementation of findNextMatch uses RegExp matching
*/
WikiRuleBase.prototype.findNextMatch = function(startPos) {
	this.matchRegExp.lastIndex = startPos;
	this.match = this.matchRegExp.exec(this.parser.source);
	return this.match ? this.match.index : undefined;
};

exports.WikiRuleBase = WikiRuleBase;

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/element.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/element.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/element.js
type: application/javascript
module-type: wikirenderer

Element renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Element widget. A degenerate widget that renders ordinary HTML elements
*/
var ElementWidget = function(renderer) {
	this.renderer = renderer;
	this.tag = this.renderer.parseTreeNode.tag;
	this.attributes = this.renderer.attributes;
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
	this.events = this.renderer.parseTreeNode.events;
};

ElementWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Check if any of our attribute dependencies have changed
	if($tw.utils.count(changedAttributes) > 0) {
		// Update our attributes
		this.renderer.assignAttributes();
	}
	// Refresh any child nodes
	$tw.utils.each(this.children,function(node) {
		if(node.refreshInDom) {
			node.refreshInDom(changedTiddlers);
		}
	});
};

/*
Element renderer
*/
var ElementRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
	// Initialise widget classes
	if(!this.widgetClasses) {
		ElementRenderer.prototype.widgetClasses = $tw.modules.applyMethods("widget");
	}
	// Compute our dependencies
	this.dependencies = {};
	var self = this;
	$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {
		if(attribute.type === "indirect") {
			var tr = $tw.utils.parseTextReference(attribute.textReference);
			self.dependencies[tr.title ? tr.title : renderContext.tiddlerTitle] = true;
		}
	});
	// Compute our attributes
	this.attributes = {};
	this.computeAttributes();
	// Create the parasite widget object if required
	if(this.parseTreeNode.tag.charAt(0) === "$") {
		// Choose the class
		var WidgetClass = this.widgetClasses[this.parseTreeNode.tag.substr(1)];
		// Instantiate the widget
		if(WidgetClass) {
			this.widget = new WidgetClass(this);
		} else {
			WidgetClass = this.widgetClasses.error;
			if(WidgetClass) {
				this.widget = new WidgetClass(this,"Unknown widget '<" + this.parseTreeNode.tag + ">'");
			}
		}
	}
	// If we haven't got a widget, use the generic HTML element widget
	if(!this.widget) {
		this.widget = new ElementWidget(this);
	}
};

ElementRenderer.prototype.computeAttributes = function() {
	var changedAttributes = {};
	var self = this;
	$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {
		if(attribute.type === "indirect") {
			var value = self.renderTree.wiki.getTextReference(attribute.textReference,"",self.renderContext.tiddlerTitle);
			if(self.attributes[name] !== value) {
				self.attributes[name] = value;
				changedAttributes[name] = true;
			}
		} else { // String attribute
			if(self.attributes[name] !== attribute.value) {
				self.attributes[name] = attribute.value;
				changedAttributes[name] = true;
			}
		}
	});
	return changedAttributes;
};

ElementRenderer.prototype.hasAttribute = function(name) {
	return $tw.utils.hop(this.attributes,name);
};

ElementRenderer.prototype.getAttribute = function(name,defaultValue) {
	if($tw.utils.hop(this.attributes,name)) {
		return this.attributes[name];
	} else {
		return defaultValue;
	}
};

ElementRenderer.prototype.render = function(type) {
	var isHtml = type === "text/html",
		output = [],attr,a,v;
	if(isHtml) {
		output.push("<",this.widget.tag);
		if(this.widget.attributes) {
			attr = [];
			for(a in this.widget.attributes) {
				attr.push(a);
			}
			attr.sort();
			for(a=0; a<attr.length; a++) {
				v = this.widget.attributes[attr[a]];
				if(v !== undefined) {
					if($tw.utils.isArray(v)) {
						v = v.join(" ");
					} else if(typeof v === "object") {
						var s = [];
						for(var p in v) {
							s.push(p + ":" + v[p] + ";");
						}
						v = s.join("");
					}
					output.push(" ",attr[a],"='",$tw.utils.htmlEncode(v),"'");
				}
			}
		}
		output.push(">\n");
	}
	if($tw.config.htmlVoidElements.indexOf(this.widget.tag) === -1) {
		$tw.utils.each(this.widget.children,function(node) {
			if(node.render) {
				output.push(node.render(type));
			}
		});
		if(isHtml) {
			output.push("</",this.widget.tag,">");
		}
	}
	return output.join("");
};

ElementRenderer.prototype.renderInDom = function() {
	// Check if our widget is providing an element
	if(this.widget.tag) {
		// Create the element
		this.domNode = document.createElement(this.widget.tag);
		// Assign any specified event handlers
		$tw.utils.addEventListeners(this.domNode,this.widget.events);
		// Assign the attributes
		this.assignAttributes();
		// Render any child nodes
		var self = this;
		$tw.utils.each(this.widget.children,function(node) {
			if(node.renderInDom) {
				self.domNode.appendChild(node.renderInDom());
			}
		});
		// Call postRenderInDom if the widget provides it
		if(this.widget.postRenderInDom) {
			this.widget.postRenderInDom();
		}
		// Return the dom node
		return this.domNode;
	} else {
		// If we're not generating an element, just render our first child
		return this.widget.children[0].renderInDom();
	}
};

ElementRenderer.prototype.assignAttributes = function() {
	var self = this;
	$tw.utils.each(this.widget.attributes,function(v,a) {
		if(v !== undefined) {
			if($tw.utils.isArray(v)) { // Ahem, could there be arrays other than className?
				self.domNode.className = v.join(" "); 
			} else if (typeof v === "object") { // ...or objects other than style?
				for(var p in v) {
					self.domNode.style[$tw.utils.unHyphenateCss(p)] = v[p];
				}
			} else {
				self.domNode.setAttribute(a,v);
			}
		}
	});
};

ElementRenderer.prototype.refreshInDom = function(changedTiddlers) {
	// Update our attributes if required
	var changedAttributes = {};
	if($tw.utils.checkDependencies(this.dependencies,changedTiddlers)) {
		changedAttributes = this.computeAttributes();
	}
	// Check if the widget has a refreshInDom method
	if(this.widget.refreshInDom) {
		// Let the widget refresh itself
		this.widget.refreshInDom(changedAttributes,changedTiddlers);
	} else {
		// If not, assign the attributes and refresh any child nodes
		this.assignAttributes();
		$tw.utils.each(this.widget.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

ElementRenderer.prototype.getContextTiddlerTitle = function() {
	var context = this.renderContext;
	while(context) {
		if($tw.utils.hop(context,"tiddlerTitle")) {
			return context.tiddlerTitle;
		}
		context = context.parentContext;
	}
	return undefined;
};

/*
Check for render context recursion by returning true if the members of a proposed new render context are already present in the render context chain
*/
ElementRenderer.prototype.checkContextRecursion = function(newRenderContext) {
	var context = this.renderContext;
	while(context) {
		var match = true;
		for(var member in newRenderContext) {
			if($tw.utils.hop(newRenderContext,member)) {
				if(newRenderContext[member] && newRenderContext[member] !== context[member]) {
					match = false;
				}
			}
		}
		if(match) {
			return true;
		}
		context = context.parentContext;
	}
	return false;
};

ElementRenderer.prototype.getContextScopeId = function() {
	var guidBits = [],
		context = this.renderContext;
	while(context) {
		$tw.utils.each(context,function(field,name) {
			if(name !== "parentContext") {
				guidBits.push(name + ":" + field + ";");
			}
		});
		guidBits.push("-");
		context = context.parentContext;
	}
	return guidBits.join("");
};

/*
Find a named macro definition
*/
ElementRenderer.prototype.findMacroDefinition = function(name) {
	var context = this.renderContext;
	while(context) {
		if(context.macroDefinitions && context.macroDefinitions[name]) {
			return context.macroDefinitions[name];
		}
		context = context.parentContext;
	}
	return undefined;
};

exports.element = ElementRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/entity.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/entity.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/entity.js
type: application/javascript
module-type: wikirenderer

Entity renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Entity renderer
*/
var EntityRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
};

EntityRenderer.prototype.render = function(type) {
	return type === "text/html" ? this.parseTreeNode.entity : $tw.utils.entityDecode(this.parseTreeNode.entity);
};

EntityRenderer.prototype.renderInDom = function() {
	return document.createTextNode($tw.utils.entityDecode(this.parseTreeNode.entity));
};

exports.entity = EntityRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/macrocall.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/macrocall.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/macrocall.js
type: application/javascript
module-type: wikirenderer

Macro call renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Macro call renderer
*/
var MacroCallRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
	// Find the macro definition
	var macro = this.findMacroDefinition(this.parseTreeNode.name);
	// Insert an error message if we couldn't find the macro
	var childTree;
	if(!macro) {
		childTree = [{type: "text", text: "<<Undefined macro: " + this.parseTreeNode.name + ">>"}];
	} else {
		// Substitute the macro parameters
		var text = this.substituteParameters(macro.text,this.parseTreeNode,macro);
		// Parse the text
		childTree = this.renderTree.wiki.parseText("text/vnd.tiddlywiki",text,{parseAsInline: !this.parseTreeNode.isBlock}).tree;
	}
	// Create the renderers for the child nodes
	this.children = this.renderTree.createRenderers(this.renderContext,childTree);
};

/*
Find a named macro definition
*/
MacroCallRenderer.prototype.findMacroDefinition = function(name) {
	var context = this.renderContext;
	while(context) {
		if(context.macroDefinitions && context.macroDefinitions[name]) {
			return context.macroDefinitions[name];
		}
		context = context.parentContext;
	}
	return undefined;
};

/*
Expand the parameters in a block of text
*/
MacroCallRenderer.prototype.substituteParameters = function(text,macroCallParseTreeNode,macroDefinition) {
	var nextAnonParameter = 0; // Next candidate anonymous parameter in macro call
	// Step through each of the parameters in the macro definition
	for(var p=0; p<macroDefinition.params.length; p++) {
		// Check if we've got a macro call parameter with the same name
		var paramInfo = macroDefinition.params[p],
			paramValue = undefined;
		for(var m=0; m<macroCallParseTreeNode.params.length; m++) {
			if(macroCallParseTreeNode.params[m].name === paramInfo.name) {
				paramValue = macroCallParseTreeNode.params[m].value;
			}
		}
		// If not, use the next available anonymous macro call parameter
		if(!paramValue && macroCallParseTreeNode.params.length > 0) {
			while(macroCallParseTreeNode.params[nextAnonParameter].name && nextAnonParameter < macroCallParseTreeNode.params.length-1) {
				nextAnonParameter++;
			}
			if(!macroCallParseTreeNode.params[nextAnonParameter].name) {
				paramValue = macroCallParseTreeNode.params[nextAnonParameter].value;
				nextAnonParameter++;
			}
		}
		// If we've still not got a value, use the default, if any
		paramValue = paramValue || paramInfo["default"] || "";
		// Replace any instances of this parameter
		text = text.replace(new RegExp("\\$" + $tw.utils.escapeRegExp(paramInfo.name) + "\\$","mg"),paramValue);
	}
	return text;
};

MacroCallRenderer.prototype.render = function(type) {
	var output = [];
	$tw.utils.each(this.children,function(node) {
		if(node.render) {
			output.push(node.render(type));
		}
	});
	return output.join("");
};

MacroCallRenderer.prototype.renderInDom = function() {
	// Create the element
	this.domNode = document.createElement(this.parseTreeNode.isBlock ? "div" : "span");
	this.domNode.setAttribute("data-macro-name",this.parseTreeNode.name);
	// Render any child nodes
	var self = this;
	$tw.utils.each(this.children,function(node,index) {
		if(node.renderInDom) {
			self.domNode.appendChild(node.renderInDom());
		}
	});
	// Return the dom node
	return this.domNode;
};

exports.macrocall = MacroCallRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/macrodef.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/macrodef.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/macrodef.js
type: application/javascript
module-type: wikirenderer

Macro definition renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Macro definition renderer
*/
var MacroDefRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
	// Save the macro definition into the render context
	this.renderContext.macroDefinitions = this.renderContext.macroDefinitions || {};
	this.renderContext.macroDefinitions[this.parseTreeNode.name] = this.parseTreeNode;
};

exports.macrodef = MacroDefRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/raw.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/raw.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/raw.js
type: application/javascript
module-type: wikirenderer

Raw HTML renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Raw HTML renderer
*/
var RawRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
};

RawRenderer.prototype.render = function(type) {
	return this.parseTreeNode.html;
};

RawRenderer.prototype.renderInDom = function() {
	var domNode = document.createElement("div");
	domNode.innerHTML = this.parseTreeNode.html;
	return domNode;
};

exports.raw = RawRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/renderers/text.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikirenderer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/renderers/text.js","wikirenderer",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/renderers/text.js
type: application/javascript
module-type: wikirenderer

Text renderer

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Text renderer
*/
var TextRenderer = function(renderTree,renderContext,parseTreeNode) {
	// Store state information
	this.renderTree = renderTree;
	this.renderContext = renderContext;
	this.parseTreeNode = parseTreeNode;
};

TextRenderer.prototype.render = function(type) {
	return type === "text/html" ? $tw.utils.htmlEncode(this.parseTreeNode.text) : this.parseTreeNode.text;
};

TextRenderer.prototype.renderInDom = function() {
	return document.createTextNode(this.parseTreeNode.text);
};

exports.text = TextRenderer

})();
});
</script><script data-tiddler-title="$:/core/modules/rendertree/wikirendertree.js" data-tiddler-type="application/javascript" data-tiddler-module-type="global" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/rendertree/wikirendertree.js","global",function(module,exports,require) {/*\
title: $:/core/modules/rendertree/wikirendertree.js
type: application/javascript
module-type: global

Wiki text render tree

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Create a render tree object for a parse tree
*/
var WikiRenderTree = function(parser,options) {
	this.parser = parser;
	this.wiki = options.wiki;
	// Hashmap of the renderer classes
	if(!this.rendererClasses) {
		WikiRenderTree.prototype.rendererClasses = $tw.modules.applyMethods("wikirenderer");
	}

};

/*
Generate the full render tree for this parse tree
	renderContext: see below
An renderContext consists of these fields:
	tiddlerTitle: title of the tiddler providing the context
	parentContext: reference back to previous context in the stack
*/
WikiRenderTree.prototype.execute = function(renderContext) {
	renderContext = renderContext || {};
	this.rendererTree = this.createRenderers(renderContext,this.parser.tree);
};

/*
Create an array of renderers for an array of parse tree nodes
*/
WikiRenderTree.prototype.createRenderers = function(renderContext,parseTreeNodes) {
	var rendererNodes = [];
	if(parseTreeNodes) {
		for(var t=0; t<parseTreeNodes.length; t++) {
			rendererNodes.push(this.createRenderer(renderContext,parseTreeNodes[t]));
		}
	}
	return rendererNodes;
};	

/*
Create a renderer node for a parse tree node
*/
WikiRenderTree.prototype.createRenderer = function(renderContext,parseTreeNode) {
	var RenderNodeClass = this.rendererClasses[parseTreeNode.type];
	return new RenderNodeClass(this,renderContext,parseTreeNode);
};

/*
Render as a string
*/
WikiRenderTree.prototype.render = function(type) {
	var output = [];
	$tw.utils.each(this.rendererTree,function(node) {
		if(node.render) {
			output.push(node.render(type));
		}
	});
	return output.join("");
};

/*
Render to the DOM
*/
WikiRenderTree.prototype.renderInDom = function(container) {
	this.container = container;
	$tw.utils.each(this.rendererTree,function(node) {
		if(node.renderInDom) {
			container.appendChild(node.renderInDom());
		}
	});
};

/*
Update the DOM rendering in the light of a set of changes
*/
WikiRenderTree.prototype.refreshInDom = function(changes) {
	$tw.utils.each(this.rendererTree,function(node) {
		if(node.refreshInDom) {
			node.refreshInDom(changes);
		}
	});
};

exports.WikiRenderTree = WikiRenderTree;

})();
});
</script><script data-tiddler-title="$:/core/modules/savers/download.js" data-tiddler-type="application/javascript" data-tiddler-module-type="saver" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/savers/download.js","saver",function(module,exports,require) {/*\
title: $:/core/modules/savers/download.js
type: application/javascript
module-type: saver

Handles saving changes via HTML5's download APIs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var DownloadSaver = function(wiki) {
};

DownloadSaver.prototype.save = function(text) {
	// Set up the link
	var link = document.createElement("a");
	link.setAttribute("target","_blank");
	link.setAttribute("href","data:text/html," + encodeURIComponent(text));
	link.setAttribute("download","tiddlywiki.html");
	link.click();
	return true;
};

/*
Information about this saver
*/
DownloadSaver.prototype.info = {
	name: "download",
	priority: 100
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return document.createElement("a").download !== undefined;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new DownloadSaver(wiki);
};

})();
});
</script><script data-tiddler-title="$:/core/modules/savers/manualdownload.js" data-tiddler-type="application/javascript" data-tiddler-module-type="saver" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/savers/manualdownload.js","saver",function(module,exports,require) {/*\
title: $:/core/modules/savers/manualdownload.js
type: application/javascript
module-type: saver

Handles saving changes via HTML5's download APIs

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

// Title of the tiddler containing the download message
var downloadInstructionsTitle = "$:/messages/Download"

/*
Select the appropriate saver module and set it up
*/
var ManualDownloadSaver = function(wiki) {
};

ManualDownloadSaver.prototype.save = function(text) {
	$tw.modal.display(downloadInstructionsTitle,{
		downloadLink: "data:text/html," + encodeURIComponent(text)
	});
	return true;
};

/*
Information about this saver
*/
ManualDownloadSaver.prototype.info = {
	name: "manualdownload",
	priority: 0
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new ManualDownloadSaver(wiki);
};

})();
});
</script><script data-tiddler-title="$:/core/modules/savers/tiddlyfox.js" data-tiddler-type="application/javascript" data-tiddler-module-type="saver" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/savers/tiddlyfox.js","saver",function(module,exports,require) {/*\
title: $:/core/modules/savers/tiddlyfox.js
type: application/javascript
module-type: saver

Handles saving changes via the TiddlyFox file extension

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false, netscape: false, Components: false */
"use strict";

var TiddlyFoxSaver = function(wiki) {
};

TiddlyFoxSaver.prototype.save = function(text) {
	var messageBox = document.getElementById("tiddlyfox-message-box");
	if(messageBox) {
		// Create the message element and put it in the message box
		var message = document.createElement("div");
		message.setAttribute("data-tiddlyfox-path",document.location.pathname);
		message.setAttribute("data-tiddlyfox-content",text);
		messageBox.appendChild(message);
		// Create and dispatch the custom event to the extension
		var event = document.createEvent("Events");
		event.initEvent("tiddlyfox-save-file",true,false);
		message.dispatchEvent(event);
		return true;
	} else {
		return false;
	}
};

/*
Information about this saver
*/
TiddlyFoxSaver.prototype.info = {
	name: "tiddlyfox",
	priority: 1500
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return (window.location.protocol === "file:");
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new TiddlyFoxSaver(wiki);
};

})();
});
</script><script data-tiddler-title="$:/core/modules/savers/upload.js" data-tiddler-type="application/javascript" data-tiddler-module-type="saver" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/savers/upload.js","saver",function(module,exports,require) {/*\
title: $:/core/modules/savers/upload.js
type: application/javascript
module-type: saver

Handles saving changes via upload to a server.

Designed to be compatible with BidiX's UploadPlugin at http://tiddlywiki.bidix.info/#UploadPlugin

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Select the appropriate saver module and set it up
*/
var UploadSaver = function(wiki) {
	this.wiki = wiki;
};

UploadSaver.prototype.save = function(text) {
	// Get the various parameters we need
	var backupDir = ".",
		userName = this.wiki.getTextReference("$:/UploadName"),
		password = $tw.utils.getPassword("upload"),
		uploadDir = ".",
		url = this.wiki.getTextReference("$:/UploadURL");
	// Bail out if we don't have the bits we need
	if(!userName || userName.toString().trim() === "" || !password || password.toString().trim() === "") {
		return false;
	}
	// Construct the url if not provided
	if(!url) {
		url = "http://" + userName + ".tiddlyspot.com/store.cgi";
	}
	// Assemble the header
	var boundary = "---------------------------" + "AaB03x";	
	var uploadFormName = "UploadPlugin";
	var head = [];
	head.push("--" + boundary + "\r\nContent-disposition: form-data; name=\"UploadPlugin\"\r\n");
	head.push("backupDir=" + backupDir + ";user=" + userName + ";password=" + password + ";uploaddir=" + uploadDir + ";;"); 
	head.push("\r\n" + "--" + boundary);
	head.push("Content-disposition: form-data; name=\"userfile\"; filename=\"index.html\"");
	head.push("Content-Type: text/html;charset=UTF-8");
	head.push("Content-Length: " + text.length + "\r\n");
	head.push("");
	// Assemble the tail and the data itself
	var tail = "\r\n--" + boundary + "--\r\n",
		data = head.join("\r\n") + text + tail;
	// Do the HTTP post
	var http = new XMLHttpRequest();
	http.open("POST",url,true,userName,password);
	http.setRequestHeader("Content-Type","multipart/form-data; ;charset=UTF-8; boundary=" + boundary);
	http.onreadystatechange = function() {
		if(http.readyState == 4 && http.status == 200) {
			window.alert(http.responseText);
		}
	};
	http.send(data);
	return true;
};

/*
Information about this saver
*/
UploadSaver.prototype.info = {
	name: "upload",
	priority: 500
};

/*
Static method that returns true if this saver is capable of working
*/
exports.canSave = function(wiki) {
	return true;
};

/*
Create an instance of this saver
*/
exports.create = function(wiki) {
	return new UploadSaver(wiki);
};

})();
});
</script><script data-tiddler-title="$:/core/modules/startup.js" data-tiddler-type="application/javascript" data-tiddler-module-type="startup" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/startup.js","startup",function(module,exports,require) {/*\
title: $:/core/modules/startup.js
type: application/javascript
module-type: startup

This is the main application logic for both the client and server

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.startup = function() {
	var modules,n,m,f,commander;
	// Load modules
	$tw.modules.applyMethods("global",$tw);
	$tw.modules.applyMethods("config",$tw.config);
	$tw.modules.applyMethods("utils",$tw.utils);
	if($tw.browser) {
		$tw.utils.getBrowserInfo($tw.browser);
	}
	$tw.version = $tw.utils.extractVersionInfo();
	$tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap("tiddlerfield");
	$tw.modules.applyMethods("tiddlermethod",$tw.Tiddler.prototype);
	$tw.modules.applyMethods("wikimethod",$tw.Wiki.prototype);
	$tw.modules.applyMethods("tiddlerdeserializer",$tw.Wiki.tiddlerDeserializerModules);
	// Set up the wiki store
	$tw.wiki.initParsers();
	$tw.wiki.initSyncers();
	// Set up the command modules
	$tw.Commander.initCommands();
	// Get the default tiddlers
	var defaultTiddlersTitle = "$:/DefaultTiddlers",
		defaultTiddlersTiddler = $tw.wiki.getTiddler(defaultTiddlersTitle),
		defaultTiddlers = [];
	if(defaultTiddlersTiddler) {
		defaultTiddlers = $tw.wiki.filterTiddlers(defaultTiddlersTiddler.fields.text);
	}
	// Initialise the story and history
	var storyTitle = "$:/StoryList",
		story = [];
	for(var t=0; t<defaultTiddlers.length; t++) {
		story[t] = defaultTiddlers[t];
	}
	$tw.wiki.addTiddler({title: storyTitle, text: story.join("\n")});
	// Host-specific startup
	if($tw.browser) {
		// Call browser startup modules
		$tw.modules.forEachModuleOfType("browser-startup",function(title,module) {
			if(module.startup) {
				module.startup();
			}
		});
		// Install the popup manager
		$tw.popup = new $tw.utils.Popup({
			rootElement: document.body
		});
		// Install the modal message mechanism
		$tw.modal = new $tw.utils.Modal($tw.wiki);
		document.addEventListener("tw-modal",function(event) {
			$tw.modal.display(event.param);
		},false);
		// Install the syncer message mechanism
		document.addEventListener("tw-login",function(event) {
			$tw.wiki.invokeSyncers("handleLoginEvent",event);
		},false);
		document.addEventListener("tw-logout",function(event) {
			$tw.wiki.invokeSyncers("handleLogoutEvent",event);
		},false);
		// Install the scroller
		$tw.pageScroller = new $tw.utils.PageScroller();
		document.addEventListener("tw-scroll",$tw.pageScroller,false);
		// Install the save action handler
		$tw.wiki.initSavers();
		document.addEventListener("tw-save-wiki",function(event) {
			$tw.wiki.saveWiki({
				template: event.param,
				downloadType: "text/plain"
			});
		},false);
		// Install the crypto event handlers
		document.addEventListener("tw-set-password",function(event) {
			$tw.passwordPrompt.createPrompt({
				serviceName: "Set a new password for this TiddlyWiki",
				noUserName: true,
				submitText: "Set password",
				callback: function(data) {
					$tw.crypto.setPassword(data.password);
					return true; // Get rid of the password prompt
				}
			});
		});
		document.addEventListener("tw-clear-password",function(event) {
			$tw.crypto.setPassword(null);
		});
		// Apply stylesheets
		var styleTiddlers = $tw.wiki.getTiddlersWithTag("$:/core/styles");
		$tw.utils.each(styleTiddlers,function(title) {
			// Stylesheets don't refresh, yet
			var parser = $tw.wiki.parseTiddler(title),
				renderTree = new $tw.WikiRenderTree(parser,{wiki: $tw.wiki});
			renderTree.execute({tiddlerTitle: title});
			var styleNode = document.createElement("style");
			styleNode.type = "text/css";
			var text = renderTree.render("text/plain");
			styleNode.appendChild(document.createTextNode(text));
			document.getElementsByTagName("head")[0].appendChild(styleNode);
		});
		// If we're being viewed on a data: URI then give instructions for how to save
		if(document.location.protocol === "data:") {
			var event = document.createEvent("Event");
			event.initEvent("tw-modal",true,true);
			event.param = "$:/messages/SaveInstructions";
			document.dispatchEvent(event);
		} 
		// Display the PageTemplate
		var templateTitle = "$:/templates/PageTemplate",
			parser = $tw.wiki.parseTiddler(templateTitle),
			renderTree = new $tw.WikiRenderTree(parser,{wiki: $tw.wiki});
		renderTree.execute({tiddlerTitle: templateTitle});
		var container = document.createElement("div");
		document.body.insertBefore(container,document.body.firstChild);
		renderTree.renderInDom(container);
		$tw.wiki.addEventListener("",function(changes) {
			renderTree.refreshInDom(changes);
		});
	} else {
		// On the server, start a commander with the command line arguments
		commander = new $tw.Commander(
			$tw.boot.argv,
			function(err) {
				if(err) {
					console.log("Error: " + err);
				}
			},
			$tw.wiki,
			{output: process.stdout, error: process.stderr}
		);
		commander.execute();
	}

};

})();
});
</script><script data-tiddler-title="$:/core/modules/tiddler.js" data-tiddler-type="application/javascript" data-tiddler-module-type="tiddlermethod" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/tiddler.js","tiddlermethod",function(module,exports,require) {/*\
title: $:/core/modules/tiddler.js
type: application/javascript
module-type: tiddlermethod

Extension methods for the $tw.Tiddler object

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.hasTag = function(tag) {
	return this.fields.tags && this.fields.tags.indexOf(tag) !== -1;
};

exports.isShadow = function() {
	if(!$tw.utils.hop(this,"shadowFlag")) {
		this.shadowFlag = this.fields.title.indexOf("$:/") === 0;
	}
	return this.shadowFlag;
};

exports.isTemporary = function() {
	return this.fields.title.indexOf("$:/temp/") === 0;
};

exports.getFieldString = function(field) {
	var value = this.fields[field];
	// Check for a missing field
	if(value === undefined || value === null) {
		return "";
	}
	// Parse the field with the associated module (if any)
	var fieldModule = $tw.Tiddler.fieldModules[field];
	if(fieldModule) {
		return fieldModule.stringify.call(this,value);
	} else {
		return value.toString();
	}
};

/*
Get all the fields as a name:value block. Options:
	exclude: an array of field names to exclude
*/
exports.getFieldStringBlock = function(options) {
	options = options || {};
	var exclude = options.exclude || [];
	var fields = [];
	for(var field in this.fields) {
		if($tw.utils.hop(this.fields,field)) {
			if(exclude.indexOf(field) === -1) {
				fields.push(field + ": " + this.getFieldString(field));
			}
		}
	}
	return fields.join("\n");
};

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/dom/browser.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/dom/browser.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/dom/browser.js
type: application/javascript
module-type: utils

Browser feature detection

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Set style properties of an element
	element: dom node
	styles: ordered array of {name: value} pairs
*/
exports.setStyle = function(element,styles) {
	for(var t=0; t<styles.length; t++) {
		for(var styleName in styles[t]) {
			element.style[$tw.utils.convertStyleNameToPropertyName(styleName)] = styles[t][styleName];
		}
	}
};

/*
Converts a standard CSS property name into the local browser-specific equivalent. For example:
	"background-color" --> "backgroundColor"
	"transition" --> "webkitTransition"
*/

var styleNameCache = {}; // We'll cache the style name conversions

exports.convertStyleNameToPropertyName = function(styleName) {
	// Return from the cache if we can
	if(styleNameCache[styleName]) {
		return styleNameCache[styleName];
	}
	// Convert it by first removing any hyphens
	var propertyName = $tw.utils.unHyphenateCss(styleName);
	// Then check if it needs a prefix
	if(document.body.style[propertyName] === undefined) {
		var prefixes = ["O","MS","Moz","webkit"];
		for(var t=0; t<prefixes.length; t++) {
			var prefixedName = prefixes[t] + propertyName.substr(0,1).toUpperCase() + propertyName.substr(1);
			if(document.body.style[prefixedName] !== undefined) {
				propertyName = prefixedName;
				break;
			}
		}
	}
	// Put it in the cache too
	styleNameCache[styleName] = propertyName;
	return propertyName;
};

/*
Converts a JS format CSS property name back into the dashed form used in CSS declarations. For example:
	"backgroundColor" --> "background-color"
	"webkitTransform" --> "-webkit-transform"
*/
exports.convertPropertyNameToStyleName = function(propertyName) {
	// Rehyphenate the name
	var styleName = $tw.utils.hyphenateCss(propertyName);
	// If there's a webkit prefix, add a dash (other browsers have uppercase prefixes, and so get the dash automatically)
	if(styleName.indexOf("webkit") === 0) {
		styleName = "-" + styleName;
	} else if(styleName.indexOf("-m-s") === 0) {
		styleName = "-ms" + styleName.substr(4);
	}
	return styleName;
};

/*
Round trip a stylename to a property name and back again. For example:
	"transform" --> "webkitTransform" --> "-webkit-transform"
*/
exports.roundTripPropertyName = function(propertyName) {
	return $tw.utils.convertPropertyNameToStyleName($tw.utils.convertStyleNameToPropertyName(propertyName));
};

/*
Converts a standard event name into the local browser specific equivalent. For example:
	"animationEnd" --> "webkitAnimationEnd"
*/

var eventNameCache = {}; // We'll cache the conversions

var eventNameMappings = {
	"transitionEnd": {
		correspondingCssProperty: "transition",
		mappings: {
			transition: "transitionend",
			OTransition: "oTransitionEnd",
			MSTransition: "msTransitionEnd",
			MozTransition: "transitionend",
			webkitTransition: "webkitTransitionEnd"
		}
	},
	"animationEnd": {
		correspondingCssProperty: "animation",
		mappings: {
			animation: "animationend",
			OAnimation: "oAnimationEnd",
			MSAnimation: "msAnimationEnd",
			MozAnimation: "animationend",
			webkitAnimation: "webkitAnimationEnd"
		}
	}
};

exports.convertEventName = function(eventName) {
	if(eventNameCache[eventName]) {
		return eventNameCache[eventName];
	}
	var newEventName = eventName,
		mappings = eventNameMappings[eventName];
	if(mappings) {
		var convertedProperty = $tw.utils.convertStyleNameToPropertyName(mappings.correspondingCssProperty);
		if(mappings.mappings[convertedProperty]) {
			newEventName = mappings.mappings[convertedProperty];
		}
	}
	// Put it in the cache too
	eventNameCache[eventName] = newEventName;
	return newEventName;
};

// Setup constants for the current browser
exports.getBrowserInfo = function(info) {
	info.requestFullScreen = document.body.webkitRequestFullScreen !== undefined ? "webkitRequestFullScreen" :
							document.body.mozRequestFullScreen !== undefined ? "mozRequestFullScreen" :
							document.body.requestFullScreen !== undefined ? "requestFullScreen" : "";
	info.cancelFullScreen = document.webkitCancelFullScreen !== undefined ? "webkitCancelFullScreen" :
							document.mozCancelFullScreen !== undefined ? "mozCancelFullScreen" :
							document.cancelFullScreen !== undefined ? "cancelFullScreen" : "";
	info.isFullScreen = document.webkitIsFullScreen !== undefined ? "webkitIsFullScreen" :
							document.mozFullScreen !== undefined ? "mozFullScreen" :
							document.fullScreen !== undefined ? "fullScreen" : "";
};

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/dom.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/dom.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/dom.js
type: application/javascript
module-type: utils

Various static DOM-related utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Determines whether element 'a' contains element 'b'
Code thanks to John Resig, http://ejohn.org/blog/comparing-document-position/
*/
exports.domContains = function(a,b) {
	return a.contains ?
		a != b && a.contains(b) :
		!!(a.compareDocumentPosition(b) & 16);
};

exports.removeChildren = function(node) {
	while(node.hasChildNodes()) {
		node.removeChild(node.firstChild);
	}
};

exports.hasClass = function(el,className) {
	return el.className.split(" ").indexOf(className) !== -1;
};

exports.addClass = function(el,className) {
	var c = el.className.split(" ");
	if(c.indexOf(className) === -1) {
		c.push(className);
	}
	el.className = c.join(" ");
};

exports.removeClass = function(el,className) {
	var c = el.className.split(" "),
		p = c.indexOf(className);
	if(p !== -1) {
		c.splice(p,1);
		el.className = c.join(" ");
	}
};

exports.toggleClass = function(el,className,status) {
	if(status === undefined) {
		status = !exports.hasClass(el,className);
	}
	if(status) {
		exports.addClass(el,className);
	} else {
		exports.removeClass(el,className);
	}
};

exports.applyStyleSheet = function(id,css) {
	var el = document.getElementById(id);
	if(document.createStyleSheet) { // Older versions of IE
		if(el) {
			el.parentNode.removeChild(el);
		}
		document.getElementsByTagName("head")[0].insertAdjacentHTML("beforeEnd",
			'&nbsp;<style id="' + id + '" type="text/css">' + css + '</style>'); // fails without &nbsp;
	} else { // Modern browsers
		if(el) {
			el.replaceChild(document.createTextNode(css), el.firstChild);
		} else {
			el = document.createElement("style");
			el.type = "text/css";
			el.id = id;
			el.appendChild(document.createTextNode(css));
			document.getElementsByTagName("head")[0].appendChild(el);
		}
	}
};

/*
Get the scroll position of the viewport
Returns:
	{
		x: horizontal scroll position in pixels,
		y: vertical scroll position in pixels
	}
*/
exports.getScrollPosition = function() {
	if("scrollX" in window) {
		return {x: window.scrollX, y: window.scrollY};
	} else {
		return {x: document.documentElement.scrollLeft, y: document.documentElement.scrollTop};
	}
};

/*
Gets the bounding rectangle of an element in absolute page coordinates
*/
exports.getBoundingPageRect = function(element) {
	var scrollPos = $tw.utils.getScrollPosition(),
		clientRect = element.getBoundingClientRect();
	return {
		left: clientRect.left + scrollPos.x,
		width: clientRect.width,
		right: clientRect.right + scrollPos.x,
		top: clientRect.top + scrollPos.y,
		height: clientRect.height,
		bottom: clientRect.bottom + scrollPos.y
	};
};

/*
Saves a named password in the browser
*/
exports.savePassword = function(name,password) {
	localStorage.setItem("tw5-password-" + name,password);
};

/*
Retrieve a named password from the browser
*/
exports.getPassword = function(name) {
	return localStorage.getItem("tw5-password-" + name);
};

/*
Force layout of a dom node and its descendents
*/
exports.forceLayout = function(element) {
	var dummy = element.offsetWidth;
};

/*
Pulse an element for debugging purposes
*/
exports.pulseElement = function(element) {
	// Event handler to remove the class at the end
	element.addEventListener($tw.browser.animationEnd,function handler(event) {
		element.removeEventListener($tw.browser.animationEnd,handler,false);
		$tw.utils.removeClass(element,"pulse");
	},false);
	// Apply the pulse class
	$tw.utils.removeClass(element,"pulse");
	$tw.utils.forceLayout(element);
	$tw.utils.addClass(element,"pulse");
};

/*
Attach specified event handlers to a DOM node
*/
exports.addEventListeners = function(domNode,events) {
	$tw.utils.each(events,function(eventInfo) {
		var handler;
		if(eventInfo.handlerFunction) {
			handler = eventInfo.handlerFunction;
		} else if(eventInfo.handlerObject) {
			if(eventInfo.handlerMethod) {
				handler = function(event) {
					eventInfo.handlerObject[eventInfo.handlerMethod].call(eventInfo.handlerObject,event);
				};	
			} else {
				handler = eventInfo.handlerObject;
			}
		}
		domNode.addEventListener(eventInfo.name,handler,false);
	});
};

/*
Construct and dispatch a custom event
*/
exports.dispatchCustomEvent = function(target,name,members) {
	var event = document.createEvent("Event");
	event.initEvent(name,true,true);
	$tw.utils.each(members,function(member,name) {
		event[name] = member;
	});
	target.dispatchEvent(event); 
};


})();
});
</script><script data-tiddler-title="$:/core/modules/utils/dom/modal.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/dom/modal.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/dom/modal.js
type: application/javascript
module-type: utils

Modal message mechanism

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var Modal = function(wiki) {
	this.wiki = wiki;
};

/*
Display a modal dialogue
	title: Title of tiddler to display
	options: see below
Options include:
	downloadLink: Text of a big download link to include
*/
Modal.prototype.display = function(title,options) {
	options = options || {};
	// Create the wrapper divs
	var wrapper = document.createElement("div"),
		modalBackdrop = document.createElement("div"),
		modalWrapper = document.createElement("div"),
		modalHeader = document.createElement("div"),
		headerTitle = document.createElement("h3"),
		modalBody = document.createElement("div"),
		modalLink = document.createElement("a"),
		modalFooter = document.createElement("div"),
		modalFooterHelp = document.createElement("span"),
		modalFooterButtons = document.createElement("span"),
		tiddler = this.wiki.getTiddler(title),
		d = $tw.config.preferences.animationDuration + "ms";
	// Don't do anything if the tiddler doesn't exist
	if(!tiddler) {
		return;
	}
	// Add classes
	$tw.utils.addClass(modalBackdrop,"modal-backdrop");
	$tw.utils.addClass(modalWrapper,"modal");
	$tw.utils.addClass(modalHeader,"modal-header");
	$tw.utils.addClass(modalBody,"modal-body");
	$tw.utils.addClass(modalLink,"btn btn-large btn-block btn-success");
	$tw.utils.addClass(modalFooter,"modal-footer");
	// Join them together
	wrapper.appendChild(modalBackdrop);
	wrapper.appendChild(modalWrapper);
	modalHeader.appendChild(headerTitle);
	modalWrapper.appendChild(modalHeader);
	modalWrapper.appendChild(modalBody);
	modalFooter.appendChild(modalFooterHelp);
	modalFooter.appendChild(modalFooterButtons);
	modalWrapper.appendChild(modalFooter);
	// Render the title of the message
	var titleText;
	if(tiddler && tiddler.fields && tiddler.fields.subtitle) {
		titleText = tiddler.fields.subtitle;
	} else {
		titleText = title;
	}
	var headerParser = this.wiki.parseText("text/vnd.tiddlywiki-run",titleText,{parseAsInline: true}),
		headerRenderTree = new $tw.WikiRenderTree(headerParser,{wiki: $tw.wiki});
	headerRenderTree.execute({tiddlerTitle: title});
	headerRenderTree.renderInDom(headerTitle);
	this.wiki.addEventListener("",function(changes) {
		headerRenderTree.refreshInDom(changes);
	});
	// Render the body of the message
	var bodyParser = this.wiki.parseTiddler(title),
		bodyRenderTree = new $tw.WikiRenderTree(bodyParser,{wiki: $tw.wiki});
	bodyRenderTree.execute({tiddlerTitle: title});
	bodyRenderTree.renderInDom(modalBody);
	this.wiki.addEventListener("",function(changes) {
		bodyRenderTree.refreshInDom(changes);
	});
	// Setup the link if present
	if(options.downloadLink) {
		modalLink.href = options.downloadLink
		modalLink.appendChild(document.createTextNode("Right-click to save changes"));
		modalBody.appendChild(modalLink);
	}
	// Render the footer of the message
	if(tiddler && tiddler.fields && tiddler.fields.help) {
		var link = document.createElement("a");
		link.setAttribute("href",tiddler.fields.help);
		link.setAttribute("target","_blank");
		link.appendChild(document.createTextNode("Help"));
		modalFooterHelp.appendChild(link);
		modalFooterHelp.style.float = "left";
	}
	var footerText;
	if(tiddler && tiddler.fields && tiddler.fields.footer) {
		footerText = tiddler.fields.footer;
	} else {
		footerText = '<$button message="tw-close-tiddler" class="btn btn-primary">Close</$button>';
	}
	var footerParser = this.wiki.parseText("text/vnd.tiddlywiki-run",footerText,{parseAsInline: true}),
		footerRenderTree = new $tw.WikiRenderTree(footerParser,{wiki: $tw.wiki});
	footerRenderTree.execute({tiddlerTitle: title});
	footerRenderTree.renderInDom(modalFooterButtons);
	this.wiki.addEventListener("",function(changes) {
		footerRenderTree.refreshInDom(changes);
	});
	// Add the close event handler
	wrapper.addEventListener("tw-close-tiddler",function(event) {
		// Force layout and animate the modal message away
		$tw.utils.forceLayout(modalBackdrop);
		$tw.utils.forceLayout(modalWrapper);
		$tw.utils.setStyle(modalBackdrop,[
			{opacity: "0"}
		]);
		$tw.utils.setStyle(modalWrapper,[
			{transform: "translateY(" + window.innerHeight + "px)"}
		]);
		// Set up an event for the transition end
		modalWrapper.addEventListener($tw.utils.convertEventName("transitionEnd"),function(event) {
			if(wrapper.parentNode) {
				// Remove the modal message from the DOM
				document.body.removeChild(wrapper);
			}
		},false);
		// Don't let anyone else handle the tw-close-tiddler message
		event.stopPropagation();
		return false;
	},false);
	// Set the initial styles for the message
	$tw.utils.setStyle(modalBackdrop,[
		{opacity: "0"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transformOrigin: "0% 0%"},
		{transform: "translateY(" + (-window.innerHeight) + "px)"}
	]);
	// Put the message into the document
	document.body.appendChild(wrapper);
	// Set up animation for the styles
	$tw.utils.setStyle(modalBackdrop,[
		{transition: "opacity " + d + " ease-out"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + $tw.config.preferences.animationDurationMs + " ease-in-out"}
	]);
	// Force layout
	$tw.utils.forceLayout(modalBackdrop);
	$tw.utils.forceLayout(modalWrapper);
	// Set final animated styles
	$tw.utils.setStyle(modalBackdrop,[
		{opacity: "0.7"}
	]);
	$tw.utils.setStyle(modalWrapper,[
		{transform: "translateY(0px)"}
	]);
};

exports.Modal = Modal;

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/dom/popup.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/dom/popup.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/dom/popup.js
type: application/javascript
module-type: utils

Module that creates a $tw.utils.Popup object prototype that manages popups in the browser

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Creates a Popup object with these options:
	rootElement: the DOM element to which the popup zapper should be attached
*/
var Popup = function(options) {
	options = options || {};
	this.rootElement = options.rootElement || document.body;
};

Popup.prototype.show = function(options) {
	this.cancel();
	this.title = options.title;
	this.wiki = options.wiki;
	this.anchorDomNode = options.domNode;
	this.rootElement.addEventListener("click",this,true);
};

Popup.prototype.handleEvent = function(event) {
	if(event.type === "click" && !$tw.utils.domContains(this.anchorDomNode,event.target)) {
		this.cancel();
	}
};

Popup.prototype.cancel = function() {
	this.rootElement.removeEventListener("click",this,true);
	if(this.title) {
		this.wiki.deleteTiddler(this.title);
		this.title = null;
	}
};

/*
Trigger a popup open or closed. Parameters are in a hashmap:
	title: title of the tiddler where the popup details are stored
	domNode: dom node to which the popup will be positioned
	wiki: wiki
*/
Popup.prototype.triggerPopup = function(options) {
	// Get the current popup state tiddler
	var value = options.wiki.getTextReference(options.title,"");
	// Check if the popup is open by checking whether it matches "(<x>,<y>)"
	var popupLocationRegExp = /^\((-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+)\)$/;
	if(popupLocationRegExp.test(value)) {
		this.cancel();
	} else {
		// Set the position if we're opening it
		this.cancel();
		options.wiki.setTextReference(options.title,
			"(" + options.domNode.offsetLeft + "," + options.domNode.offsetTop + "," + 
				options.domNode.offsetWidth + "," + options.domNode.offsetHeight + ")");
		this.show(options);
	}
};

exports.Popup = Popup;

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/dom/scroller.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/dom/scroller.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/dom/scroller.js
type: application/javascript
module-type: utils

Module that creates a $tw.utils.Scroller object prototype that manages scrolling in the browser

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Event handler for when the `tw-scroll` event hits the document body
*/
var PageScroller = function() {
	this.timerId = null;
};

PageScroller.prototype.cancelScroll = function() {
	if(this.timerId) {
		window.clearInterval(this.timerId);
		this.timerId = null;
	}
};

/*
Handle an event
*/
PageScroller.prototype.handleEvent = function(event) {
	if(event.type === "tw-scroll") {
		return this.scrollIntoView(event);
	}
	return true;
};

/*
Handle a scroll event hitting the page document
*/
PageScroller.prototype.scrollIntoView = function(event) {
	// Get the offset bounds of the element
	var domNode = event.target,
		bounds = {
			left: domNode.offsetLeft,
			top: domNode.offsetTop,
			width: domNode.offsetWidth,
			height: domNode.offsetHeight
		};
	// Walk up the tree adjusting the offset bounds by each offsetParent
	while(domNode.offsetParent) {
		domNode = domNode.offsetParent;
		bounds.left += domNode.offsetLeft;
		bounds.top += domNode.offsetTop;
	}
	// Now get ready to scroll the body
	this.cancelScroll();
	this.startTime = new Date();
	var scrollPosition = $tw.utils.getScrollPosition(),
		// We'll consider the horizontal and vertical scroll directions separately via this function
		getEndPos = function(targetPos,targetSize,currentPos,currentSize) {
			// If the target is above/left of the current view, then scroll to it's top/left
			if(targetPos <= currentPos) {
				return targetPos;
			// If the target is smaller than the window and the scroll position is too far up, then scroll till the target is at the bottom of the window
			} else if(targetSize < currentSize && currentPos < (targetPos + targetSize - currentSize)) {
				return targetPos + targetSize - currentSize;
			// If the target is big, then just scroll to the top
			} else if(currentPos < targetPos) {
				return targetPos;
			// Otherwise, stay where we are
			} else {
				return currentPos;
			}
		},
		endX = getEndPos(bounds.left,bounds.width,scrollPosition.x,window.innerWidth),
		endY = getEndPos(bounds.top,bounds.height,scrollPosition.y,window.innerHeight);
	// Only scroll if necessary
	if(endX !== scrollPosition.x || endY !== scrollPosition.y) {
		var self = this;
		this.timerId = window.setInterval(function() {
			var t = ((new Date()) - self.startTime) / $tw.config.preferences.animationDuration;
			if(t >= 1) {
				self.cancelScroll();
				t = 1;
			}
			t = $tw.utils.slowInSlowOut(t);
			window.scrollTo(scrollPosition.x + (endX - scrollPosition.x) * t,scrollPosition.y + (endY - scrollPosition.y) * t);
		}, 10);
	}
};

exports.PageScroller = PageScroller;

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/parsetree.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/parsetree.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/parsetree.js
type: application/javascript
module-type: utils

Parse tree utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.addAttributeToParseTreeNode = function(node,name,value) {
	if(node.type === "element") {
		node.attributes = node.attributes || {};
		node.attributes[name] = {type: "string", value: value};
	}
};

exports.addClassToParseTreeNode = function(node,classString) {
	var classes = [];
	if(node.type === "element") {
		node.attributes = node.attributes || {};
		node.attributes["class"] = node.attributes["class"] || {type: "string", value: ""};
		if(node.attributes["class"].type === "string") {
			if(node.attributes["class"].value !== "") {
				classes = node.attributes["class"].value.split(" ");
			}
			if(classString !== "") {
				$tw.utils.pushTop(classes,classString.split(" "));
			}
			node.attributes["class"].value = classes.join(" ");
		}
	}
};

exports.addStyleToParseTreeNode = function(node,name,value) {
	if(node.type === "element") {
		node.attributes = node.attributes || {};
		node.attributes["style"] = node.attributes["style"] || {type: "string", value: ""};
		if(node.attributes["style"].type === "string") {
			node.attributes["style"].value += name + ":" + value + ";";
		}
	}
};

exports.findParseTreeNode = function(nodeArray,search) {
	for(var t=0; t<nodeArray.length; t++) {
		if(nodeArray[t].type === search.type && nodeArray[t].tag === search.tag) {
			return nodeArray[t];
		}
	}
	return undefined;
};

})();
});
</script><script data-tiddler-title="$:/core/modules/utils/utils.js" data-tiddler-type="application/javascript" data-tiddler-module-type="utils" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/utils/utils.js","utils",function(module,exports,require) {/*\
title: $:/core/modules/utils/utils.js
type: application/javascript
module-type: utils

Various static utility functions.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Trim whitespace from the start and end of a string
Thanks to Steven Levithan, http://blog.stevenlevithan.com/archives/faster-trim-javascript
*/
exports.trim = function(str) {
	if(typeof str === "string") {
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	} else {
		return str;
	}
};

/*
Return the number of keys in an object
*/
exports.count = function(object) {
	var s = 0;
	$tw.utils.each(object,function() {s++;});
	return s;
};

/*
Push entries onto an array, removing them first if they already exist in the array
	array: array to modify
	value: a single value to push or an array of values to push
*/
exports.pushTop = function(array,value) {
	var t,p;
	if($tw.utils.isArray(value)) {
		// Remove any array entries that are duplicated in the new values
		for(t=0; t<value.length; t++) {
			p = array.indexOf(value[t]);
			if(p !== -1) {
				array.splice(p,1);
			}
		}
		// Push the values on top of the main array
		array.push.apply(array,value);
	} else {
		p = array.indexOf(value);
		if(p !== -1) {
			array.splice(p,1);
		}
		array.push(value);
	}
};

/*
Remove entries from an array
	array: array to modify
	value: a single value to remove, or an array of values to remove
*/
exports.removeArrayEntries = function(array,value) {
	var t,p;
	if($tw.utils.isArray(value)) {
		for(t=0; t<value.length; t++) {
			p = array.indexOf(value[t]);
			if(p !== -1) {
				array.splice(p,1);
			}
		}
	} else {
		p = array.indexOf(value);
		if(p !== -1) {
			array.splice(p,1);
		}
	}
};

/*
Check whether any members of a hashmap are present in another hashmap
*/
exports.checkDependencies = function(dependencies,changes) {
	var hit = false;
	$tw.utils.each(changes,function(change,title) {
		if($tw.utils.hop(dependencies,title)) {
			hit = true;
		}
	});
	return hit;
};

exports.extend = function(object /* [, src] */) {
	$tw.utils.each(Array.prototype.slice.call(arguments, 1), function(source) {
		if(source) {
			for(var property in source) {
				object[property] = source[property];
			}
		}
	});
	return object;
};

exports.deepCopy = function(object) {
	var result,t;
	if($tw.utils.isArray(object)) {
		// Copy arrays
		result = object.slice(0);
	} else if(typeof object === "object") {
		result = {};
		for(t in object) {
			if(object[t] !== undefined) {
				result[t] = $tw.utils.deepCopy(object[t]);
			}
		}
	} else {
		result = object;
	}
	return result;
};

exports.extendDeepCopy = function(object,extendedProperties) {
	var result = $tw.utils.deepCopy(object),t;
	for(t in extendedProperties) {
		if(extendedProperties[t] !== undefined) {
			result[t] = $tw.utils.deepCopy(extendedProperties[t]);
		}
	}
	return result;
};

exports.slowInSlowOut = function(t) {
	return (1 - ((Math.cos(t * Math.PI) + 1) / 2));
};

exports.formatDateString = function (date,template) {
	var t = template.replace(/0hh12/g,$tw.utils.pad($tw.utils.getHours12(date)));
	t = t.replace(/hh12/g,$tw.utils.getHours12(date));
	t = t.replace(/0hh/g,$tw.utils.pad(date.getHours()));
	t = t.replace(/hh/g,date.getHours());
	t = t.replace(/mmm/g,$tw.config.dateFormats.shortMonths[date.getMonth()]);
	t = t.replace(/0mm/g,$tw.utils.pad(date.getMinutes()));
	t = t.replace(/mm/g,date.getMinutes());
	t = t.replace(/0ss/g,$tw.utils.pad(date.getSeconds()));
	t = t.replace(/ss/g,date.getSeconds());
	t = t.replace(/[ap]m/g,$tw.utils.getAmPm(date).toLowerCase());
	t = t.replace(/[AP]M/g,$tw.utils.getAmPm(date).toUpperCase());
	t = t.replace(/wYYYY/g,$tw.utils.getYearForWeekNo(date));
	t = t.replace(/wYY/g,$tw.utils.pad($tw.utils.getYearForWeekNo(date)-2000));
	t = t.replace(/YYYY/g,date.getFullYear());
	t = t.replace(/YY/g,$tw.utils.pad(date.getFullYear()-2000));
	t = t.replace(/MMM/g,$tw.config.dateFormats.months[date.getMonth()]);
	t = t.replace(/0MM/g,$tw.utils.pad(date.getMonth()+1));
	t = t.replace(/MM/g,date.getMonth()+1);
	t = t.replace(/0WW/g,$tw.utils.pad($tw.utils.getWeek(date)));
	t = t.replace(/WW/g,$tw.utils.getWeek(date));
	t = t.replace(/DDD/g,$tw.config.dateFormats.days[date.getDay()]);
	t = t.replace(/ddd/g,$tw.config.dateFormats.shortDays[date.getDay()]);
	t = t.replace(/0DD/g,$tw.utils.pad(date.getDate()));
	t = t.replace(/DDth/g,date.getDate()+$tw.utils.getDaySuffix(date));
	t = t.replace(/DD/g,date.getDate());
	var tz = date.getTimezoneOffset();
	var atz = Math.abs(tz);
	t = t.replace(/TZD/g,(tz < 0 ? '+' : '-') + $tw.utils.pad(Math.floor(atz / 60)) + ':' + $tw.utils.pad(atz % 60));
	t = t.replace(/\\/g,"");
	return t;
};

exports.getAmPm = function(date) {
	return date.getHours() >= 12 ? $tw.config.dateFormats.pm : $tw.config.dateFormats.am;
};

exports.getDaySuffix = function(date) {
	return $tw.config.dateFormats.daySuffixes[date.getDate()-1];
};

exports.getWeek = function(date) {
	var dt = new Date(date.getTime());
	var d = dt.getDay();
	if(d === 0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week to calculate weekNo
	var n = Math.floor((dt.getTime()-new Date(dt.getFullYear(),0,1)+3600000)/86400000);
	return Math.floor(n/7)+1;
};

exports.getYearForWeekNo = function(date) {
	var dt = new Date(date.getTime());
	var d = dt.getDay();
	if(d === 0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week
	return dt.getFullYear();
};

exports.getHours12 = function(date) {
	var h = date.getHours();
	return h > 12 ? h-12 : ( h > 0 ? h : 12 );
};

/*
Convert a date delta in milliseconds into a string representation of "23 seconds ago", "27 minutes ago" etc.
	delta: delta in milliseconds
Returns an object with these members:
	description: string describing the delta period
	updatePeriod: time in millisecond until the string will be inaccurate
*/
exports.getRelativeDate = function(delta) {
	var units = [
		{name: "years",   duration:      365 * 24 * 60 * 60 * 1000},
		{name: "months",  duration: (365/12) * 24 * 60 * 60 * 1000},
		{name: "days",    duration:            24 * 60 * 60 * 1000},
		{name: "hours",   duration:                 60 * 60 * 1000},
		{name: "minutes", duration:                      60 * 1000},
		{name: "seconds", duration:                           1000}
	];
	for(var t=0; t<units.length; t++) {
		var result = Math.floor(delta / units[t].duration);
		if(result >= 2) {
			return {
				delta: delta,
				description: result + " " + units[t].name + " ago",
				updatePeriod: units[t].duration
			};
		}
	}
	return {
		delta: delta,
		description: "1 second ago",
		updatePeriod: 1000
	};
};

// Convert & to "&amp;", < to "&lt;", > to "&gt;" and " to "&quot;"
exports.htmlEncode = function(s) {
	if(s) {
		return s.toString().replace(/&/mg,"&amp;").replace(/</mg,"&lt;").replace(/>/mg,"&gt;").replace(/\"/mg,"&quot;");
	} else {
		return "";
	}
};

// Converts all HTML entities to their character equivalents
exports.entityDecode = function(s) {
	var e = s.substr(1,s.length-2); // Strip the & and the ;
	if(e.charAt(0) === "#") {
		if(e.charAt(1) === "x" || e.charAt(1) === "X") {
			return String.fromCharCode(parseInt(e.substr(2),16));	
		} else {
			return String.fromCharCode(parseInt(e.substr(1),10));
		}
	} else {
		var c = $tw.config.htmlEntities[e];
		if(c) {
			return String.fromCharCode(c);
		} else {
			return s; // Couldn't convert it as an entity, just return it raw
		}
	}
};

exports.unescapeLineBreaks = function(s) {
	return s.replace(/\\n/mg,"\n").replace(/\\b/mg," ").replace(/\\s/mg,"\\").replace(/\r/mg,"");
};

/*
 * Returns an escape sequence for given character. Uses \x for characters <=
 * 0xFF to save space, \u for the rest.
 *
 * The code needs to be in sync with th code template in the compilation
 * function for "action" nodes.
 */
// Copied from peg.js, thanks to David Majda
exports.escape = function(ch) {
	var charCode = ch.charCodeAt(0);
	if (charCode <= 0xFF) {
		return '\\x' + $tw.utils.pad(charCode.toString(16).toUpperCase());
	} else {
		return '\\u' + $tw.utils.pad(charCode.toString(16).toUpperCase(),4);
	}
};

// Turns a string into a legal JavaScript string
// Copied from peg.js, thanks to David Majda
exports.stringify = function(s) {
	/*
	* ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
	* literal except for the closing quote character, backslash, carriage return,
	* line separator, paragraph separator, and line feed. Any character may
	* appear in the form of an escape sequence.
	*
	* For portability, we also escape escape all non-ASCII characters.
	*/
	return s
		.replace(/\\/g, '\\\\')            // backslash
		.replace(/"/g, '\\"')              // double quote character
		.replace(/'/g, "\\'")              // single quote character
		.replace(/\r/g, '\\r')             // carriage return
		.replace(/\n/g, '\\n')             // line feed
		.replace(/[\x80-\uFFFF]/g, exports.escape); // non-ASCII characters
};

/*
Escape the RegExp special characters with a preceding backslash
*/
exports.escapeRegExp = function(s) {
    return s.replace(/[\-\/\\\^\$\*\+\?\.\(\)\|\[\]\{\}]/g, '\\$&');
};

exports.nextTick = function(fn) {
/*global window: false */
	if(typeof window !== "undefined") {
		// Apparently it would be faster to use postMessage - http://dbaron.org/log/20100309-faster-timeouts
		window.setTimeout(fn,4);
	} else {
		process.nextTick(fn);
	}
};

/*
Convert a hyphenated CSS property name into a camel case one
*/
exports.unHyphenateCss = function(propName) {
	return propName.replace(/-([a-z])/gi, function(match0,match1) {
		return match1.toUpperCase();
	});
};

/*
Convert a camelcase CSS property name into a dashed one ("backgroundColor" --> "background-color")
*/
exports.hyphenateCss = function(propName) {
	return propName.replace(/([A-Z])/g, function(match0,match1) {
		return "-" + match1.toLowerCase();
	});
};

/*
Parse a text reference of one of these forms:
* title
* !!field
* title!!field
* title##index
* etc
Returns an object with the following fields, all optional:
* title: tiddler title
* field: tiddler field name
* index: JSON property index
*/
exports.parseTextReference = function(textRef) {
	// Separate out the title, field name and/or JSON indices
	var reTextRef = /^\s*([^\s!#]+)?(?:(?:!!([^\s]+))|(?:##([^\s]+)))?\s*/mg,
		match = reTextRef.exec(textRef);
	if(match && reTextRef.lastIndex === textRef.length) {
		// Return the parts
		return {
			title: match[1],
			field: match[2],
			index: match[3]
		};
	} else {
		// If we couldn't parse it (eg it started with a)
		return {
			title: textRef
		};
	}
};

/*
Extract the version number from the meta tag or from the boot file
*/

if($tw.browser) {

// Browser version
exports.extractVersionInfo = function() {
	var metatags = document.getElementsByTagName("meta");
	for(var t=0; t<metatags.length; t++) {
		var m = metatags[t];
		if(m.name === "tiddlywiki-version") {
			return m.content;
		}
	}
	return null;
};

} else {

// Server version
exports.extractVersionInfo = function() {
	return $tw.packageInfo.version;
};

}

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/button.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/button.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/button.js
type: application/javascript
module-type: widget

Implements the button widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ButtonWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

ButtonWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.message = this.renderer.getAttribute("message");
	this.param = this.renderer.getAttribute("param");
	this.set = this.renderer.getAttribute("set");
	this.setTo = this.renderer.getAttribute("setTo");
	this.popup = this.renderer.getAttribute("popup");
	this.hover = this.renderer.getAttribute("hover");
	this.qualifyTiddlerTitles = this.renderer.getAttribute("qualifyTiddlerTitles");
	this["class"] = this.renderer.getAttribute("class");
	// Compose the button
	var classes = ["tw-button"];
	if(this["class"]) {
		$tw.utils.pushTop(classes,this["class"]);
	}
	var events = [{name: "click", handlerObject: this, handlerMethod: "handleClickEvent"}];
	if(this.hover === "yes") {
		events.push({name: "mouseover", handlerObject: this, handlerMethod: "handleMouseOverOrOutEvent"});
		events.push({name: "mouseout", handlerObject: this, handlerMethod: "handleMouseOverOrOutEvent"});
	}
	// Set the return element
	this.tag = "button";
	this.attributes ={"class": classes.join(" ")};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
	this.events = events;
};

ButtonWidget.prototype.dispatchMessage = function(event) {
	$tw.utils.dispatchCustomEvent(event.target,this.message,{
		param: this.param,
		tiddlerTitle: this.renderer.getContextTiddlerTitle()
	});
};

ButtonWidget.prototype.triggerPopup = function(event) {
	var title = this.popup;
	if(this.qualifyTiddlerTitles) {
		title =  title + "-" + this.renderer.getContextScopeId();
	}
	$tw.popup.triggerPopup({
		domNode: this.renderer.domNode,
		title: title,
		wiki: this.renderer.renderTree.wiki
	});
};

ButtonWidget.prototype.setTiddler = function() {
	var tiddler = this.renderer.renderTree.wiki.getTiddler(this.set);
	this.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(tiddler,{title: this.set, text: this.setTo}));
};

ButtonWidget.prototype.handleClickEvent = function(event) {
	if(this.message) {
		this.dispatchMessage(event);
	}
	if(this.popup) {
		this.triggerPopup(event);
	}
	if(this.set && this.setTo) {
		this.setTiddler();
	}
	event.preventDefault();
	return false;
};

ButtonWidget.prototype.handleMouseOverOrOutEvent = function(event) {
	if(this.popup) {
		this.triggerPopup(event);
	}
	event.preventDefault();
	return false;
};

ButtonWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
 	if(changedAttributes.message || changedAttributes.param || changedAttributes.set || changedAttributes.setTo || changedAttributes.popup || changedAttributes.hover || changedAttributes.qualifyTiddlerTitles || changedAttributes["class"] || (this.set && changedTiddlers[this.set]) || (this.popup && changedTiddlers[this.popup])) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// We don't need to refresh ourselves, so just refresh any child nodes
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.button = ButtonWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/checkbox.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/checkbox.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/checkbox.js
type: application/javascript
module-type: widget

Implements the checkbox widget.

```
<$checkbox tag="done"/>

<$checkbox tiddler="HelloThere" tag="red"/>

<$checkbox tag="done">
<$view title/>
</$checkbox>
```

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var CheckboxWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

CheckboxWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.tiddlerTitle = this.renderer.getAttribute("tiddler",this.renderer.getContextTiddlerTitle());
	this.tagName = this.renderer.getAttribute("tag");
	this["class"] = this.renderer.getAttribute("class");
	// Compute classes
	var classes = ["tw-checkbox"];
	if(this["class"]) {
		$tw.utils.pushTop(classes,this["class"]);
	}
	// Create the checkbox and span elements
	var nodeCheckbox = {
			type: "element",
			tag: "input",
			attributes: {
				type: {type: "string", value: "checkbox"}
			}
		},
		nodeSpan = {
			type: "element",
			tag: "span",
			children: this.renderer.parseTreeNode.children
		};
	// Set the state of the checkbox
	if(this.getValue()) {
		$tw.utils.addAttributeToParseTreeNode(nodeCheckbox,"checked","true");
	}
	// Set the return element
	this.tag = "label";
	this.attributes ={"class": classes.join(" ")};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[nodeCheckbox,nodeSpan]);
	this.events = [{name: "change", handlerObject: this, handlerMethod: "handleChangeEvent"}];
};

CheckboxWidget.prototype.getValue = function() {
	var tiddler = this.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle);
	return tiddler ? tiddler.hasTag(this.tagName) : false;
};

CheckboxWidget.prototype.handleChangeEvent  = function(event) {
	var checked = this.children[0].domNode.checked,
		tiddler = this.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle);
	if(tiddler && tiddler.hasTag(this.tagName) !== checked) {
		var newTags = tiddler.fields.tags.slice(0),
			pos = newTags.indexOf(this.tagName);
		if(pos !== -1) {
			newTags.splice(pos,1);
		}
		if(checked) {
			newTags.push(this.tagName);
		}
		this.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(tiddler,{tags: newTags}));
	}
};

CheckboxWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
	if(changedAttributes.tiddler || changedAttributes.tag || changedAttributes["class"]) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// Update the checkbox if necessary
		if(changedTiddlers[this.tiddlerTitle]) {
			this.children[0].domNode.checked = this.getValue();
		}
		// Refresh children
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.checkbox = CheckboxWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/edit/edit.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/edit/edit.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/edit/edit.js
type: application/javascript
module-type: widget

The edit widget uses editor plugins to edit tiddlers of different types.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var EditWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Initialise the editors if they've not been done already
	if(!this.editors) {
		EditWidget.prototype.editors = {};
		$tw.modules.applyMethods("editor",this.editors);
	}
	// Generate child nodes
	this.generate();
};

EditWidget.prototype.generate = function() {
	// Get parameters from our attributes
	this.tiddlerTitle = this.renderer.getAttribute("tiddler",this.renderer.getContextTiddlerTitle());
	this.fieldName = this.renderer.getAttribute("field","text");
	// Choose the editor to use
	// TODO: Tiddler field modules should be able to specify a field type from which the editor is derived
	var tiddler = this.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle),
		Editor;
	if(this.fieldName === "text" && tiddler && tiddler.fields.type) {
		Editor = this.editors[tiddler.fields.type];
	}
	if(!Editor) {
		Editor = this.editors["text/vnd.tiddlywiki"];
	}
	// Instantiate the editor
	this.editor = new Editor(this,this.tiddlerTitle,this.fieldName);
	// Ask the editor to create the widget element
	this.editor.render();
};

EditWidget.prototype.postRenderInDom = function() {
	if(this.editor && this.editor.postRenderInDom) {
		this.editor.postRenderInDom();
	}
};

EditWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// We'll completely regenerate ourselves if any of our attributes have changed
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.format) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else if(this.tiddlerTitle && changedTiddlers[this.tiddlerTitle]) {
		// Refresh the editor if our tiddler has changed
		if(this.editor && this.editor.refreshInDom) {
			this.editor.refreshInDom(changedTiddlers);
		}
	} else {
		// Otherwise, just refresh any child nodes
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.edit = EditWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/edit/editors/bitmapeditor.js" data-tiddler-type="application/javascript" data-tiddler-module-type="editor" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/edit/editors/bitmapeditor.js","editor",function(module,exports,require) {/*\
title: $:/core/modules/widgets/edit/editors/bitmapeditor.js
type: application/javascript
module-type: editor

A bitmap editor

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var BitmapEditor = function(editWidget,tiddlerTitle,fieldName) {
	this.editWidget = editWidget;
	this.tiddlerTitle = tiddlerTitle;
	this.fieldName = fieldName;
};

BitmapEditor.prototype.render = function() {
	// Set the element details
	this.editWidget.tag = "canvas";
	this.editWidget.attributes = {
		"class": "tw-edit-bitmapeditor"
	};
	this.editWidget.events = [
		{name: "touchstart", handlerObject: this, handlerMethod: "handleTouchStartEvent"},
		{name: "touchmove", handlerObject: this, handlerMethod: "handleTouchMoveEvent"},
		{name: "touchend", handlerObject: this, handlerMethod: "handleTouchEndEvent"},
		{name: "mousedown", handlerObject: this, handlerMethod: "handleMouseDownEvent"},
		{name: "mousemove", handlerObject: this, handlerMethod: "handleMouseMoveEvent"},
		{name: "mouseup", handlerObject: this, handlerMethod: "handleMouseUpEvent"}
	];
};

BitmapEditor.prototype.postRenderInDom = function() {
	var tiddler = this.editWidget.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle),
		canvas = this.editWidget.renderer.domNode,
		currImage = new Image();
	// Get the current bitmap into an image object
	currImage.src = "data:" + tiddler.fields.type + ";base64," + tiddler.fields.text;
	// Wait until the image is loaded
	var self = this;
	currImage.onload = function() {
		// Copy the image to the on-screen canvas
		canvas.width = currImage.width;
		canvas.height = currImage.height;
		var ctx = canvas.getContext("2d");
		ctx.drawImage(currImage,0,0);
		// And also copy the current bitmap to the off-screen canvas
		self.currCanvas = document.createElement("canvas");
		self.currCanvas.width = currImage.width;
		self.currCanvas.height = currImage.height;
		ctx = self.currCanvas.getContext("2d");
		ctx.drawImage(currImage,0,0);
	};
};

BitmapEditor.prototype.handleTouchStartEvent = function(event) {
	this.brushDown = true;
	this.strokeStart(event.touches[0].clientX,event.touches[0].clientY);
	event.preventDefault();
	event.stopPropagation();
	return false;
};

BitmapEditor.prototype.handleTouchMoveEvent = function(event) {
	if(this.brushDown) {
		this.strokeMove(event.touches[0].clientX,event.touches[0].clientY);
	}
	event.preventDefault();
	event.stopPropagation();
	return false;
};

BitmapEditor.prototype.handleTouchEndEvent = function(event) {
	if(this.brushDown) {
		this.brushDown = false;
		this.strokeEnd();
	}
	event.preventDefault();
	event.stopPropagation();
	return false;
};

BitmapEditor.prototype.handleMouseDownEvent = function(event) {
	this.strokeStart(event.clientX,event.clientY);
	this.brushDown = true;
	event.preventDefault();
	event.stopPropagation();
	return false;
};

BitmapEditor.prototype.handleMouseMoveEvent = function(event) {
	if(this.brushDown) {
		this.strokeMove(event.clientX,event.clientY);
		event.preventDefault();
		event.stopPropagation();
		return false;
	}
	return true;
};

BitmapEditor.prototype.handleMouseUpEvent = function(event) {
	if(this.brushDown) {
		this.brushDown = false;
		this.strokeEnd();
		event.preventDefault();
		event.stopPropagation();
		return false;
	}
	return true;
};

BitmapEditor.prototype.adjustCoordinates = function(x,y) {
	var canvas = this.editWidget.renderer.domNode,
		canvasRect = canvas.getBoundingClientRect(),
		scale = canvas.width/canvasRect.width;
	return {x: (x - canvasRect.left) * scale, y: (y - canvasRect.top) * scale};
};

BitmapEditor.prototype.strokeStart = function(x,y) {
	// Start off a new stroke
	this.stroke = [this.adjustCoordinates(x,y)];
};

BitmapEditor.prototype.strokeMove = function(x,y) {
	var canvas = this.editWidget.renderer.domNode,
		ctx = canvas.getContext("2d"),
		t;
	// Add the new position to the end of the stroke
	this.stroke.push(this.adjustCoordinates(x,y));
	// Redraw the previous image
	ctx.drawImage(this.currCanvas,0,0);
	// Render the stroke
	ctx.lineWidth = 3;
	ctx.lineCap = "round";
	ctx.lineJoin = "round";
	ctx.beginPath();
	ctx.moveTo(this.stroke[0].x,this.stroke[0].y);
	for(t=1; t<this.stroke.length-1; t++) {
		var s1 = this.stroke[t],
			s2 = this.stroke[t-1],
			tx = (s1.x + s2.x)/2,
			ty = (s1.y + s2.y)/2;
		ctx.quadraticCurveTo(s2.x,s2.y,tx,ty);
	}
	ctx.stroke();
};

BitmapEditor.prototype.strokeEnd = function() {
	// Copy the bitmap to the off-screen canvas
	var canvas = this.editWidget.renderer.domNode,
		ctx = this.currCanvas.getContext("2d");
	ctx.drawImage(canvas,0,0);
	// Save the image into the tiddler
	this.saveChanges();
};

BitmapEditor.prototype.saveChanges = function() {
	var tiddler = this.editWidget.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle);
	if(tiddler) {
		// data URIs look like "data:<type>;base64,<text>"
		var dataURL = this.editWidget.renderer.domNode.toDataURL(tiddler.fields.type,1.0),
			posColon = dataURL.indexOf(":"),
			posSemiColon = dataURL.indexOf(";"),
			posComma = dataURL.indexOf(","),
			type = dataURL.substring(posColon+1,posSemiColon),
			text = dataURL.substring(posComma+1);
		var update = {type: type, text: text};
		this.editWidget.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(tiddler,update));
	}
};

/*
Note that the bitmap editor intentionally doesn't have a refreshInDom method to avoid the situation where a bitmap being editted is modified externally
*/

exports["image/jpg"] = BitmapEditor;
exports["image/jpeg"] = BitmapEditor;
exports["image/png"] = BitmapEditor;
exports["image/gif"] = BitmapEditor;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/edit/editors/texteditor.js" data-tiddler-type="application/javascript" data-tiddler-module-type="editor" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/edit/editors/texteditor.js","editor",function(module,exports,require) {/*\
title: $:/core/modules/widgets/edit/editors/texteditor.js
type: application/javascript
module-type: editor

A plain text editor

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var MIN_TEXT_AREA_HEIGHT = 100;

var TextEditor = function(editWidget,tiddlerTitle,fieldName) {
	this.editWidget = editWidget;
	this.tiddlerTitle = tiddlerTitle;
	this.fieldName = fieldName;
};

/*
Get the tiddler being edited and current value
*/
TextEditor.prototype.getEditInfo = function() {
	// Get the current tiddler and the field name
	var tiddler = this.editWidget.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle),
		value;
	// If we've got a tiddler, the value to display is the field string value
	if(tiddler) {
		value = tiddler.getFieldString(this.fieldName);
	} else {
		// Otherwise, we need to construct a default value for the editor
		switch(this.fieldName) {
			case "text":
				value = "Type the text for the tiddler '" + this.tiddlerTitle + "'";
				break;
			case "title":
				value = this.tiddlerTitle;
				break;
			default:
				value = "";
				break;
		}
		value = this.editWidget.renderer.getAttribute("default",value);
	}
	return {tiddler: tiddler, value: value};
};

TextEditor.prototype.render = function() {
	// Get the initial value of the editor
	var editInfo = this.getEditInfo();
	// Create the editor nodes
	var node = {
		type: "element",
		attributes: {}
	};
	var type = this.editWidget.renderer.getAttribute("type",this.fieldName === "text" ? "textarea" : "input");
	switch(type) {
		case "textarea":
			node.tag = "textarea";
			node.children = [{
				type: "text",
				text: editInfo.value
			}];
			break;
		case "search":
			node.tag = "input";
			node.attributes.type = {type: "string", value: "search"};
			node.attributes.value = {type: "string", value: editInfo.value};
			break;
		default: // "input"
			node.tag = "input";
			node.attributes.type = {type: "string", value: "text"};
			node.attributes.value = {type: "string", value: editInfo.value};
			break;
	}
	// Set the element details
	this.editWidget.tag = this.editWidget.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.editWidget.attributes = {
		"class": "tw-edit-texteditor"
	};
	this.editWidget.children = this.editWidget.renderer.renderTree.createRenderers(this.editWidget.renderer.renderContext,[node]);
	this.editWidget.events = [
		{name: "focus", handlerObject: this},
		{name: "blur", handlerObject: this},
		{name: "keyup", handlerObject: this}
	];
};

TextEditor.prototype.handleEvent = function(event) {
	// Get the value of the field if it might have changed
	if(["keyup","focus","blur"].indexOf(event.type) !== -1) {
		this.saveChanges();
	}
	// Fix the height of the textarea if required
	if(["keyup","focus"].indexOf(event.type) !== -1) {
		this.fixHeight();
	}
	return true;
};

TextEditor.prototype.saveChanges = function() {
	var text = this.editWidget.children[0].domNode.value,
		tiddler = this.editWidget.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle);
	if(!tiddler) {
		tiddler = new $tw.Tiddler({title: this.tiddlerTitle});
	}
	if(text !== tiddler.fields[this.fieldName]) {
		var update = {};
		update[this.fieldName] = text;
		this.editWidget.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(tiddler,update));
	}
};

TextEditor.prototype.fixHeight = function() {
	var self = this;
	if(this.editWidget.children[0].domNode && this.editWidget.children[0].domNode.type === "textarea") {
		$tw.utils.nextTick(function() {
			// Resize the textarea to fit its content
			var textarea = self.editWidget.children[0].domNode,
				scrollTop = document.body.scrollTop;
			textarea.style.height = "auto";
			var newHeight = Math.max(textarea.scrollHeight + textarea.offsetHeight - textarea.clientHeight,MIN_TEXT_AREA_HEIGHT);
			if(newHeight !== textarea.offsetHeight) {
				textarea.style.height =  newHeight + "px";
				document.body.scrollTop = scrollTop;
			}
		});
	}
};

TextEditor.prototype.postRenderInDom = function() {
	this.fixHeight();
};

TextEditor.prototype.refreshInDom = function() {
	if(document.activeElement !== this.editWidget.children[0].domNode) {
		var editInfo = this.getEditInfo();
		this.editWidget.children[0].domNode.value = editInfo.value;
	}
	// Fix the height if needed
	this.fixHeight();
};

exports["text/vnd.tiddlywiki"] = TextEditor;
exports["text/plain"] = TextEditor;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/encrypt.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/encrypt.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/encrypt.js
type: application/javascript
module-type: widget

Implements the encrypt widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var EncryptWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

EncryptWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.filter = this.renderer.getAttribute("filter");
	// Check whether we've got an encryption password
	var isEncrypted = $tw.crypto.hasPassword();
	// Encrypt the filtered tiddlers
	var tiddlers = this.renderer.renderTree.wiki.filterTiddlers(this.filter),
		json = {},
		self = this;
	$tw.utils.each(tiddlers,function(title) {
		var tiddler = self.renderer.renderTree.wiki.getTiddler(title),
			jsonTiddler = {};
		for(var f in tiddler.fields) {
			jsonTiddler[f] = tiddler.getFieldString(f);
		}
		json[title] = jsonTiddler;
	});
	var encryptedText = $tw.utils.htmlEncode($tw.crypto.encrypt(JSON.stringify(json)));
	// Set the return element
	this.tag = "pre";
	this.attributes ={"class": "tw-encrypt"};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[{
		type: "text",
		text: encryptedText
	}]);
};

exports.encrypt = EncryptWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/error.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/error.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/error.js
type: application/javascript
module-type: widget

The error widget displays an error message.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ErrorWidget = function(renderer,errorMessage) {
	// Save state
	this.renderer = renderer;
	this.errorMessage = errorMessage;
	// Generate child nodes
	this.generate();
};

ErrorWidget.prototype.generate = function() {
	// Set the element details
	this.tag = "span";
	this.attributes = {
		"class": "tw-error-widget"
	};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[{
			type: "text",
			text: this.errorMessage
		}]);
};

exports.error = ErrorWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/fields.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/fields.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/fields.js
type: application/javascript
module-type: widget

The view widget displays the fields of a tiddler through a text substitution template.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var FieldsWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

FieldsWidget.prototype.generate = function() {
	// Get parameters from our attributes
	this.tiddlerTitle = this.renderer.getAttribute("tiddler",this.renderer.getContextTiddlerTitle());
	this.template = this.renderer.getAttribute("template");
	this.exclude = this.renderer.getAttribute("exclude");
	this.stripTitlePrefix = this.renderer.getAttribute("stripTitlePrefix","no") === "yes";
	// Get the tiddler we're displaying
	var tiddler = this.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle);
	// Get the exclusion list
	var exclude;
	if(this.exclude) {
		exclude = this.exclude.split(" ");
	} else {
		exclude = ["text"]; 
	}
	// Compose the template
	var text = [];
	if(this.template && tiddler) {
		for(var fieldName in tiddler.fields) {
			if(exclude.indexOf(fieldName) === -1) {
				var row = this.template,
					value = tiddler.getFieldString(fieldName);
				if(this.stripTitlePrefix && fieldName === "title") {
					var reStrip = /^\{[^\}]+\}(.+)/mg,
						reMatch = reStrip.exec(value);
					if(reMatch) {
						value = reMatch[1];
					}
				}
				row = row.replace("$name$",fieldName);
				row = row.replace("$value$",value);
				row = row.replace("$encoded_value$",$tw.utils.htmlEncode(value));
				text.push(row)
			}
		}
	}
	// Set the element
	this.tag = "pre";
	this.attributes = {
		"class": "tw-fields"
	};
	// Set up the attributes for the wrapper element
	var classes = [];
	if(this.renderer.hasAttribute("class")) {
		$tw.utils.pushTop(classes,this.renderer.getAttribute("class").split(" "));
	}
	if(classes.length > 0) {
		this.attributes["class"] = classes.join(" ");
	}
	if(this.renderer.hasAttribute("style")) {
		this.attributes.style = this.renderer.getAttribute("style");
	}
	if(this.renderer.hasAttribute("tooltip")) {
		this.attributes.title = this.renderer.getAttribute("tooltip");
	}
	// Create the renderers for the wrapper and the children
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[{
		type: "text",
		text: text.join("")
	}]);
};

exports.fields = FieldsWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/info.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/info.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/info.js
type: application/javascript
module-type: widget

Implements the info widget that displays various information about a specified tiddler.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var InfoWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

InfoWidget.types = {
	changecount: function(options) {return options.wiki.getChangeCount(options.title);}
};

InfoWidget.prototype.generate = function() {
	// Get attributes
	this.tiddlerTitle = this.renderer.getAttribute("tiddler",this.renderer.getContextTiddlerTitle());
	this.type = this.renderer.getAttribute("type","changecount");
	// Get the appropriate value for the current tiddler
	var value = "",
		fn = InfoWidget.types[this.type];
	if(fn) {
		value = fn({
			wiki: this.renderer.renderTree.wiki,
			title: this.tiddlerTitle
		});
	}
	// Set the element
	this.tag = "span";
	this.attributes = {};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[{
		type: "text",
		text: value
	}]);
};

exports.info = InfoWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/link.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/link.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/link.js
type: application/javascript
module-type: widget

Implements the link widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var isLinkExternal = function(to) {
	var externalRegExp = /(?:file|http|https|mailto|ftp|irc|news|data):[^\s'"]+(?:\/|\b)/i;
	return externalRegExp.test(to);
};

var LinkWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

LinkWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.to = this.renderer.getAttribute("to");
	this.hover = this.renderer.getAttribute("hover");
	this.qualifyHoverTitles = this.renderer.getAttribute("qualifyHoverTitles");
	// Qualify the hover tiddler title if needed
	if(this.qualifyHoverTitles) {
		this.hover =  this.hover + "-" + this.renderer.getContextScopeId();
	}
	// Determine the default link characteristics
	this.isExternal = isLinkExternal(this.to);
	if(!this.isExternal) {
		this.isMissing = !this.renderer.renderTree.wiki.tiddlerExists(this.to);
	}
	// Compose the link
	var classes = ["tw-tiddlylink"]
	if(this.isExternal) {
		$tw.utils.pushTop(classes,"tw-tiddlylink-external");
	} else {
		$tw.utils.pushTop(classes,"tw-tiddlylink-internal");
		if(this.isMissing) {
			$tw.utils.pushTop(classes,"tw-tiddlylink-missing");
		} else {
			$tw.utils.pushTop(classes,"tw-tiddlylink-resolves");
		}
	}
	var events = [{name: "click", handlerObject: this, handlerMethod: "handleClickEvent"}];
	if(this.hover) {
		events.push({name: "mouseover", handlerObject: this, handlerMethod: "handleMouseOverOrOutEvent"});
		events.push({name: "mouseout", handlerObject: this, handlerMethod: "handleMouseOverOrOutEvent"});
	}
	// Get the value of the tw-wikilinks configuration macro
	var wikiLinksMacro = this.renderer.findMacroDefinition("tw-wikilinks"),
		useWikiLinks = wikiLinksMacro ? !(wikiLinksMacro.text.trim() === "no") : true;
	// Set up the element
	if(useWikiLinks) {
		this.tag = "a";
		this.attributes = {
			"class": classes.join(" ")
		};
		if(this.isExternal) {
			this.attributes.href = this.to;
		} else {
			var wikiLinkTemplateMacro = this.renderer.findMacroDefinition("tw-wikilink-template"),
				wikiLinkTemplate = wikiLinkTemplateMacro ? wikiLinkTemplateMacro.text.trim() : "$uri_encoded$",
				wikiLinkText = wikiLinkTemplate.replace("$uri_encoded$",encodeURIComponent(this.to));
			this.attributes.href = wikiLinkText;
		}
	} else {
		this.tag = "span";
	}
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
	this.events = events;
};

LinkWidget.prototype.handleClickEvent = function(event) {
	if(isLinkExternal(this.to)) {
		event.target.setAttribute("target","_blank");
		return true;
	} else {
		$tw.utils.dispatchCustomEvent(event.target,"tw-navigate",{
			navigateTo: this.to,
			navigateFromNode: this,
			navigateFromClientRect: this.renderer.domNode.getBoundingClientRect()
		});
		event.preventDefault();
		return false;
	}
};

LinkWidget.prototype.handleMouseOverOrOutEvent = function(event) {
	if(this.hover) {
		$tw.popup.triggerPopup({
			title: this.hover,
			domNode: this.renderer.domNode,
			wiki: this.renderer.renderTree.wiki
		});
	}
	event.preventDefault();
	return false;
};

LinkWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Set the class for missing tiddlers
	if(this.targetTitle && changedTiddlers[this.targetTitle]) {
		$tw.utils.toggleClass(this.renderer.domNode,"tw-tiddler-missing",!this.renderer.renderTree.wiki.tiddlerExists(this.targetTitle));
	}
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
	if(changedAttributes.to || changedAttributes.hover || (this.to && changedTiddlers[this.to]) || (this.hover && changedTiddlers[this.hover])) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// We don't need to refresh ourselves, so just refresh any child nodes
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.link = LinkWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/list/list.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/list/list.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/list/list.js
type: application/javascript
module-type: widget

The list widget

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ListWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Initialise the listviews if they've not been done already
	if(!this.listViews) {
		ListWidget.prototype.listViews = {};
		$tw.modules.applyMethods("listview",this.listViews);
	}
	// Generate widget elements
	this.generate();
};

/*
These types are shorthands for particular filters
*/
var typeMappings = {
	all: "[!is[shadow]sort[title]]",
	recent: "[!is[shadow]sort[modified]]",
	missing: "[is[missing]sort[title]]",
	orphans: "[is[orphan]sort[title]]",
	shadows: "[is[shadow]sort[title]]"
};

ListWidget.prototype.generate = function() {
	// Get our attributes
	this.itemClass = this.renderer.getAttribute("itemClass");
	this.template = this.renderer.getAttribute("template");
	this.editTemplate = this.renderer.getAttribute("editTemplate");
	this.emptyMessage = this.renderer.getAttribute("emptyMessage");
	// Get the list of tiddlers object
	this.getTiddlerList();
	// Create the list
	var listMembers = [];
	if(this.list.length === 0) {
		// Check for an empty list
		listMembers = [this.getEmptyMessage()];
	} else {
		// Create the list
		for(var t=0; t<this.list.length; t++) {
			listMembers.push(this.createListElement(this.list[t]));
		}		
	}
	// Create the list frame element
	this.tag = this.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.attributes = {
		"class": "tw-list-frame"
	};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,listMembers);
};

ListWidget.prototype.getTiddlerList = function() {
	var filter;
	if(this.renderer.hasAttribute("type")) {
		filter = typeMappings[this.renderer.getAttribute("type")];
	} else if(this.renderer.hasAttribute("filter")) {
		filter = this.renderer.getAttribute("filter");
	}
	if(!filter) {
		filter = "[!is[shadow]]";
	}
	this.list = this.renderer.renderTree.wiki.filterTiddlers(filter,this.renderer.getContextTiddlerTitle());
};

/*
Create and execute the nodes representing the empty message
*/
ListWidget.prototype.getEmptyMessage = function() {
	return {
		type: "element",
		tag: "span",
		children: this.renderer.renderTree.wiki.parseText("text/vnd.tiddlywiki",this.emptyMessage).tree
	};
};

/*
Create a list element representing a given tiddler
*/
ListWidget.prototype.createListElement = function(title) {
	// Define an event handler that adds navigation information to the event
	var handleEvent = function(event) {
			event.navigateFromTitle = title;
			return true;
		},
		classes = ["tw-list-element"];
	// Add any specified classes
	if(this.itemClass) {
		$tw.utils.pushTop(classes,this.itemClass);
	}
	// Return the list element
	return {
		type: "element",
		tag: this.renderer.parseTreeNode.isBlock ? "div" : "span",
		attributes: {
			"class": {type: "string", value: classes.join(" ")}
		},
		children: [this.createListElementMacro(title)],
		events: [
			{name: "tw-navigate", handlerFunction: handleEvent},
			{name: "tw-edit-tiddler", handlerFunction: handleEvent},
			{name: "tw-save-tiddler", handlerFunction: handleEvent},
			{name: "tw-close-tiddler", handlerFunction: handleEvent},
			{name: "tw-new-tiddler", handlerFunction: handleEvent}
		]
	};
};

/*
Create the tiddler macro needed to represent a given tiddler
*/
ListWidget.prototype.createListElementMacro = function(title) {
	// Check if the tiddler is a draft
	var tiddler = this.renderer.renderTree.wiki.getTiddler(title),
		isDraft = tiddler ? tiddler.hasField("draft.of") : false;
	// Figure out the template to use
	var template = this.template,
		templateTree = undefined;
	if(isDraft && this.editTemplate) {
		template = this.editTemplate;
	}
	// Check for not having a template
	if(!template) {
		if(this.renderer.parseTreeNode.children && this.renderer.parseTreeNode.children.length > 0) {
			// Use our content as the template
			templateTree = this.renderer.parseTreeNode.children;
		} else {
			// Use default content
			templateTree = [{
				type: "element",
				tag: "$view",
				attributes: {
					field: {type: "string", value: "title"},
					format: {type: "string", value: "link"}
				}
			}];
		}
	}
	// Create the transclude widget
	return {
		type: "element",
		tag: "$transclude",
		attributes: {
			target: {type: "string", value: title},
			template: {type: "string", value: template}
		},
		children: templateTree
	};
};

/*
Remove a list element from the list, along with the attendant DOM nodes
*/
ListWidget.prototype.removeListElement = function(index) {
	// Get the list element
	var listElement = this.children[index];
	// Invoke the listview to animate the removal
	if(this.listview && this.listview.remove) {
		if(!this.listview.remove(index)) {
			// Only delete the DOM element if the listview.remove() returned false
			listElement.domNode.parentNode.removeChild(listElement.domNode);
		}
	} else {
		// Always remove the DOM node if we didn't invoke the listview
		listElement.domNode.parentNode.removeChild(listElement.domNode);
	}
	// Then delete the actual renderer node
	this.children.splice(index,1);
};

/*
Return the index of the list element that corresponds to a particular title
startIndex: index to start search (use zero to search from the top)
title: tiddler title to seach for
*/
ListWidget.prototype.findListElementByTitle = function(startIndex,title) {
	while(startIndex < this.children.length) {
		if(this.children[startIndex].widget.children[0].attributes.target === title) {
			return startIndex;
		}
		startIndex++;
	}
	return undefined;
};

ListWidget.prototype.postRenderInDom = function() {
	this.listview = this.chooseListView();
	this.history = [];
};

/*
Select the appropriate list viewer
*/
ListWidget.prototype.chooseListView = function() {
	// Instantiate the list view
	var listviewName = this.renderer.getAttribute("listview");
	var ListView = this.listViews[listviewName];
	return ListView ? new ListView(this) : null;
};

ListWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Reexecute the widget if any of our attributes have changed
	if(changedAttributes.itemClass || changedAttributes.template || changedAttributes.editTemplate || changedAttributes.emptyMessage || changedAttributes.type || changedAttributes.filter || changedAttributes.template || changedAttributes.history || changedAttributes.listview) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// Handle any changes to the list, and refresh any nodes we're reusing
		this.handleListChanges(changedTiddlers);
		// Update the history list
		var history = this.renderer.getAttribute("history");
		if(history && changedTiddlers[history]) {
			this.handleHistoryChanges();
		}
	}
};

ListWidget.prototype.handleListChanges = function(changedTiddlers) {
	var t,
		prevListLength = this.list.length,
		self = this;
	// Get the list of tiddlers, having saved the previous length
	this.getTiddlerList();
	// Check if the list is empty
	if(this.list.length === 0) {
		// Check if it was empty before
		if(prevListLength === 0) {
			// If so, just refresh the empty message
			$tw.utils.each(this.children,function(node) {
				if(node.refreshInDom) {
					node.refreshInDom(changedTiddlers);
				}
			});
			return;
		} else {
			// If the list wasn't empty before, empty it
			for(t=prevListLength-1; t>=0; t--) {
				this.removeListElement(t);
			}
			// Insert the empty message
			this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[this.getEmptyMessage()]);
			$tw.utils.each(this.children,function(node) {
				if(node.renderInDom) {
					self.renderer.domNode.appendChild(node.renderInDom());
				}
			});
			return;
		}
	} else {
		// If it is not empty now, but was empty previously, then remove the empty message
		if(prevListLength === 0) {
			this.removeListElement(0);
		}
	}
	// Step through the list and adjust our child list elements appropriately
	for(t=0; t<this.list.length; t++) {
		// Check to see if the list element is already there
		var index = this.findListElementByTitle(t,this.list[t]);
		if(index === undefined) {
			// The list element isn't there, so we need to insert it
			this.children.splice(t,0,this.renderer.renderTree.createRenderer(this.renderer.renderContext,this.createListElement(this.list[t])));
			this.renderer.domNode.insertBefore(this.children[t].renderInDom(),this.renderer.domNode.childNodes[t]);
			// Ask the listview to animate the insertion
			if(this.listview && this.listview.insert) {
				this.listview.insert(t);
			}
		} else {
			// Delete any list elements preceding the one we want
			for(var n=index-1; n>=t; n--) {
				this.removeListElement(n);
			}
			// Refresh the node we're reusing
			this.children[t].refreshInDom(changedTiddlers);
		}
	}
	// Remove any left over elements
	for(t=this.children.length-1; t>=this.list.length; t--) {
		this.removeListElement(t);
	}
};

/*
Handle any changes to the history list
*/
ListWidget.prototype.handleHistoryChanges = function() {
	// Get the history data
	var historyAtt = this.renderer.getAttribute("history"),
		newHistory = this.renderer.renderTree.wiki.getTiddlerData(historyAtt,[]);
	// Ignore any entries of the history that match the previous history
	var entry = 0;
	while(entry < newHistory.length && entry < this.history.length && newHistory[entry].title === this.history[entry].title) {
		entry++;
	}
	// Navigate forwards to each of the new tiddlers
	while(entry < newHistory.length) {
		if(this.listview && this.listview.navigateTo) {
			this.listview.navigateTo(newHistory[entry]);
		}
		entry++;
	}
	// Update the history
	this.history = newHistory;
};

exports.list = ListWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/list/listviews/classic.js" data-tiddler-type="application/javascript" data-tiddler-module-type="listview" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/list/listviews/classic.js","listview",function(module,exports,require) {/*\
title: $:/core/modules/widgets/list/listviews/classic.js
type: application/javascript
module-type: listview

Views the list as a linear sequence

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ClassicListView = function(listWidget) {
	this.listWidget = listWidget;
}

ClassicListView.prototype.navigateTo = function(historyInfo) {
	var listElementIndex = this.listWidget.findListElementByTitle(0,historyInfo.title),
		listElementNode = this.listWidget.children[listElementIndex],
		targetElement = listElementNode.domNode;
	// Scroll the node into view
	var scrollEvent = document.createEvent("Event");
	scrollEvent.initEvent("tw-scroll",true,true);
	targetElement.dispatchEvent(scrollEvent);
};

ClassicListView.prototype.insert = function(index) {
	var listElementNode = this.listWidget.children[index],
		targetElement = listElementNode.domNode;
	// Get the current height of the tiddler
	var currMarginBottom = parseInt(window.getComputedStyle(targetElement).marginBottom,10),
		currMarginTop = parseInt(window.getComputedStyle(targetElement).marginTop,10),
		currHeight = targetElement.offsetHeight + currMarginTop;
	// Reset the margin once the transition is over
	var transitionEventName = $tw.utils.convertEventName("transitionEnd");
	targetElement.addEventListener(transitionEventName,function handler(event) {
		$tw.utils.setStyle(targetElement,[
			{transition: "none"},
			{marginBottom: ""}
		]);
		targetElement.removeEventListener(transitionEventName,handler,false);
	},false);
	// Set up the initial position of the element
	$tw.utils.setStyle(targetElement,[
		{transition: "none"},
		{marginBottom: (-currHeight) + "px"},
		{opacity: "0.0"}
	]);
	$tw.utils.forceLayout(targetElement);
	// Transition to the final position
	$tw.utils.setStyle(targetElement,[
		{transition: "opacity " + $tw.config.preferences.animationDurationMs + " ease-in-out, " +
					"margin-bottom " + $tw.config.preferences.animationDurationMs + " ease-in-out"},
		{marginBottom: currMarginBottom + "px"},
		{opacity: "1.0"}
	]);
};

ClassicListView.prototype.remove = function(index) {
	var listElementNode = this.listWidget.children[index],
		targetElement = listElementNode.domNode;
	// Get the current height of the tiddler
	var currWidth = targetElement.offsetWidth,
		currMarginBottom = parseInt(window.getComputedStyle(targetElement).marginBottom,10),
		currMarginTop = parseInt(window.getComputedStyle(targetElement).marginTop,10),
		currHeight = targetElement.offsetHeight + currMarginTop;
	// Attach an event handler for the end of the transition
	targetElement.addEventListener($tw.utils.convertEventName("transitionEnd"),function(event) {
		if(targetElement.parentNode) {
			targetElement.parentNode.removeChild(targetElement);
		}
	},false);
	// Animate the closure
	$tw.utils.setStyle(targetElement,[
		{transition: "none"},
		{transform: "translateX(0px)"},
		{marginBottom:  currMarginBottom + "px"},
		{opacity: "1.0"}
	]);
	$tw.utils.forceLayout(targetElement);
	$tw.utils.setStyle(targetElement,[
		{transition: $tw.utils.roundTripPropertyName("transform") + " " + $tw.config.preferences.animationDurationMs + " ease-in-out, " +
					"opacity " + $tw.config.preferences.animationDurationMs + " ease-in-out, " +
					"margin-bottom " + $tw.config.preferences.animationDurationMs + " ease-in-out"},
		{transform: "translateX(" + currWidth + "px)"},
		{marginBottom: (-currHeight) + "px"},
		{opacity: "0.0"}
	]);
	// Returning true causes the DOM node not to be deleted
	return true;
};

exports.classic = ClassicListView;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/list/listviews/scroller.js" data-tiddler-type="application/javascript" data-tiddler-module-type="listview" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/list/listviews/scroller.js","listview",function(module,exports,require) {/*\
title: $:/core/modules/widgets/list/listviews/scroller.js
type: application/javascript
module-type: listview

A list view that scrolls to newly inserted elements

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var ScrollerListView = function(listWidget) {
	this.listWidget = listWidget;
}

ScrollerListView.prototype.navigateTo = function(historyInfo) {
	var listElementIndex = this.listWidget.findListElementByTitle(0,historyInfo.title),
		listElementNode = this.listWidget.children[listElementIndex],
		targetElement = listElementNode.domNode;
	// Scroll the node into view
	var scrollEvent = document.createEvent("Event");
	scrollEvent.initEvent("tw-scroll",true,true);
	targetElement.dispatchEvent(scrollEvent);
};

exports.scroller = ScrollerListView;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/navigator.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/navigator.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/navigator.js
type: application/javascript
module-type: widget

Implements the navigator widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var NavigatorWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

NavigatorWidget.prototype.generate = function() {
	// Get our parameters
	this.storyTitle = this.renderer.getAttribute("story");
	this.historyTitle = this.renderer.getAttribute("history");
	// Set the element
	this.tag = "div";
	this.attributes = {
		"class": "tw-navigator"
	};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
	this.events = [
		{name: "tw-navigate", handlerObject: this, handlerMethod: "handleNavigateEvent"},
		{name: "tw-edit-tiddler", handlerObject: this, handlerMethod: "handleEditTiddlerEvent"},
		{name: "tw-delete-tiddler", handlerObject: this, handlerMethod: "handleDeleteTiddlerEvent"},
		{name: "tw-save-tiddler", handlerObject: this, handlerMethod: "handleSaveTiddlerEvent"},
		{name: "tw-close-tiddler", handlerObject: this, handlerMethod: "handleCloseTiddlerEvent"},
		{name: "tw-new-tiddler", handlerObject: this, handlerMethod: "handleNewTiddlerEvent"}
	];
};

NavigatorWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// We don't need to refresh ourselves, so just refresh any child nodes
	$tw.utils.each(this.children,function(node) {
		if(node.refreshInDom) {
			node.refreshInDom(changedTiddlers);
		}
	});
};

NavigatorWidget.prototype.getStoryList = function() {
	var text = this.renderer.renderTree.wiki.getTextReference(this.storyTitle,"");
	if(text && text.length > 0) {
		this.storyList = text.split("\n");
	} else {
		this.storyList = [];
	}
};

NavigatorWidget.prototype.saveStoryList = function() {
	var storyTiddler = this.renderer.renderTree.wiki.getTiddler(this.storyTitle);
	this.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler({
		title: this.storyTitle
	},storyTiddler,{text: this.storyList.join("\n")}));
};

NavigatorWidget.prototype.findTitleInStory = function(title,defaultIndex) {
	for(var t=0; t<this.storyList.length; t++) {
		if(this.storyList[t] === title) {
			return t;
		}
	}	
	return defaultIndex;
};

// Navigate to a specified tiddler
NavigatorWidget.prototype.handleNavigateEvent = function(event) {
	if(this.storyTitle) {
		// Update the story tiddler if specified
		this.getStoryList();
		// See if the tiddler is already there
		var slot = this.findTitleInStory(event.navigateTo,-1);
		// If not we need to add it
		if(slot === -1) {
			// First we try to find the position of the story element we navigated from
			slot = this.findTitleInStory(event.navigateFromTitle,-1) + 1;
			// Add the tiddler
			this.storyList.splice(slot,0,event.navigateTo);
			// Save the story
			this.saveStoryList();
		}
	}
	// Add a new record to the top of the history stack
	if(this.historyTitle) {
		var historyList = this.renderer.renderTree.wiki.getTiddlerData(this.historyTitle,[]);
		historyList.push({title: event.navigateTo, fromPageRect: event.navigateFromClientRect});
		this.renderer.renderTree.wiki.setTiddlerData(this.historyTitle,historyList);
	}
	event.stopPropagation();
	return false;
};

// Close a specified tiddler
NavigatorWidget.prototype.handleCloseTiddlerEvent = function(event) {
	this.getStoryList();
	// Look for tiddlers with this title to close
	var slot = this.findTitleInStory(event.tiddlerTitle,-1);
	if(slot !== -1) {
		this.storyList.splice(slot,1);
		this.saveStoryList();
	}
	event.stopPropagation();
	return false;
};

// Place a tiddler in edit mode
NavigatorWidget.prototype.handleEditTiddlerEvent = function(event) {
	this.getStoryList();
	// Replace the specified tiddler with a draft in edit mode
	for(var t=0; t<this.storyList.length; t++) {
		if(this.storyList[t] === event.tiddlerTitle) {
			// Compute the title for the draft
			var draftTitle = this.generateDraftTitle(event.tiddlerTitle);
			this.storyList[t] = draftTitle;
			// Get the current value of the tiddler we're editing
			var tiddler = this.renderer.renderTree.wiki.getTiddler(event.tiddlerTitle);
			// Save the initial value of the draft tiddler
			this.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(
				{
					text: "Type the text for the tiddler '" + event.tiddlerTitle + "'"
				},
				tiddler,
				{
					title: draftTitle,
					"draft.title": event.tiddlerTitle,
					"draft.of": event.tiddlerTitle
				}));
		}
	}
	this.saveStoryList();
	event.stopPropagation();
	return false;
};

// Delete a tiddler
NavigatorWidget.prototype.handleDeleteTiddlerEvent = function(event) {
	// Get the tiddler title we're deleting
	var tiddler = this.renderer.renderTree.wiki.getTiddler(event.tiddlerTitle);
	// Check if the tiddler we're deleting is in draft mode
	if(tiddler.hasField("draft.title")) {
		// Delete the original tiddler
		this.renderer.renderTree.wiki.deleteTiddler(tiddler.fields["draft.of"]);
	}
	// Delete this tiddler
	this.renderer.renderTree.wiki.deleteTiddler(event.tiddlerTitle);
	// Remove the closed tiddler from the story
	this.getStoryList();
	// Look for tiddler with this title to close
	var slot = this.findTitleInStory(event.tiddlerTitle,-1);
	if(slot !== -1) {
		this.storyList.splice(slot,1);
		this.saveStoryList();
	}
	event.stopPropagation();
	return false;
};

/*
Generate a title for the draft of a given tiddler
*/
NavigatorWidget.prototype.generateDraftTitle = function(title) {
	var c = 0;
	do {
		var draftTitle = "Draft " + (c ? (c + 1) + " " : "") + "of '" + title + "'";
		c++;
	} while(this.renderer.renderTree.wiki.tiddlerExists(draftTitle));
	return draftTitle;
};

// Take a tiddler out of edit mode, saving the changes
NavigatorWidget.prototype.handleSaveTiddlerEvent = function(event) {
	this.getStoryList();
	var storyTiddlerModified = false;
	for(var t=0; t<this.storyList.length; t++) {
		if(this.storyList[t] === event.tiddlerTitle) {
			var tiddler = this.renderer.renderTree.wiki.getTiddler(event.tiddlerTitle);
			if(tiddler.hasField("draft.title")) {
				// Save the draft tiddler as the real tiddler
				this.renderer.renderTree.wiki.addTiddler(new $tw.Tiddler(tiddler,{
					title: tiddler.fields["draft.title"],
					modified: new Date(),
					"draft.title": undefined, 
					"draft.of": undefined
				}));
				// Remove the draft tiddler
				this.renderer.renderTree.wiki.deleteTiddler(event.tiddlerTitle);
				// Remove the original tiddler if we're renaming it
				if(tiddler.fields["draft.of"] !== tiddler.fields["draft.title"]) {
					this.renderer.renderTree.wiki.deleteTiddler(tiddler.fields["draft.of"]);
				}
				// Make the story record point to the newly saved tiddler
				this.storyList[t] = tiddler.fields["draft.title"];
				// Check if we're modifying the story tiddler itself
				if(tiddler.fields["draft.title"] === this.storyTitle) {
					storyTiddlerModified = true;
				}
			}
		}
	}
	if(!storyTiddlerModified) {
		this.saveStoryList();
	}
	event.stopPropagation();
	return false;
};

// Create a new draft tiddler
NavigatorWidget.prototype.handleNewTiddlerEvent = function(event) {
	// Get the story details
	this.getStoryList();
	// Create the new tiddler
	var title;
	for(var t=0; true; t++) {
		title = "New Tiddler" + (t ? " " + t : "");
		if(!this.renderer.renderTree.wiki.tiddlerExists(title)) {
			break;
		}
	}
	var tiddler = new $tw.Tiddler({
		title: title,
		text: "Newly created tiddler"
	});
	this.renderer.renderTree.wiki.addTiddler(tiddler);
	// Create the draft tiddler
	var draftTitle = "New Tiddler at " + (new Date()),
		draftTiddler = new $tw.Tiddler({
			text: "Type the text for the new tiddler",
			title: draftTitle,
			"draft.title": title,
			"draft.of": title
		});
	this.renderer.renderTree.wiki.addTiddler(draftTiddler);
	// Update the story to insert the new draft at the top
	var slot = this.findTitleInStory(event.navigateFromTitle,-1) + 1;
	this.storyList.splice(slot,0,draftTitle);
	// Save the updated story
	this.saveStoryList();
	// Add a new record to the top of the history stack
	var history = this.renderer.renderTree.wiki.getTiddlerData(this.historyTitle,[]);
	history.push({title: draftTitle});
	this.renderer.renderTree.wiki.setTiddlerData(this.historyTitle,history);
	event.stopPropagation();
	return false;
};

exports.navigator = NavigatorWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/password.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/password.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/password.js
type: application/javascript
module-type: widget

Implements the password widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var PasswordWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

PasswordWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.name = this.renderer.getAttribute("name");
	// Get the current password
	var password = $tw.browser ? $tw.utils.getPassword(this.name) : "";
	// Generate our element
	this.tag = "input";
	this.attributes = {
		type: "password",
		value: password
	};
	this.events = [
		{name: "keyup", handlerObject: this},
		{name: "input", handlerObject: this}];
};

PasswordWidget.prototype.handleEvent = function(event) {
	var password = this.renderer.domNode.value;
	return $tw.utils.savePassword(this.name,password);
};

exports.password = PasswordWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/reveal.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/reveal.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/reveal.js
type: application/javascript
module-type: widget

Implements the reveal widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var RevealWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

RevealWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.state = this.renderer.getAttribute("state");
	this.type = this.renderer.getAttribute("type");
	this.text = this.renderer.getAttribute("text");
	this.position = this.renderer.getAttribute("position");
	this["default"] = this.renderer.getAttribute("default");
	this.qualifyTiddlerTitles = this.renderer.getAttribute("qualifyTiddlerTitles");
	this["class"] = this.renderer.getAttribute("class");
	// Compute the title of the state tiddler and read it
	this.stateTitle = this.state;
	if(this.qualifyTiddlerTitles) {
		this.stateTitle =  this.stateTitle + "-" + this.renderer.getContextScopeId();
	}
	this.readState();
	// Set up the element attributes
	var classes = ["tw-reveal"],
		styles = [];
	if(this["class"]) {
		$tw.utils.pushTop(classes,this["class"]);
	}
	switch(this.type) {
		case "popup":
			styles.push("position:absolute;");
			classes.push("tw-popup");
			break;
	}
	styles.push("display:" + (this.isOpen ? (this.renderer.parseTreeNode.isBlock ? "block" : "inline") : "none") + ";");
	// Set the element
	this.tag =  "div";
	this.attributes = {
		"class": classes.join(" "),
		style: styles.join("")
	};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.isOpen ? this.renderer.parseTreeNode.children : []);
	this.events = [{name: "click", handlerObject: this, handlerMethod: "handleClickEvent"}];
};

/*
Read the state tiddler
*/
RevealWidget.prototype.readState = function() {
	// Start with the default value for being open or closed
	if(this["default"]) {
		this.isOpen = this["default"] === "open";
	}
	// Read the information from the state tiddler
	if(this.stateTitle) {
		var state = this.renderer.renderTree.wiki.getTextReference(this.stateTitle);
		switch(this.type) {
			case "popup":
				this.readPopupState(state);
				break;
			case "match":
				this.readMatchState(state);
				break;
			case "nomatch":
				this.readMatchState(state);
				this.isOpen = !this.isOpen;
				break;
		}
	}
};

RevealWidget.prototype.readMatchState = function(state) {
	this.isOpen = state === this.text;
};

RevealWidget.prototype.readPopupState = function(state) {
	var popupLocationRegExp = /^\((-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+),(-?[0-9\.E]+)\)$/,
		match = popupLocationRegExp.exec(state);
	// Check if the state matches the location regexp
	if(match) {
		// If so, we're open
		this.isOpen = true;
		// Get the location
		this.popup = {
			left: parseFloat(match[1]),
			top: parseFloat(match[2]),
			width: parseFloat(match[3]),
			height: parseFloat(match[4])
		};
	} else {
		// If not, we're closed
		this.isOpen = false;
	}
};

RevealWidget.prototype.handleClickEvent = function(event) {
	if(event.type === "click" && this.type === "popup") {
		// Cancel the popup if we get a click on it
		if(this.stateTitle) {
			this.renderer.renderTree.wiki.deleteTextReference(this.stateTitle);
		}
		event.preventDefault();
		return false;
	}
	return true;
};

RevealWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
	if(changedAttributes.state || changedAttributes.type || changedAttributes.text || changedAttributes.position || changedAttributes["default"] || changedAttributes.qualifyTiddlerTitles || changedAttributes["class"]) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		var needChildrenRefresh = true; // Avoid refreshing the children nodes if we don't need to
		// Get the open state
		this.readState();
		// Construct the child nodes if  required
		if(this.isOpen && this.children.length === 0) {
			this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
			var parentNode = this.renderer.domNode;
			$tw.utils.each(this.children,function(child) {
				parentNode.appendChild(child.renderInDom());
			});
			needChildrenRefresh = false;
		}
		// Refresh any child nodes
		if(needChildrenRefresh) {
			$tw.utils.each(this.children,function(node) {
				if(node.refreshInDom) {
					node.refreshInDom(changedTiddlers);
				}
			});
		}
		// Set the visibility of the children
		this.renderer.domNode.style.display = this.isOpen ? (this.renderer.parseTreeNode.isBlock ? "block" : "inline") : "none";
	}
	// Position the content if required
	if(this.isOpen) {
		this.postRenderInDom();
	}
};

RevealWidget.prototype.postRenderInDom = function() {
	switch(this.type) {
		case "popup":
			if(this.isOpen) {
				this.renderer.domNode.style.position = "absolute";
				this.renderer.domNode.style.zIndex = "1000";
				switch(this.position) {
					case "left":
						this.renderer.domNode.style.left = (this.popup.left - this.renderer.domNode.offsetWidth) + "px";
						this.renderer.domNode.style.top = this.popup.top + "px";
						break;
					case "above":
						this.renderer.domNode.style.left = this.popup.left + "px";
						this.renderer.domNode.style.top = (this.popup.top - this.renderer.domNode.offsetHeight) + "px";
						break;
					case "aboveright":
						this.renderer.domNode.style.left = (this.popup.left + this.popup.width) + "px";
						this.renderer.domNode.style.top = (this.popup.top + this.popup.height - this.renderer.domNode.offsetHeight) + "px";
						break;
					case "right":
						this.renderer.domNode.style.left = (this.popup.left + this.popup.width) + "px";
						this.renderer.domNode.style.top = this.popup.top + "px";
						break;
					case "belowleft":
						this.renderer.domNode.style.left = (this.popup.left + this.popup.width - this.renderer.domNode.offsetWidth) + "px";
						this.renderer.domNode.style.top = (this.popup.top + this.popup.height) + "px";
						break;
					default: // Below
						this.renderer.domNode.style.left = this.popup.left + "px";
						this.renderer.domNode.style.top = (this.popup.top + this.popup.height) + "px";
						break;
				}
			}
			break;
	}
};

exports.reveal = RevealWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/setstyle.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/setstyle.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/setstyle.js
type: application/javascript
module-type: widget

Implements the setstyle widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var SetStyleWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

SetStyleWidget.prototype.generate = function() {
	// Get the parameters from the attributes
	this.name = this.renderer.getAttribute("name");
	this.value = this.renderer.getAttribute("value");
	this["class"] = this.renderer.getAttribute("class");
	// Set up the element
	this.tag = this.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.attributes = {
		style: this.name + ":" + this.value
	};
	if(this["class"]) {
		this.attributes["class"] = this["class"];
	}
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,this.renderer.parseTreeNode.children);
};

exports.setstyle = SetStyleWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/transclude.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/transclude.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/transclude.js
type: application/javascript
module-type: widget

The transclude widget includes another tiddler into the tiddler being rendered.

Attributes:
	target: the title of the tiddler to transclude
	template: the title of the tiddler to use as a template for the transcluded tiddler

The simplest case is to just supply a target tiddler:

{{{
<$transclude target="Foo"/>
}}}

This will render the tiddler Foo within the current tiddler. If the tiddler Foo includes
the view widget (or other widget that reference the fields of the current tiddler), then the
fields of the tiddler Foo will be accessed.

If you want to transclude the tiddler as a template, so that the fields referenced by the view
widget are those of the tiddler doing the transcluding, then you can instead specify the tiddler
as a template:

{{{
<$transclude template="Foo"/>
}}}

The effect is the same as the previous example: the text of the tiddler Foo is rendered. The
difference is that the view widget will access the fields of the tiddler doing the transcluding.

The `target` and `template` attributes may be combined:

{{{
<$transclude template="Bar" target="Foo"/>
}}}

Here, the text of the tiddler `Bar` will be transcluded, with the widgets within it accessing the fields
of the tiddler `Foo`.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var TranscludeWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

TranscludeWidget.prototype.generate = function() {
	var tr, templateParseTree, templateTiddler;
	// Get the render target details
	this.targetTitle = this.renderer.getAttribute("target",this.renderer.getContextTiddlerTitle());
	this.targetField = this.renderer.getAttribute("field");
	this.targetIndex = this.renderer.getAttribute("index");
	// Get the render tree for the template
	this.templateTitle = undefined;
	if(this.renderer.parseTreeNode.children && this.renderer.parseTreeNode.children.length > 0) {
		// Use the child nodes as the template if we've got them
		templateParseTree = this.renderer.parseTreeNode.children;
	} else {
		this.templateTitle = this.renderer.getAttribute("template",this.targetTitle);
		// Check for recursion
		if(this.renderer.checkContextRecursion({
				tiddlerTitle: this.targetTitle,
				templateTitle: this.templateTitle
			})) {
			templateParseTree = [{type: "text", text: "Tiddler recursion error in transclude widget"}];	
		} else {
			var parser;
			if(this.targetField === "text" || (!this.targetField && !this.targetIndex)) {
				parser = this.renderer.renderTree.wiki.parseTiddler(this.templateTitle,{parseAsInline: !this.renderer.parseTreeNode.isBlock});
			} else {
				var tiddler,text;
				if(this.targetField) {
					tiddler = this.renderer.renderTree.wiki.getTiddler(this.targetTitle);
					text = tiddler ? tiddler.fields[this.targetField] : "";
					if(text === undefined) {
						text = "";
					}
					parser = this.renderer.renderTree.wiki.parseText("text/vnd.tiddlywiki",text,{parseAsInline: !this.renderer.parseTreeNode.isBlock});
				} else if(this.targetIndex) {
					text = this.renderer.renderTree.wiki.extractTiddlerDataItem(this.targetTitle,this.targetIndex,"");
					parser = this.renderer.renderTree.wiki.parseText("text/vnd.tiddlywiki",text);
				}
			}
			templateParseTree = parser ? parser.tree : [];
		}
	}
	// Set up the attributes for the wrapper element
	var classes = ["tw-transclude"];
	if(this.renderer.hasAttribute("class")) {
		$tw.utils.pushTop(classes,this.renderer.getAttribute("class").split(" "));
	}
	if(!this.renderer.renderTree.wiki.tiddlerExists(this.targetTitle)) {
		$tw.utils.pushTop(classes,"tw-tiddler-missing");
	}
	// Create the renderers for the wrapper and the children
	var newRenderContext = {
		tiddlerTitle: this.targetTitle,
		templateTitle: this.templateTitle,
		parentContext: this.renderer.renderContext
	};
	// Set the element
	this.tag = this.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.attributes = {};
	if(classes.length > 0) {
		this.attributes["class"] = classes.join(" ");
	}
	if(this.renderer.hasAttribute("style")) {
		this.attributes.style = this.renderer.getAttribute("style");
	}
	if(this.renderer.hasAttribute("tooltip")) {
		this.attributes.title = this.renderer.getAttribute("tooltip");
	}
	this.children = this.renderer.renderTree.createRenderers(newRenderContext,templateParseTree);
};

TranscludeWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Set the class for missing tiddlers
	if(this.targetTitle && changedTiddlers[this.targetTitle]) {
		$tw.utils.toggleClass(this.renderer.domNode,"tw-tiddler-missing",!this.renderer.renderTree.wiki.tiddlerExists(this.targetTitle));
	}
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
	if(changedAttributes.target || changedAttributes.template || (this.templateTitle && changedTiddlers[this.templateTitle])) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// We don't need to refresh ourselves, so just refresh any child nodes
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.transclude = TranscludeWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widget/version.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widget/version.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widget/version.js
type: application/javascript
module-type: widget

Implements the version widget.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var VersionWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Generate child nodes
	this.generate();
};

VersionWidget.prototype.generate = function() {
	// Set the element
	this.tag = "span";
	this.attributes = {};
	this.children = this.renderer.renderTree.createRenderers(this.renderer.renderContext,[{
		type: "text",
		text: $tw.version
	}]);
};

exports.version = VersionWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view.js" data-tiddler-type="application/javascript" data-tiddler-module-type="widget" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view.js","widget",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view.js
type: application/javascript
module-type: widget

The view widget displays a tiddler field.

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Define the "text" viewer here so that it is always available
*/
var TextViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

TextViewer.prototype.render = function() {
	// Get the value as a string
	if(this.field !== "text" && this.tiddler) {
		this.value = this.tiddler.getFieldString(this.field);
	}
	var value = "";
	if(this.value !== undefined && this.value !== null) {
		value = this.value;
	}
	// Set the element details
	this.viewWidget.tag = "span";
	this.viewWidget.attributes = {};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
		type: "text",
		text: value
	}]);
};

var ViewWidget = function(renderer) {
	// Save state
	this.renderer = renderer;
	// Initialise the field viewers if they've not been done already
	if(!this.fieldViewers) {
		ViewWidget.prototype.fieldViewers = {text: TextViewer}; // Start with the built-in text viewer
		$tw.modules.applyMethods("fieldviewer",this.fieldViewers);
	}
	// Generate child nodes
	this.generate();
};

ViewWidget.prototype.generate = function() {
	// Get parameters from our attributes
	this.tiddlerTitle = this.renderer.getAttribute("tiddler",this.renderer.getContextTiddlerTitle());
	this.fieldName = this.renderer.getAttribute("field","text");
	this.format = this.renderer.getAttribute("format","text");
	// Get the value to display
	var tiddler = this.renderer.renderTree.wiki.getTiddler(this.tiddlerTitle),
		value;
	if(tiddler) {
		if(this.fieldName === "text") {
			// Calling getTiddlerText() triggers lazy loading of skinny tiddlers
			value = this.renderer.renderTree.wiki.getTiddlerText(this.tiddlerTitle);
		} else {
			value = tiddler.fields[this.fieldName];
		}
	} else { // Use a special value if the tiddler is missing
		switch(this.fieldName) {
			case "title":
				value = this.tiddlerTitle;
				break;
			case "modified":
			case "created":
				value = new Date();
				break;
			default:
				value = "";
				break;
		}
	}
	// Choose the viewer to use
	var Viewer = this.fieldViewers.text;
	if($tw.utils.hop(this.fieldViewers,this.format)) {
		Viewer = this.fieldViewers[this.format];
	}
	this.viewer = new Viewer(this,tiddler,this.fieldName,value);
	// Ask the viewer to create the widget element
	this.viewer.render();
};

ViewWidget.prototype.refreshInDom = function(changedAttributes,changedTiddlers) {
	// Check if any of our attributes have changed, or if a tiddler we're interested in has changed
	if(changedAttributes.tiddler || changedAttributes.field || changedAttributes.format || (this.tiddlerTitle && changedTiddlers[this.tiddlerTitle])) {
		// Regenerate and rerender the widget and replace the existing DOM node
		this.generate();
		var oldDomNode = this.renderer.domNode,
			newDomNode = this.renderer.renderInDom();
		oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);
	} else {
		// We don't need to refresh ourselves, so just refresh any child nodes
		$tw.utils.each(this.children,function(node) {
			if(node.refreshInDom) {
				node.refreshInDom(changedTiddlers);
			}
		});
	}
};

exports.view = ViewWidget;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/date.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/date.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/date.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as a date

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var DateViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

DateViewer.prototype.render = function() {
	var template = this.viewWidget.renderer.getAttribute("template","DD MMM YYYY"),
		value = "";
	if(this.value !== undefined) {
		value = $tw.utils.formatDateString(this.value,template);
	}
	// Set the element details
	this.viewWidget.tag = "span";
	this.viewWidget.attributes = {
		"class": "tw-view-date"
	};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
		type: "text",
		text: value
	}]);
};

exports.date = DateViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/htmlencoded.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/htmlencoded.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/htmlencoded.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as HTML encoded text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var HtmlEncodedViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

HtmlEncodedViewer.prototype.render = function() {
	// Get the value as a string
	if(this.field !== "text" && this.tiddler) {
		this.value = this.tiddler.getFieldString(this.field);
	}
	var value = "";
	if(this.value !== undefined && this.value !== null) {
		value = this.value;
	}
	// Set the element details
	this.viewWidget.tag = "span";
	this.viewWidget.attributes = {
		"class": "tw-view-htmlencoded"
	};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
		type: "text",
		text: $tw.utils.htmlEncode(value)
	}]);
};

exports.htmlencoded = HtmlEncodedViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/htmlwikified.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/htmlwikified.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/htmlwikified.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as a textual HTML representation of the wikified text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var HtmlWikifiedViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

HtmlWikifiedViewer.prototype.render = function() {
	// Parse the field text
	var newRenderContext = {
		parentContext: this.viewWidget.renderer.renderContext
	};
	var wiki = this.viewWidget.renderer.renderTree.wiki,
		parser = wiki.parseText("text/vnd.tiddlywiki",this.value),
		renderTree = new $tw.WikiRenderTree(parser,{wiki: wiki});
	renderTree.execute(newRenderContext);
	var text = renderTree.render("text/html");
	// Set the element details
	this.viewWidget.tag = "pre";
	this.viewWidget.attributes = {
		"class": "tw-view-htmlwikified"
	};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
			type: "text",
			text: text
		}]);
};

exports.htmlwikified = HtmlWikifiedViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/jsencoded.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/jsencoded.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/jsencoded.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as JavaScript stringified text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var JsEncodedViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

JsEncodedViewer.prototype.render = function() {
	// Get the value as a string
	if(this.field !== "text" && this.tiddler) {
		this.value = this.tiddler.getFieldString(this.field);
	}
	var value = "";
	if(this.value !== undefined && this.value !== null) {
		value = this.value;
	}
	// Set the element details
	this.viewWidget.tag = "pre";
	this.viewWidget.attributes = {
		"class": "tw-view-jsencoded"
	};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
			type: "text",
			text: $tw.utils.stringify(value)
		}]);
};

exports.jsencoded = JsEncodedViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/link.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/link.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/link.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as a link

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var LinkViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

LinkViewer.prototype.render = function() {
	var text = this.value === undefined ? "" : this.value;
	// Indicate that we're not generating an element
	this.viewWidget.tag = this.viewWidget.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.viewWidget.attributes = {
		"class": "tw-view-link"
	};
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[{
			type: "element",
			tag: "$link",
			attributes: {
				to: {type: "string", value: text}
			},
			children: [{
				type: "text",
				text: text
			}]
		}]);
};

exports.link = LinkViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/widgets/view/viewers/wikified.js" data-tiddler-type="application/javascript" data-tiddler-module-type="fieldviewer" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/widgets/view/viewers/wikified.js","fieldviewer",function(module,exports,require) {/*\
title: $:/core/modules/widgets/view/viewers/wikified.js
type: application/javascript
module-type: fieldviewer

A viewer for viewing tiddler fields as wikified text

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

var WikifiedViewer = function(viewWidget,tiddler,field,value) {
	this.viewWidget = viewWidget;
	this.tiddler = tiddler;
	this.field = field;
	this.value = value;
};

WikifiedViewer.prototype.render = function() {
	// Set the element details
	this.viewWidget.tag = this.viewWidget.renderer.parseTreeNode.isBlock ? "div" : "span";
	this.viewWidget.attributes = {};
	var node = {
			type: "element",
			tag: "$transclude",
			attributes: {
				"class": "tw-view-wikified",
				field: {type: "string", value: this.field}
			},
			isBlock: this.viewWidget.renderer.parseTreeNode.isBlock
		};
	if(this.tiddler && this.tiddler.fields.title) {
		node.attributes.target = {type: "string", value: this.tiddler.fields.title}
	}
	this.viewWidget.children = this.viewWidget.renderer.renderTree.createRenderers(this.viewWidget.renderer.renderContext,[node]);
};

exports.wikified = WikifiedViewer;

})();
});
</script><script data-tiddler-title="$:/core/modules/wiki.js" data-tiddler-type="application/javascript" data-tiddler-module-type="wikimethod" type="text/javascript" data-module="yes">$tw.modules.define("$:/core/modules/wiki.js","wikimethod",function(module,exports,require) {/*\
title: $:/core/modules/wiki.js
type: application/javascript
module-type: wikimethod

Extension methods for the $tw.Wiki object

Adds the following properties to the wiki object:

* `eventListeners` is an array of {filter: <string>, listener: fn}
* `changedTiddlers` is a hashmap describing changes to named tiddlers since wiki change events were
last dispatched. Each entry is a hashmap containing two fields:
	modified: true/false
	deleted: true/false
* `changeCount` is a hashmap by tiddler title containing a numerical index that starts at zero and is
	incremented each time a tiddler is created changed or deleted
* `caches` is a hashmap by tiddler title containing a further hashmap of named cache objects. Caches
	are automatically cleared when a tiddler is modified or deleted

\*/
(function(){

/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

/*
Get the value of a text reference. Text references can have any of these forms:
	<tiddlertitle>
	<tiddlertitle>!!<fieldname>
	!!<fieldname> - specifies a field of the current tiddlers
	<tiddlertitle>##<field>
*/
exports.getTextReference = function(textRef,defaultText,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title = tr.title || currTiddlerTitle;
	if(tr.field) {
		var tiddler = this.getTiddler(title);
		if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {
			return tiddler.fields[tr.field];
		} else {
			return defaultText;
		}
	} else if(tr.index) {
		return this.extractTiddlerDataItem(title,tr.index,defaultText);
	} else {
		return this.getTiddlerText(title);
	}
};

exports.setTextReference = function(textRef,value,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title,tiddler,fields;
	// Check if it is a reference to a tiddler
	if(tr.title && !tr.field) {
		tiddler = this.getTiddler(tr.title);
		this.addTiddler(new $tw.Tiddler(tiddler,{title: tr.title,text: value}));
	// Else check for a field reference
	} else if(tr.field) {
		title = tr.title || currTiddlerTitle;
		tiddler = this.getTiddler(title);
		if(tiddler) {
			fields = {};
			fields[tr.field] = value;
			this.addTiddler(new $tw.Tiddler(tiddler,fields));
		}
	}
};

exports.deleteTextReference = function(textRef,currTiddlerTitle) {
	var tr = $tw.utils.parseTextReference(textRef),
		title,tiddler,fields;
	// Check if it is a reference to a tiddler
	if(tr.title && !tr.field) {
		this.deleteTiddler(tr.title);
	// Else check for a field reference
	} else if(tr.field) {
		title = tr.title || currTiddlerTitle;
		tiddler = this.getTiddler(title);
		if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {
			fields = {};
			fields[tr.field] = undefined;
			this.addTiddler(new $tw.Tiddler(tiddler,fields));
		}
	}
};

exports.addEventListener = function(filter,listener) {
	this.eventListeners = this.eventListeners || [];
	this.eventListeners.push({
		filter: filter,
		listener: listener
	});	
};

exports.removeEventListener = function(filter,listener) {
	for(var c=this.eventListeners.length-1; c>=0; c--) {
		var l = this.eventListeners[c];
		if(l.filter === filter && l.listener === listener) {
			this.eventListeners.splice(c,1);
		}
	}
};

/*
Causes a tiddler to be marked as changed, incrementing the change count, and triggers event handlers.
This method should be called after the changes it describes have been made to the wiki.tiddlers[] array.
	title: Title of tiddler
	isDeleted: defaults to false (meaning the tiddler has been created or modified),
		true if the tiddler has been created
*/
exports.enqueueTiddlerEvent = function(title,isDeleted) {
	// Record the touch in the list of changed tiddlers
	this.changedTiddlers = this.changedTiddlers || {};
	this.changedTiddlers[title] = this.changedTiddlers[title] || [];
	this.changedTiddlers[title][isDeleted ? "deleted" : "modified"] = true;
	// Increment the change count
	this.changeCount = this.changeCount || {};
	if($tw.utils.hop(this.changeCount,title)) {
		this.changeCount[title]++;
	} else {
		this.changeCount[title] = 1;
	}
	// Trigger events
	this.eventListeners = this.eventListeners || [];
	if(!this.eventsTriggered) {
		var me = this;
		$tw.utils.nextTick(function() {
			var changes = me.changedTiddlers;
			me.changedTiddlers = {};
			me.eventsTriggered = false;
			for(var e=0; e<me.eventListeners.length; e++) {
				var listener = me.eventListeners[e];
				listener.listener(changes);
			}
		});
		this.eventsTriggered = true;
	}
};

exports.getChangeCount = function(title) {
	this.changeCount = this.changeCount || {};
	if($tw.utils.hop(this.changeCount,title)) {
		return this.changeCount[title];
	} else {
		return 0;
	}
};

exports.deleteTiddler = function(title) {
console.log("Deleting",title)
	delete this.tiddlers[title];
	this.clearCache(title);
	this.enqueueTiddlerEvent(title,true);
};

exports.tiddlerExists = function(title) {
	return !!this.tiddlers[title];
};

exports.addTiddler = function(tiddler) {
	// Check if we're passed a fields hashmap instead of a tiddler
	if(!(tiddler instanceof $tw.Tiddler)) {
		tiddler = new $tw.Tiddler(tiddler);
	}
	// Get the title
	var title = tiddler.fields.title;
	// Save the tiddler
	this.tiddlers[title] = tiddler;
	this.clearCache(title);
	this.enqueueTiddlerEvent(title);
};

/*
Return a sorted array of tiddler titles, optionally filtered by a tag 
*/
exports.getTiddlers = function(sortField,excludeTag) {
	sortField = sortField || "title";
	var tiddlers = [], t, titles = [];
	for(t in this.tiddlers) {
		if($tw.utils.hop(this.tiddlers,t) && !this.tiddlers[t].isShadow()) {
			tiddlers.push(this.tiddlers[t]);
		}
	}
	tiddlers.sort(function(a,b) {
		var aa = a.fields[sortField].toLowerCase() || "",
			bb = b.fields[sortField].toLowerCase() || "";
		if(aa < bb) {
			return -1;
		} else {
			if(aa > bb) {
				return 1;
			} else {
				return 0;
			}
		}
	});
	for(t=0; t<tiddlers.length; t++) {
		if(!excludeTag || !tiddlers[t].hasTag(excludeTag)) {
			titles.push(tiddlers[t].fields.title);
		}
	}
	return titles;
};

/*
Sort an array of tiddler titles by a specified field
	titles: array of titles (sorted in place)
	sortField: name of field to sort by
	isDescending: true if the sort should be descending
	isCaseSensitive: true if the sort should consider upper and lower case letters to be different
*/
exports.sortTiddlers = function(titles,sortField,isDescending,isCaseSensitive) {
	var self = this;
	titles.sort(function(a,b) {
		if(sortField !== "title") {
			a = self.getTiddler(a).fields[sortField] || "";
			b = self.getTiddler(b).fields[sortField] || "";
		}
		if(!isCaseSensitive) {
			if(typeof a === "string") {
				a = a.toLowerCase();
			}
			if(typeof b === "string") {
				b = b.toLowerCase();
			}
		}
		if(a < b) {
			return isDescending ? +1 : -1;
		} else {
			if(a > b) {
				return isDescending ? -1 : +1;
			} else {
				return 0;
			}
		}
	});
};

exports.forEachTiddler = function(/* [sortField,[excludeTag,]]callback */) {
	var arg = 0,
		sortField = arguments.length > 1 ? arguments[arg++] : null,
		excludeTag = arguments.length > 2 ? arguments[arg++] : null,
		callback = arguments[arg++],
		titles = this.getTiddlers(sortField,excludeTag),
		t, tiddler;
	for(t=0; t<titles.length; t++) {
		tiddler = this.tiddlers[titles[t]];
		if(tiddler) {
			callback.call(this,tiddler.fields.title,tiddler);
		}
	}
};

exports.getMissingTitles = function() {
	return []; // Todo
};

exports.getOrphanTitles = function() {
	return []; // Todo
};

exports.getShadowTitles = function() {
	var titles = [];
	for(var title in this.tiddlers) {
		if(this.tiddlers[title].isShadow()) {
			titles.push(title);
		}
	}
	titles.sort();
	return titles;
};

/*
Retrieves a list of the tiddler titles that are tagged with a given tag
*/
exports.getTiddlersWithTag = function(tag) {
	var titles = [];
	for(var title in this.tiddlers) {
		var tiddler = this.tiddlers[title];
		if(tiddler.fields.tags && tiddler.fields.tags.indexOf(tag) !== -1) {
			titles.push(title);
		}
	}
	return titles;
};

/*
Get a tiddlers content as a JavaScript object. How this is done depends on the type of the tiddler:

application/json: the tiddler JSON is parsed into an object
application/x-tiddler-dictionary: the tiddler is parsed as sequence of name:value pairs

Other types currently just return null.
*/
exports.getTiddlerData = function(title,defaultData) {
	var tiddler = this.tiddlers[title],
		data;
	if(tiddler && tiddler.fields.text) {
		switch(tiddler.fields.type) {
			case "application/json":
				// JSON tiddler
				try {
					data = JSON.parse(tiddler.fields.text);
				} catch(ex) {
					return defaultData;
				}
				return data;
			case "application/x-tiddler-dictionary":
				return $tw.utils.parseFields(tiddler.fields.text);
		}
	}
	return defaultData;
};

/*
Extract an indexed field from within a data tiddler
*/
exports.extractTiddlerDataItem = function(title,index,defaultText) {
	var data = this.getTiddlerData(title,{}),
		text;
	if(data && $tw.utils.hop(data,index)) {
		text = data[index];
	}
	if(typeof text === "string" || typeof text === "number") {
		return text.toString();
	} else {
		return defaultText;
	}
};

/*
Set a tiddlers content to a JavaScript object. Currently this is done by setting the tiddler's type to "application/json" and setting the text to the JSON text of the data.
*/
exports.setTiddlerData = function(title,data) {
	var tiddler = this.getTiddler(title);
	this.addTiddler(new $tw.Tiddler(tiddler,{title: title, type: "application/json", text: JSON.stringify(data,null,$tw.config.preferences.jsonSpaces)}));
};

/*
Return the content of a tiddler as an array containing each line
*/
exports.getTiddlerList = function(title) {
	var tiddler = this.getTiddler(title);
	if(tiddler && tiddler.fields.text && tiddler.fields.text.length > 0) {
		return tiddler.fields.text.split("\n");
	}
	return [];
};

// Return the named cache object for a tiddler. If the cache doesn't exist then the initializer function is invoked to create it
exports.getCacheForTiddler = function(title,cacheName,initializer) {
	this.caches = this.caches || {};
	var caches = this.caches[title];
	if(caches && caches[cacheName]) {
		return caches[cacheName];
	} else {
		if(!caches) {
			caches = {};
			this.caches[title] = caches;
		}
		caches[cacheName] = initializer();
		return caches[cacheName];
	}
};

// Clear all caches associated with a particular tiddler
exports.clearCache = function(title) {
	this.caches = this.caches || {};
	if($tw.utils.hop(this.caches,title)) {
		delete this.caches[title];
	}
};

exports.initParsers = function(moduleType) {
	// Install the new parser modules
	$tw.wiki.parsers = {};
	var self = this;
	$tw.modules.forEachModuleOfType("parser",function(title,module) {
		for(var f in module) {
			if($tw.utils.hop(module,f)) {
				$tw.wiki.parsers[f] = module[f]; // Store the parser class
			}
		}
	});
};

/*
Parse a block of text of a specified MIME type
	type: content type of text to be parsed
	text: text
	options: see below
Options include:
	parseAsInline: if true, the text of the tiddler will be parsed as an inline run
*/
exports.parseText = function(type,text,options) {
	options = options || {};
	// Select a parser
	var Parser = this.parsers[type];
	if(!Parser && $tw.config.fileExtensionInfo[type]) {
		Parser = this.parsers[$tw.config.fileExtensionInfo[type].type];
	}
	if(!Parser) {
		Parser = this.parsers[options.defaultType || "text/vnd.tiddlywiki"];
	}
	if(!Parser) {
		return null;
	}
	// Return the parser instance
	return new Parser(type,text,{
		parseAsInline: options.parseAsInline,
		wiki: this
	});
};

/*
Parse a tiddler according to its MIME type
*/
exports.parseTiddler = function(title,options) {
	options = options || {};
	var cacheType = options.parseAsInline ? "newInlineParseTree" : "newBlockParseTree",
		tiddler = this.getTiddler(title),
		self = this;
	return tiddler ? this.getCacheForTiddler(title,cacheType,function() {
			return self.parseText(tiddler.fields.type,tiddler.fields.text,options);
		}) : null;
};

/*
Parse text in a specified format and render it into another format
	outputType: content type for the output
	textType: content type of the input text
	text: input text
*/
exports.renderText = function(outputType,textType,text) {
	var parser = this.parseText(textType,text),
		renderTree = new $tw.WikiRenderTree(parser,{wiki: this});
	renderTree.execute();
	return renderTree.render(outputType);
};

/*
Parse text from a tiddler and render it into another format
	outputType: content type for the output
	title: title of the tiddler to be rendered
*/
exports.renderTiddler = function(outputType,title) {
	var parser = this.parseTiddler(title),
		renderTree = new $tw.WikiRenderTree(parser,{wiki: this});
	renderTree.execute();
	return renderTree.render(outputType);
};

/*
Select the appropriate saver modules and set them up
*/
exports.initSavers = function(moduleType) {
	moduleType = moduleType || "saver";
	// Instantiate the available savers
	this.savers = [];
	var self = this;
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		if(module.canSave(self)) {
			self.savers.push(module.create(self));
		}
	});
	// Sort the savers into priority order
	this.savers.sort(function(a,b) {
		if(a.info.priority < b.info.priority) {
			return -1;
		} else {
			if(a.info.priority > b.info.priority) {
				return +1;
			} else {
				return 0;
			}
		}
	});
};

/*
Invoke the highest priority saver that successfully handles a method
*/
exports.callSaver = function(method /*, args */ ) {
	for(var t=this.savers.length-1; t>=0; t--) {
		var saver = this.savers[t];
		if(saver[method].apply(saver,Array.prototype.slice.call(arguments,1))) {
			return true;
		}
	}
	return false;
};

/*
Save the wiki contents. Options are:
	template: the tiddler containing the template to save
	downloadType: the content type for the saved file
*/
exports.saveWiki = function(options) {
	options = options || {};
	var template = options.template || "$:/core/templates/tiddlywiki5.template.html",
		downloadType = options.downloadType || "text/plain";
	var text = this.renderTiddler(downloadType,template);
	this.callSaver("save",text);
};

/*
Return an array of tiddler titles that match a search string
	text: The text string to search for
	options: see below
Options available:
	titles:  Hashmap or array of tiddler titles to limit search
	exclude: An array of tiddler titles to exclude from the search
	invert: If true returns tiddlers that do not contain the specified string
	caseSensitive: If true forces a case sensitive search
	literal: If true, searches for literal string, rather than separate search terms
*/
exports.search = function(text,options) {
	options = options || {};
	var me = this,t;
	// Convert the search string into a regexp for each term
	var terms, searchTermsRegExps,
		flags = options.caseSensitive ? "" : "i";
	if(options.literal) {
		if(text.length === 0) {
			return [];
		}
		searchTermsRegExps = [new RegExp("(" + $tw.utils.escapeRegExp(text) + ")",flags)];
	} else {
		terms = text.replace(/( +)/g," ").split(" ");
		searchTermsRegExps = [];
		if(terms.length === 0) {
			return [];
		}
		for(t=0; t<terms.length; t++) {
			searchTermsRegExps.push(new RegExp("(" + $tw.utils.escapeRegExp(terms[t]) + ")",flags));
		}
	}
	// Function to check a given tiddler for the search term
	var searchTiddler = function(title) {
		var tiddler = me.getTiddler(title);
		if(!tiddler) {
			return !!options.invert;
		}
		var contentTypeInfo = $tw.config.contentTypeInfo[tiddler.fields.type];
		if(contentTypeInfo ? contentTypeInfo.encoding === "utf8" : true) {
			var match = true;
			for(var t=0; t<searchTermsRegExps.length; t++) {
				// Search title and body
				if(match) {
					match = searchTermsRegExps[t].test(tiddler.fields.title) || searchTermsRegExps[t].test(tiddler.fields.text);
				}
			}
			return options.invert ? !match : match;
		}
		return false;			
	};
	// Loop through all the tiddlers doing the search
	var results = [];
	if($tw.utils.isArray(options.titles)) {
		for(t=0; t<options.titles.length; t++) {
			if(searchTiddler(options.titles[t])) {
				results.push(options.titles[t]);
			}
		}
	} else {
		var source = options.titles || this.tiddlers;
		for(t in source) {
			if(searchTiddler(t)) {
				results.push(t);
			}
		}
	}
	// Remove any of the results we have to exclude
	if(options.exclude) {
		for(t=0; t<options.exclude.length; t++) {
			var p = results.indexOf(options.exclude[t]);
			if(p !== -1) {
				results.splice(p,1);
			}
		}
	}
	return results;
};

/*
Initialise syncers
*/
exports.initSyncers = function() {
	this.syncers = {};
	var self = this;
	$tw.modules.forEachModuleOfType("syncer",function(title,module) {
		if(module.name && module.syncer) {
			self.syncers[module.name] = new module.syncer({
				wiki: self
			});
		}
	});
};

/*
Invoke all the active syncers
*/
exports.invokeSyncers = function(method /* ,args */) {
	var args = Array.prototype.slice.call(arguments,1);
	for(var name in this.syncers) {
		var syncer = this.syncers[name];
		if(syncer[method]) {
			syncer[method].apply(syncer,args);
		}
	}
};

/*
Trigger a load for a tiddler if it is skinny. Returns the text, or undefined if the tiddler is missing, null if the tiddler is being lazily loaded.
*/
exports.getTiddlerText = function(title,defaultText) {
	var tiddler = this.getTiddler(title);
	// Return undefined if the tiddler isn't found
	if(!tiddler) {
		return defaultText;
	}
	if(tiddler.fields.text !== undefined) {
		// Just return the text if we've got it
		return tiddler.fields.text;
	} else {
		// Ask all the syncers to load the tiddler if they can
		this.invokeSyncers("lazyLoad",title,tiddler);
		// Indicate that the text is being loaded
		return null;
	}
};

})();
});
</script>
</div>
<!----------- Boot kernel ----------->
<div id="bootKernel" style="display:none;">
<script data-tiddler-title="$:/core/boot.js" data-tiddler-type="application/javascript" type="text/javascript">/*\
title: $:/core/boot.js
type: application/javascript

The main boot kernel for TiddlyWiki. This single file creates a barebones TW environment that is just sufficient to bootstrap the modules containing the main logic of the application.

On the server this file is executed directly to boot TiddlyWiki. In the browser, this file is packed into a single HTML file along with other elements:

# bootprefix.js
# <module definitions>
# boot.js

The module definitions on the browser look like this:

	$tw.defineModule("MyModule","moduletype",function(module,exports,require) {
	// Module code inserted here
	return exports;
	});

In practice, each module is wrapped in a separate script block.

\*/
(function() {

/*jslint node: true, browser: true */
/*global modules: false, $tw: false */
"use strict";

/////////////////////////// Setting up $tw

// Set up $tw global for the server
if(typeof(window) === "undefined") {
	global.$tw = global.$tw || {}; // No `browser` member for the server
	exports.$tw = $tw; // Export $tw for when boot.js is required directly in node.js
}

// Include bootprefix if we're on the server
if(!$tw.browser) {
	require("./bootprefix.js");
}

// Boot information
$tw.boot = {};

// Plugin state
$tw.plugins = {};

// Modules store registers all the modules the system has seen
$tw.modules = $tw.modules || {};
$tw.modules.titles = $tw.modules.titles || {}; // hashmap by module title of {fn:, exports:, moduleType:}
$tw.modules.types = $tw.modules.types || {}; // hashmap by module type of hashmap of exports

// Config object
$tw.config = $tw.config || {};

// Constants
$tw.config.pluginsPath = "../plugins/";
$tw.config.wikiInfo = $tw.config.wikiInfo || "./tiddlywiki.info";
$tw.config.wikiPluginsSubDir = $tw.config.wikiPluginsSubDir || "./plugins";
$tw.config.wikiShadowsSubDir = $tw.config.wikiShadowsSubDir || "./wiki";
$tw.config.wikiTiddlersSubDir = $tw.config.wikiTiddlersSubDir || "./tiddlers";

$tw.config.jsModuleHeaderRegExpString = "^\\/\\*\\\\\\n((?:^[^\\n]*\\n)+?)(^\\\\\\*\\/$\\n?)";

// File extension mappings
$tw.config.fileExtensionInfo = {
	".tid": {type: "application/x-tiddler"},
	".tiddler": {type: "application/x-tiddler-html-div"},
	".recipe": {type: "application/vnd.tiddlywiki2-recipe"},
	".txt": {type: "text/plain"},
	".css": {type: "text/css"},
	".html": {type: "text/html"},
	".js": {type: "application/javascript"},
	".json": {type: "application/json"},
	".pdf": {type: "application/pdf"},
	".jpg": {type: "image/jpeg"},
	".jpeg": {type: "image/jpeg"},
	".png": {type: "image/png"},
	".gif": {type: "image/gif"},
	".svg": {type: "image/svg+xml"}
};

// Content type mappings
$tw.config.contentTypeInfo = {
	"text/vnd.tiddlywiki": {encoding: "utf8", extension: ".tid"},
	"application/x-tiddler": {encoding: "utf8", extension: ".tid"},
	"application/x-tiddler-html-div": {encoding: "utf8", extension: ".tiddler"},
	"application/vnd.tiddlywiki2-recipe": {encoding: "utf8", extension: ".recipe"},
	"text/plain": {encoding: "utf8", extension: ".txt"},
	"text/css": {encoding: "utf8", extension: ".css"},
	"text/html": {encoding: "utf8", extension: ".html"},
	"application/javascript": {encoding: "utf8", extension: ".js"},
	"application/json": {encoding: "utf8", extension: ".json"},
	"application/pdf": {encoding: "base64", extension: ".pdf"},
	"image/jpeg": {encoding: "base64", extension: ".jpg"},
	"image/png": {encoding: "base64", extension: ".png"},
	"image/gif": {encoding: "base64", extension: ".gif"},
	"image/svg+xml": {encoding: "utf8", extension: ".svg"}
};

/////////////////////////// Utility functions

$tw.utils = $tw.utils || {};

/*
Log a message
*/
$tw.utils.log = function(/* args */) {
	if(console !== undefined && console.log !== undefined) {
		return window.console && console.log
			&& Function.apply.call(console.log, console, arguments);
	}
};

/*
Check if an object has a property
*/
$tw.utils.hop = function(object,property) {
	return Object.prototype.hasOwnProperty.call(object,property);
};

/*
Determine if a value is an array
*/
$tw.utils.isArray = function(value) {
	return Object.prototype.toString.call(value) == "[object Array]";
};

/*
Iterate through all the own properties of an object or array. Callback is invoked with (element,title,object)
*/
$tw.utils.each = function(object,callback) {
	var f;
	if(object) {
		if($tw.utils.isArray(object)) {
			for(f=0; f<object.length; f++) {
				callback(object[f],f,object);
			}
		} else {
			for(f in object) {
				if($tw.utils.hop(object,f)) {
					callback(object[f],f,object);
				}
			}
		}
	}
};

/*
Convert "&amp;" to &, "&lt;" to <, "&gt;" to > and "&quot;" to "
*/
$tw.utils.htmlDecode = function(s) {
	return s.toString().replace(/&lt;/mg,"<").replace(/&gt;/mg,">").replace(/&quot;/mg,"\"").replace(/&amp;/mg,"&");
};

/*
Pad a string to a given length with "0"s. Length defaults to 2
*/
$tw.utils.pad = function(value,length) {
	length = length || 2;
	var s = value.toString();
	if(s.length < length) {
		s = "000000000000000000000000000".substr(0,length - s.length) + s;
	}
	return s;
};

// Convert a date into YYYYMMDDHHMM format
$tw.utils.stringifyDate = function(value) {
	return value.getUTCFullYear() +
			$tw.utils.pad(value.getUTCMonth() + 1) +
			$tw.utils.pad(value.getUTCDate()) + 
			$tw.utils.pad(value.getUTCHours()) + 
			$tw.utils.pad(value.getUTCMinutes());
};

// Parse a date from a YYYYMMDDHHMMSSMMM format string
$tw.utils.parseDate = function(value) {
	if(typeof value === "string") {
		return new Date(Date.UTC(parseInt(value.substr(0,4),10),
				parseInt(value.substr(4,2),10)-1,
				parseInt(value.substr(6,2),10),
				parseInt(value.substr(8,2)||"00",10),
				parseInt(value.substr(10,2)||"00",10),
				parseInt(value.substr(12,2)||"00",10),
				parseInt(value.substr(14,3)||"000",10)));
	} else if (value instanceof Date) {
		return value;
	} else {
		return null;
	}
};

// Parse a string array from a bracketted list. For example "OneTiddler [[Another Tiddler]] LastOne"
$tw.utils.parseStringArray = function(value) {
	if(typeof value === "string") {
		var memberRegExp = /(?:\[\[([^\]]+)\]\])|([^\s]+)/mg,
			results = [],
			match;
		do {
			match = memberRegExp.exec(value);
			if(match) {
				results.push(match[1] || match[2]);
			}
		} while(match);
		return results;
	} else if ($tw.utils.isArray(value)) {
		return value;
	} else {
		return null;
	}
};

// Parse a block of name:value fields. The `fields` object is used as the basis for the return value
$tw.utils.parseFields = function(text,fields) {
	fields = fields || {};
	text.split(/\r?\n/mg).forEach(function(line) {
		if(line.charAt(0) !== "#") {
			var p = line.indexOf(":");
			if(p !== -1) {
				var field = line.substr(0, p).trim(),
					value = line.substr(p+1).trim();
				fields[field] = value;
			}
		}
	});
	return fields;
};

/*
Resolves a source filepath delimited with `/` relative to a specified absolute root filepath.
In relative paths, the special folder name `..` refers to immediate parent directory, and the
name `.` refers to the current directory
*/
$tw.utils.resolvePath = function(sourcepath,rootpath) {
	// If the source path starts with ./ or ../ then it is relative to the root
	if(sourcepath.substr(0,2) === "./" || sourcepath.substr(0,3) === "../" ) {
		var src = sourcepath.split("/"),
			root = rootpath.split("/");
		// Remove the filename part of the root
		root.splice(root.length-1,1);
		// Process the source path bit by bit onto the end of the root path
		while(src.length > 0) {
			var c = src.shift();
			if(c === "..") { // Slice off the last root entry for a double dot
				if(root.length > 0) {
					root.splice(root.length-1,1);
				}
			} else if(c !== ".") { // Ignore dots
				root.push(c); // Copy other elements across
			}
		}
		return root.join("/");
	} else {
		// If it isn't relative, just return the path
		return sourcepath;
	}
};

/*
Returns true if the `actual` version is greater than or equal to the `required` version. Both are in `x.y.z` format.
*/
$tw.utils.checkVersions = function(required,actual) {
	var targetVersion = required.split("."),
		currVersion = actual.split("."),
		diff = [parseInt(targetVersion[0],10) - parseInt(currVersion[0],10),
				parseInt(targetVersion[1],10) - parseInt(currVersion[1],10),
				parseInt(targetVersion[2],10) - parseInt(currVersion[2],10)];
	return (diff[0] > 0) ||
		(diff[0] === 0 && diff[1] > 0) ||
		(diff[0] === 0 && diff[1] === 0 && diff[2] > 0);
};

/*
Creates a PasswordPrompt object
*/
$tw.utils.PasswordPrompt = function() {
	// Store of pending password prompts
	this.passwordPrompts = [];
	// Create the wrapper
	this.promptWrapper = document.createElement("div");
	this.promptWrapper.className = "tw-password-wrapper";
	document.body.appendChild(this.promptWrapper);
	// Hide the empty wrapper
	this.setWrapperDisplay();
};

/*
Hides or shows the wrapper depending on whether there are any outstanding prompts
*/
$tw.utils.PasswordPrompt.prototype.setWrapperDisplay = function() {
	if(this.passwordPrompts.length) {
		this.promptWrapper.style.display = "block";
	} else {
		this.promptWrapper.style.display = "none";
	}
};

/*
Adds a new password prompt. Options are:
submitText: text to use for submit button (defaults to "Login")
serviceName: text of the human readable service name
noUserName: set true to disable username prompt
callback: function to be called on submission with parameter of object {username:,password:}. Callback must return `true` to remove the password prompt
*/
$tw.utils.PasswordPrompt.prototype.createPrompt = function(options) {
	// Create and add the prompt to the DOM
	var submitText = options.submitText || "Login",
		form = document.createElement("form"),
		html = ["<h1>" + options.serviceName + "</h1>"];
	if(!options.noUserName) {
		html.push("<input type='text' name='username' class='input-small' placeholder='Username'>");
	}
	html.push("<input type='password' name='password' class='input-small' placeholder='Password'>",
			"<button type='submit' class='btn'>" + submitText + "</button>");
	form.className = "form-inline";
	form.innerHTML = html.join("\n");
	this.promptWrapper.appendChild(form);
	window.setTimeout(function() {
		form.elements[0].focus();
	},10);
	// Add a submit event handler
	var self = this;
	form.addEventListener("submit",function(event) {
		// Collect the form data
		var data = {},t;
		for(t=0; t<form.elements.length; t++) {
			var e = form.elements[t];
			if(e.name && e.value) {
				data[e.name] = e.value;
			}
		}
		// Call the callback
		if(options.callback(data)) {
			// Remove the prompt if the callback returned true
			var i = self.passwordPrompts.indexOf(promptInfo);
			if(i !== -1) {
				self.passwordPrompts.splice(i,1);
				promptInfo.form.parentNode.removeChild(promptInfo.form);
				self.setWrapperDisplay();
			}
		} else {
			// Clear the password if the callback returned false
			for(t=0; t<form.elements.length; t++) {
				var e = form.elements[t];
				if(e.name === "password") {
					form.elements[t].value = "";
				}
			}
		}
		event.preventDefault();
		return false;
	},true);
	// Add the prompt to the list
	var promptInfo = {
		serviceName: options.serviceName,
		callback: options.callback,
		form: form
	};
	this.passwordPrompts.push(promptInfo);
	// Make sure the wrapper is displayed
	this.setWrapperDisplay();
};

/*
Crypto helper object for encrypted content. It maintains the password text in a closure, and provides methods to change
the password, and to encrypt/decrypt a block of text
*/
$tw.utils.Crypto = function() {
	var sjcl = $tw.browser ? window.sjcl : require("./sjcl.js"),
		password = null,
		callSjcl = function(method,inputText) {
			var outputText;
			try {
				outputText = sjcl[method](password,inputText);
			} catch(ex) {
				console.log("Crypto error:" + ex);
				outputText = null;	
			}
			return outputText;
		};
	this.setPassword = function(newPassword) {
		password = newPassword;
		this.updateCryptoStateTiddler();
	};
	this.updateCryptoStateTiddler = function() {
		$tw.wiki.addTiddler(new $tw.Tiddler({title: "$:/isEncrypted", text: password ? "yes" : "no"}));
	};
	this.hasPassword = function() {
		return !!password;
	}
	this.encrypt = function(text) {
		return callSjcl("encrypt",text);
	};
	this.decrypt = function(text) {
		return callSjcl("decrypt",text);
	};
};

/////////////////////////// Server initialisation

var fs, path, vm;
if(!$tw.browser) {
	// Standard node libraries
	fs = require("fs");
	path = require("path");
	vm = require("vm");
	// System paths and filenames
	$tw.boot.bootFile = path.basename(module.filename);
	$tw.boot.bootPath = path.dirname(module.filename);
	// If the first command line argument doesn't start with `--` then we
	// interpret it as the path to the wiki folder, which will otherwise default
	// to the current folder
	$tw.boot.argv = Array.prototype.slice.call(process.argv,2);
	if($tw.boot.argv[0] && $tw.boot.argv[0].indexOf("--") !== 0) {
		$tw.boot.wikiPath = $tw.boot.argv[0];
		$tw.boot.argv = $tw.boot.argv.slice(1);
	} else {
		$tw.boot.wikiPath = process.cwd();
	}
	// Read package info
	$tw.packageInfo = JSON.parse(fs.readFileSync($tw.boot.bootPath + "/../package.json"));
	// Check node version number
	if($tw.utils.checkVersions($tw.packageInfo.engines.node.substr(2),process.version.substr(1))) {
		throw "TiddlyWiki5 requires node.js version " + $tw.packageInfo.engine.node;
	}
}

/////////////////////////// Module mechanism

/*
Apply a callback to each module of a particular type
	moduleType: type of modules to enumerate
	callback: function called as callback(title,moduleExports) for each module
*/
$tw.modules.forEachModuleOfType = function(moduleType,callback) {
	var modules = $tw.modules.types[moduleType];
	$tw.utils.each(modules,function(element,title,object) {
		callback(title,$tw.modules.execute(title));
	});
};

/*
Get all the modules of a particular type in a hashmap by their `name` field
*/
$tw.modules.getModulesByTypeAsHashmap = function(moduleType,nameField) {
	nameField = nameField || "name";
	var results = {};
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		results[module[nameField]] = module;
	});
	return results;
};

/*
Apply the exports of the modules of a particular type to a target object
*/
$tw.modules.applyMethods = function(moduleType,targetObject) {
	if(!targetObject) {
		targetObject = {};
	}
	$tw.modules.forEachModuleOfType(moduleType,function(title,module) {
		$tw.utils.each(module,function(element,title,object) {
			targetObject[title] = module[title];
		});
	});
	return targetObject;
};

/*
Return an array of classes created from the modules of a specified type. Each module should export the properties to be added to those of the optional base class
*/
$tw.modules.createClassesFromModules = function(moduleType,subType,baseClass) {
	var classes = {};
	$tw.modules.forEachModuleOfType(moduleType,function(title,moduleExports) {
		if(!subType || moduleExports.types[subType]) {
			var newClass = function() {};
			if(baseClass) {
				newClass.prototype = new baseClass();
				newClass.prototype.constructor = baseClass;
			}
			$tw.utils.extend(newClass.prototype,moduleExports);
			classes[moduleExports.name] = newClass;
		}
	});
	return classes;
};

/////////////////////////// Barebones tiddler object

/*
Construct a tiddler object from a hashmap of tiddler fields. If multiple hasmaps are provided they are merged,
taking precedence to the right
*/
$tw.Tiddler = function(/* [fields,] fields */) {
	this.fields = {};
	for(var c=0; c<arguments.length; c++) {
		var arg = arguments[c],
			src = (arg instanceof $tw.Tiddler) ? arg.fields : arg;
		for(var t in src) {
			if(src[t] === undefined) {
				if(t in this.fields) {
					delete this.fields[t]; // If we get a field that's undefined, delete any previous field value
				}
			} else {
				// Parse the field with the associated field module (if any)
				var fieldModule = $tw.Tiddler.fieldModules[t];
				if(fieldModule) {
					this.fields[t] = fieldModule.parse.call(this,src[t]);
				} else {
					this.fields[t] = src[t];
				}
			}
		}
	}
};

$tw.Tiddler.prototype.hasField = function(field) {
	return $tw.utils.hop(this.fields,field);
};

/*
Hashmap of field modules by field name
*/
$tw.Tiddler.fieldModules = {};

/*
Register and install the built in tiddler field modules
*/
$tw.modules.define("$:/boot/tiddlerfields/modified","tiddlerfield",{
	name: "modified",
	parse: $tw.utils.parseDate,
	stringify: $tw.utils.stringifyDate
});
$tw.modules.define("$:/boot/tiddlerfields/created","tiddlerfield",{
	name: "created",
	parse: $tw.utils.parseDate,
	stringify: $tw.utils.stringifyDate
});
$tw.modules.define("$:/boot/tiddlerfields/tags","tiddlerfield",{
	name: "tags",
	parse: $tw.utils.parseStringArray,
	stringify: function(value) {
		var result = [];
		for(var t=0; t<value.length; t++) {
			if(value[t].indexOf(" ") !== -1) {
				result.push("[[" + value[t] + "]]");
			} else {
				result.push(value[t]);
			}
		}
		return result.join(" ");
	}
});

/////////////////////////// Barebones wiki store

/*
Construct a wiki store object
*/
$tw.Wiki = function() {
	this.tiddlers = {};
	this.bundles = {}; // Hashmap of plugin information by title
	this.bundledTiddlers = {}; // Hashmap of constituent tiddlers from plugins by title
};

$tw.Wiki.prototype.addTiddler = function(tiddler) {
	if(!(tiddler instanceof $tw.Tiddler)) {
		tiddler = new $tw.Tiddler(tiddler);
	}
	this.tiddlers[tiddler.fields.title] = tiddler;
};

$tw.Wiki.prototype.addTiddlers = function(tiddlers) {
	for(var t=0; t<tiddlers.length; t++) {
		this.addTiddler(tiddlers[t]);
	}	
};

/*
Extract constituent tiddlers from bundle tiddlers so that we can easily access them in getTiddler()
*/
$tw.Wiki.prototype.unpackBundleTiddlers = function() {
	// Collect up all the plugin tiddlers
	var self = this;
	$tw.utils.each(this.tiddlers,function(tiddler,title,object) {
		if(tiddler.fields.type === "application/json" && tiddler.hasField("bundle")) {
			// Save the bundle information
			var bundleInfo = self.bundles[title] = JSON.parse(tiddler.fields.text);
			// Extract the constituent tiddlers
			for(var t in bundleInfo.tiddlers) {
				var constituentTiddler = bundleInfo.tiddlers[t],
					constituentTitle = bundleInfo.title + "/" + t;
				// Don't overwrite tiddlers that already exist
				if(!$tw.utils.hop(self.bundledTiddlers,constituentTitle)) {
					// Save the tiddler object
					self.bundledTiddlers[constituentTitle] = new $tw.Tiddler(constituentTiddler,{title: constituentTitle});
				}
			}
		}
	});
};

/*
Define all modules stored in ordinary tiddlers
*/
$tw.Wiki.prototype.defineTiddlerModules = function() {
	$tw.utils.each(this.tiddlers,function(tiddler,title,object) {
		if(tiddler.hasField("module-type")) {
			switch (tiddler.fields.type) {
				case "application/javascript":
					// We don't need to register JavaScript tiddlers in the browser
					if(!$tw.browser) {
						$tw.modules.define(tiddler.fields.title,tiddler.fields["module-type"],tiddler.fields.text);
					}
					break;
				case "application/json":
					$tw.modules.define(tiddler.fields.title,tiddler.fields["module-type"],JSON.parse(tiddler.fields.text));
					break;
				case "application/x-tiddler-dictionary":
					$tw.modules.define(tiddler.fields.title,tiddler.fields["module-type"],$tw.utils.parseFields(tiddler.fields.text));
					break;
			}
		}
	});
};

/*
Register all the module tiddlers that have a module type
*/
$tw.Wiki.prototype.defineBundledModules = function() {
	var self = this;
	$tw.utils.each(this.bundledTiddlers,function(element,title,object) {
		var tiddler = self.getTiddler(title);
		if(!$tw.utils.hop(self.tiddlers,title)) { // Don't define the module if it is overidden by an ordinary tiddler
			if(tiddler.fields.type === "application/javascript" && tiddler.hasField("module-type")) {
				// Define the module
				$tw.modules.define(tiddler.fields.title,tiddler.fields["module-type"],tiddler.fields.text);
			}
		}
	});
};

$tw.Wiki.prototype.getTiddler = function(title) {
	var t = this.tiddlers[title];
	if(t instanceof $tw.Tiddler) {
		return t;
	} else if($tw.utils.hop(this.bundledTiddlers,title)) {
		return this.bundledTiddlers[title];
	} else {
		return undefined;
	}
};

/*
Hashmap of serializer modules by serializer name
*/
$tw.Wiki.tiddlerDeserializerModules = {};

/*
Extracts tiddlers from a typed block of text, specifying default field values
*/
$tw.Wiki.prototype.deserializeTiddlers = function(type,text,srcFields) {
	srcFields = srcFields || {};
	var deserializer = $tw.Wiki.tiddlerDeserializerModules[type],
		fields = {};
	if(!deserializer && $tw.config.fileExtensionInfo[type]) {
		// If we didn't find the serializer, try converting it from an extension to a content type
		type = $tw.config.fileExtensionInfo[type].type;
		deserializer = $tw.Wiki.tiddlerDeserializerModules[type];
	}
	if(!deserializer) {
		// If we still don't have a deserializer, treat it as plain text
		deserializer = $tw.Wiki.tiddlerDeserializerModules["text/plain"];
	}
	for(var f in srcFields) {
		fields[f] = srcFields[f];
	}
	if(deserializer) {
		return deserializer.call(this,text,fields);
	} else {
		// Return a raw tiddler for unknown types
		fields.text = text;
		return [fields];
	}
};

/*
Register the built in tiddler deserializer modules
*/
$tw.modules.define("$:/boot/tiddlerdeserializer/js","tiddlerdeserializer",{
	"application/javascript": function(text,fields) {
		var headerCommentRegExp = new RegExp($tw.config.jsModuleHeaderRegExpString,"mg"),
			match = headerCommentRegExp.exec(text);
		fields.text = text;
		if(match) {
			fields = $tw.utils.parseFields(match[1].split(/\r?\n\r?\n/mg)[0],fields);
		}
		return [fields];
	}
});
$tw.modules.define("$:/boot/tiddlerdeserializer/tid","tiddlerdeserializer",{
	"application/x-tiddler": function(text,fields) {
		var split = text.split(/\r?\n\r?\n/mg);
		if(split.length >= 1) {
			fields = $tw.utils.parseFields(split[0],fields);
		}
		if(split.length >= 2) {
			fields.text = split.slice(1).join("\n\n");
		} else {
			fields.text = "";
		}
		return [fields];
	}
});
$tw.modules.define("$:/boot/tiddlerdeserializer/txt","tiddlerdeserializer",{
	"text/plain": function(text,fields) {
		fields.text = text;
		fields.type = "text/plain";
		return [fields];
	}
});
$tw.modules.define("$:/boot/tiddlerdeserializer/html","tiddlerdeserializer",{
	"text/html": function(text,fields) {
		fields.text = text;
		fields.type = "text/html";
		return [fields];
	}
});
$tw.modules.define("$:/boot/tiddlerdeserializer/json","tiddlerdeserializer",{
	"application/json": function(text,fields) {
		var tiddlers = JSON.parse(text);
		return tiddlers;
	}
});

/////////////////////////// Intermediate initialisation

/*
Create the wiki store for the app
*/
$tw.wiki = new $tw.Wiki();

/////////////////////////// Browser definitions

if($tw.browser) {

/*
Decrypt any tiddlers stored within the element with the ID "encryptedArea". The function is asynchronous to allow the user to be prompted for a password
	callback: function to be called the decryption is complete
*/
$tw.boot.decryptEncryptedTiddlers = function(callback) {
	var encryptedArea = document.getElementById("encryptedStoreArea");
	if(encryptedArea) {
		var encryptedText = encryptedArea.innerHTML;
		// Prompt for the password
		$tw.passwordPrompt.createPrompt({
			serviceName: "Enter a password to decrypt this TiddlyWiki",
			noUserName: true,
			submitText: "Decrypt",
			callback: function(data) {
				// Attempt to decrypt the tiddlers
				$tw.crypto.setPassword(data.password);
				var decryptedText = $tw.crypto.decrypt(encryptedText);
				if(decryptedText) {
					var json = JSON.parse(decryptedText);
					for(var title in json) {
						$tw.preloadTiddler(json[title]);
					}
					// Call the callback
					callback();
					// Exit and remove the password prompt
					return true;
				} else {
					// We didn't decrypt everything, so continue to prompt for password
					return false;
				}
			}
		});
	} else {
		// Just invoke the callback straight away if there weren't any encrypted tiddlers
		callback();
	}
};

/*
Execute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'
*/
$tw.modules.execute = function(moduleName,moduleRoot) {
	/*jslint evil: true */
	var name = moduleRoot ? $tw.utils.resolvePath(moduleName,moduleRoot) : moduleName,
		require = function(modRequire) {
			return $tw.modules.execute(modRequire,name);
		},
		exports = {},
		moduleInfo = $tw.modules.titles[name];
	if(!moduleInfo) {
		throw new Error("Cannot find module named '" + moduleName + "' required by module '" + moduleRoot + "', resolved to " + name);
	}
	if(!moduleInfo.exports) {
		if(typeof moduleInfo.definition === "string") { // String
			moduleInfo.definition = window["eval"]("(function(module,exports,require) {" + moduleInfo.definition + "})");
			moduleInfo.exports = {};
			moduleInfo.definition(moduleInfo,moduleInfo.exports,require);
		} else if(typeof moduleInfo.definition === "function") { // Function
			moduleInfo.exports = {};
			moduleInfo.definition(moduleInfo,moduleInfo.exports,require);
		} else { // Object
			moduleInfo.exports = moduleInfo.definition;
		}
	}
	return moduleInfo.exports;
};

/*
Register a deserializer that can extract tiddlers from the DOM
*/
$tw.modules.define("$:/boot/tiddlerdeserializer/dom","tiddlerdeserializer",{
	"(DOM)": function(node) {
		var extractTextTiddlers = function(node) {
				var e = node.firstChild;
				while(e && e.nodeName.toLowerCase() !== "pre") {
					e = e.nextSibling;
				}
				var title = node.getAttribute ? node.getAttribute("title") : null;
				if(e && title) {
					var attrs = node.attributes,
						tiddler = {
							text: $tw.utils.htmlDecode(e.innerHTML)
						};
					for(var i=attrs.length-1; i >= 0; i--) {
						tiddler[attrs[i].name] = attrs[i].value;
					}
					return [tiddler];
				} else {
					return null;
				}
			},
			extractModuleTiddlers = function(node) {
				if(node.hasAttribute && node.hasAttribute("data-tiddler-title")) {
					var text = node.innerHTML,
						s = text.indexOf("{"),
						e = text.lastIndexOf("}");
					if(node.hasAttribute("data-module") && s !== -1 && e !== -1) {
						text = text.substring(s+1,e);
					}
					var fields = {text: text},
						attributes = node.attributes;
					for(var a=0; a<attributes.length; a++) {
						if(attributes[a].nodeName.substr(0,13) === "data-tiddler-") {
							fields[attributes[a].nodeName.substr(13)] = attributes[a].value;
						}
					}
					return [fields];
				} else {
					return null;
				}
			},
			t,result = [];
		if(node) {
			for(t = 0; t < node.childNodes.length; t++) {
					var tiddlers = extractTextTiddlers(node.childNodes[t]),
						childNode = node.childNodes[t];
					tiddlers = tiddlers || extractModuleTiddlers(childNode);
					if(tiddlers) {
						result.push.apply(result,tiddlers);
					}
			}
		}
		return result;
	}
});

$tw.loadTiddlers = function() {
	// In the browser, we load tiddlers from certain elements
	var containerIds = [
		"libraryModules",
		"modules",
		"bootKernelPrefix",
		"bootKernel",
		"styleArea",
		"storeArea",
		"shadowArea"
	];
	for(var t=0; t<containerIds.length; t++) {
		$tw.wiki.addTiddlers($tw.wiki.deserializeTiddlers("(DOM)",document.getElementById(containerIds[t])));
	}
	// Load any preloaded tiddlers
	if($tw.preloadTiddlers) {
		$tw.wiki.addTiddlers($tw.preloadTiddlers);
	}
};

// End of if($tw.browser)
}

/////////////////////////// Server definitions

if(!$tw.browser) {

/*
Get any encrypted tiddlers
*/
$tw.boot.decryptEncryptedTiddlers = function(callback) {
	// Storing encrypted tiddlers on the server isn't supported yet
	callback();
};

/*
Load the tiddlers contained in a particular file (and optionally extract fields from the accompanying .meta file)
*/
$tw.loadTiddlersFromFile = function(filepath,fields) {
	var ext = path.extname(filepath),
		extensionInfo = $tw.config.fileExtensionInfo[ext],
		typeInfo = extensionInfo ? $tw.config.contentTypeInfo[extensionInfo.type] : null,
		data = fs.readFileSync(filepath,typeInfo ? typeInfo.encoding : "utf8"),
		tiddlers = $tw.wiki.deserializeTiddlers(ext,data,fields),
		metafile = filepath + ".meta";
	if(ext !== ".json" && tiddlers.length === 1 && fs.existsSync(metafile)) {
		var metadata = fs.readFileSync(metafile,"utf8");
		if(metadata) {
			tiddlers = [$tw.utils.parseFields(metadata,tiddlers[0])];
		}
	}
	return tiddlers;
};

/*
Load all the tiddlers from a directory
*/
$tw.loadTiddlersFromPath = function(filepath,excludeRegExp) {
	excludeRegExp = excludeRegExp || /^\.DS_Store$|.meta$/;
	var tiddlers = [],
		stat, files, pluginInfo, pluginTiddlers, f, file, titlePrefix, t, filesInfo, p, tidInfo, typeInfo, text;
	if(fs.existsSync(filepath)) {
		stat = fs.statSync(filepath);
		if(stat.isDirectory()) {
			files = fs.readdirSync(filepath);
			// Look for a tiddlywiki.files file
			if(files.indexOf("tiddlywiki.files") !== -1) {
				// If so, process the files it describes
				filesInfo = JSON.parse(fs.readFileSync(filepath + "/tiddlywiki.files","utf8"));
				for(p=0; p<filesInfo.tiddlers.length; p++) {
					tidInfo = filesInfo.tiddlers[p];
					typeInfo = $tw.config.contentTypeInfo[tidInfo.fields.type || "text/plain"];
					text = fs.readFileSync(path.resolve(filepath,tidInfo.file),typeInfo ? typeInfo.encoding : "utf8");
					tidInfo.fields.text = text;
					tiddlers.push(tidInfo.fields);
				}
			} else {
				// If not, read all the files in the directory
				for(f=0; f<files.length; f++) {
					file = files[f];
					if(!excludeRegExp.test(file)) {
						tiddlers.push.apply(tiddlers,$tw.loadTiddlersFromPath(filepath + "/" + file,excludeRegExp));
					}
				}
			}
		} else if(stat.isFile()) {
			tiddlers.push.apply(tiddlers,$tw.loadTiddlersFromFile(filepath));
		}
	}
	return tiddlers;
};

/*
Load the tiddlers from a bundle folder, and package them up into a proper JSON bundle tiddler
*/
$tw.loadBundleFolder = function(filepath,excludeRegExp) {
	excludeRegExp = excludeRegExp || /^\.DS_Store$|.meta$/;
	var stat, files, bundleInfo, bundleTiddlers = [], f, file, titlePrefix, t;
	if(fs.existsSync(filepath)) {
		stat = fs.statSync(filepath);
		if(stat.isDirectory()) {
			files = fs.readdirSync(filepath);
			// Read the plugin information
			bundleInfo = JSON.parse(fs.readFileSync(filepath + "/plugin.bundle","utf8"));
			// Read the bundle files
			for(f=0; f<files.length; f++) {
				file = files[f];
				if(!excludeRegExp.test(file) && file !== "plugin.bundle" && file !== "tiddlywiki.files") {
					bundleTiddlers.push.apply(bundleTiddlers,$tw.loadTiddlersFromPath(filepath + "/" + file,excludeRegExp));
				}
			}
			// Save the bundle tiddlers into the bundle
			bundleInfo.tiddlers = bundleInfo.tiddlers || {};
			titlePrefix = bundleInfo.title + "/";
			for(t=0; t<bundleTiddlers.length; t++) {
				// Check that the constituent tiddler has the bundle title as a prefix
				if(bundleTiddlers[t].title.indexOf(titlePrefix) === 0 && bundleTiddlers[t].title.length > titlePrefix.length) {
					bundleInfo.tiddlers[bundleTiddlers[t].title.substr(titlePrefix.length)] = bundleTiddlers[t];
				} else {
					console.log("Error extracting plugin bundle: The bundle '" + bundleInfo.title + "' cannot contain a tiddler titled '" + bundleTiddlers[t].title + "'");
				}
			}
		}
	}
	// Save the bundle tiddler
	return bundleInfo ? {
		title: bundleInfo.title,
		type: "application/json",
		bundle: "yes",
		text: JSON.stringify(bundleInfo,null,4)
	} : null;
};

/*
Execute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'
*/
$tw.modules.execute = function(moduleName,moduleRoot) {
	var name = moduleRoot ? $tw.utils.resolvePath(moduleName,moduleRoot) : moduleName,
		moduleInfo = $tw.modules.titles[name],
		tiddler = $tw.wiki.getTiddler(name),
		sandbox = {
			module: moduleInfo,
			exports: {},
			console: console,
			process: process,
			$tw: $tw,
			require: function(title) {
				return $tw.modules.execute(title,name);
			}
		};
	if(!moduleInfo) {
		// If we don't have a module with that name, let node.js try to find it
		return require(moduleName);
	}
	// Execute the module if we haven't already done so
	if(!moduleInfo.exports) {
		try {
			// Check the type of the definition
			if(typeof moduleInfo.definition === "string") { // String
				vm.runInNewContext(moduleInfo.definition,sandbox,tiddler.fields.title);
				moduleInfo.exports = sandbox.exports;
			} else if(typeof moduleInfo.definition === "function") { // Function
				moduleInfo.exports = moduleInfo.definition(moduleInfo,sandbox.require,moduleInfo.exports);
			} else { // Object
				moduleInfo.exports = moduleInfo.definition;
			}
		} catch(e) {
			throw "Error executing boot module " + name + ":\n" + e;
		}
	}
	// Return the exports of the module
	return moduleInfo.exports;
};

$tw.loadTiddlers = function() {
	// On the server, we load tiddlers from specified folders
	var folders = [
		$tw.boot.bootPath,
		path.resolve($tw.boot.wikiPath,$tw.config.wikiShadowsSubDir),
		path.resolve($tw.boot.wikiPath,$tw.config.wikiTiddlersSubDir)
	];
	for(var t=0; t<folders.length; t++) {
		$tw.wiki.addTiddlers($tw.loadTiddlersFromPath(folders[t]));
	}
	// Load any plugins listed in the wiki info file
	var wikiInfoPath = path.resolve($tw.boot.wikiPath,$tw.config.wikiInfo),
		bundle;
	if(fs.existsSync(wikiInfoPath)) {
		var wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath,"utf8")),
			pluginBasePath = path.resolve($tw.boot.bootPath,$tw.config.pluginsPath);
		for(t=0; t<wikiInfo.plugins.length; t++) {
			bundle = $tw.loadBundleFolder(path.resolve(pluginBasePath,"./" + wikiInfo.plugins[t]));
			if(bundle) {
				$tw.wiki.addTiddler(bundle);
			}
		}
	}
	// Load any plugins within the wiki folder
	var wikiPluginsPath = path.resolve($tw.boot.wikiPath,$tw.config.wikiPluginsSubDir);
	if(fs.existsSync(wikiPluginsPath)) {
		var pluginFolders = fs.readdirSync(wikiPluginsPath);
		for(t=0; t<pluginFolders.length; t++) {
			bundle = $tw.loadBundleFolder(path.resolve(wikiPluginsPath,"./" + pluginFolders[t]));
			if(bundle) {
				$tw.wiki.addTiddler(bundle);
			}
		}
	}
};

// End of if(!$tw.browser)	
}

/////////////////////////// Starting up

/*
Main startup function
*/
$tw.boot.startup = function() {
	// Install built in tiddler fields modules
	$tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap("tiddlerfield");
	// Install the tiddler deserializer modules
	$tw.modules.applyMethods("tiddlerdeserializer",$tw.Wiki.tiddlerDeserializerModules);
	// Load tiddlers
	$tw.loadTiddlers();
	// Unpack bundle tiddlers
	$tw.wiki.unpackBundleTiddlers();
	// Register typed modules from the tiddlers we've just loaded
	$tw.wiki.defineTiddlerModules();
	// And any modules within bundles
	$tw.wiki.defineBundledModules();
	// Make sure the crypto state tiddler is up to date
	$tw.crypto.updateCryptoStateTiddler();
	// Run any startup modules
	$tw.modules.forEachModuleOfType("startup",function(title,module) {
		if(module.startup) {
			module.startup();
		}
	});
};

/*
Initialise crypto and then startup
*/
// Initialise crypto object
$tw.crypto = new $tw.utils.Crypto();
// Initialise password prompter
if($tw.browser) {
	$tw.passwordPrompt = new $tw.utils.PasswordPrompt();
}
// Get any encrypted tiddlers
$tw.boot.decryptEncryptedTiddlers(function() {
	$tw.boot.startup();
});

})();
</script>
</div>
</body>
</html>
